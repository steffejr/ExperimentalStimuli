ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
S'/Users/jason/Dropbox/SteffenerColumbia/Scripts/ExperimentalStimuli/PartialTrialDIR/Scripts/PsychoPyTask/data/2004_1_PartialTrial_Run2_2016_02_05_1350'
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'PartialTrial'
p11
sS'dataNames'
p12
(lp13
S'ScannerTrigger.keys'
p14
aS'ScannerTrigger.rt'
p15
aS'TrialStartTime'
p16
aS'KeyboardResp.keys'
p17
aS'KeyboardResp.corr'
p18
aS'KeyboardResp.rt'
p19
asS'autoLog'
p20
I01
sS'extraInfo'
p21
(dp22
VParticipant ID
p23
I2004
sS'date'
p24
V2016_Feb_05_1350
p25
sS'expName'
p26
g11
sVVisit ID
p27
I1
sS'frameRate'
p28
cnumpy.core.multiarray
scalar
p29
(cnumpy
dtype
p30
(S'f8'
I0
I1
tRp31
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00x\x00@\xfc\xffM@'
tRp32
ssS'loopsUnfinished'
p33
(lp34
sS'saveWideText'
p35
I01
sS'thisEntry'
p36
(dp37
sS'version'
p38
S''
sS'_paramNamesSoFar'
p39
(lp40
S'RetDur'
p41
aS'BotBrack'
p42
aS'StimDur'
p43
aS'UpBrack'
p44
aS'ProbeDurITI'
p45
aS'ProbeDur'
p46
aS'ProbeStart'
p47
aS'TrialDur'
p48
aS'ITI'
p49
aS'StimSet'
p50
aS'RetStart'
p51
aS'ProbeLet'
p52
aS'TrialITIDur'
p53
aS'Correct'
p54
asS'entries'
p55
(lp56
(dp57
g23
I2004
sS'trials.thisIndex'
p58
I0
sg26
g11
sg27
I1
sS'trials.thisRepN'
p59
I0
sg28
g32
sS'trials.thisN'
p60
I-1
sg15
F17.556122064590454
sS'trials.thisTrialN'
p61
I-1
sg24
g25
sg14
S'equal'
p62
sa(dp63
g23
I2004
sS'trials.thisIndex'
p64
I0
sg27
I1
sS'trials.thisRepN'
p65
I0
sg28
g32
sg16
F1454698262.8252771
sS'trials.thisN'
p66
I-1
sg26
g11
sS'trials.thisTrialN'
p67
I-1
sg24
g25
sa(dp68
g23
I2004
sg28
g32
sg48
g29
(g30
(S'i8'
I0
I1
tRp69
(I3
S'<'
NNNI-1
I-1
I0
tbS'\t\x00\x00\x00\x00\x00\x00\x00'
tRp70
sg19
(lp71
F1.0012698173522949
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp72
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp73
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp74
sg16
F1454698272.82162
sS'trials.thisN'
p75
I0
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp76
sg44
g29
(g69
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp77
sg45
g29
(g31
S'\xbbI\x0c\x02+\x07\x18@'
tRp78
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp79
sg50
VLXDRFJ
p80
sg24
g25
sg52
Vgynqbh
p81
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp82
sS'trials.thisIndex'
p83
g29
(g30
(S'i4'
I0
I1
tRp84
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00'
tRp85
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp86
sS'trials.thisRepN'
p87
I0
sg49
g29
(g31
S'\xbaI\x0c\x02+\x07\x10@'
tRp88
sg26
g11
sS'trials.thisTrialN'
p89
I0
sg53
g29
(g31
S'\xdd$\x06\x81\x95\x03*@'
tRp90
sg17
(lp91
S'8'
asa(dp92
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp93
sg44
g29
(g69
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp94
sg45
g29
(g31
S'5^\xbaI\x0c\x02\x10@'
tRp95
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp96
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp97
sg50
VYXDMLR
p98
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp99
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp100
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp101
sS'trials.thisIndex'
p102
g29
(g84
S'\x01\x00\x00\x00'
tRp103
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp104
sS'trials.thisRepN'
p105
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp106
sg16
F1454698285.828773
sg28
g32
sS'trials.thisN'
p107
I1
sg49
g29
(g31
S'5^\xbaI\x0c\x02\x10@'
tRp108
sS'trials.thisTrialN'
p109
I1
sg53
g29
(g31
S'6^\xbaI\x0c\x02\x18@'
tRp110
sg17
Nsa(dp111
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp112
sg44
g29
(g69
S'8\x00\x00\x00\x00\x00\x00\x00'
tRp113
sg45
g29
(g31
S'A`\xe5\xd0"[\x10@'
tRp114
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp115
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp116
sg50
VGKQNHJ
p117
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp118
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp119
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp120
sS'trials.thisIndex'
p121
g29
(g84
S'\x02\x00\x00\x00'
tRp122
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp123
sS'trials.thisRepN'
p124
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp125
sg16
F1454698291.8310039
sg28
g32
sS'trials.thisN'
p126
I2
sg49
g29
(g31
S'A`\xe5\xd0"[\x10@'
tRp127
sS'trials.thisTrialN'
p128
I2
sg53
g29
(g31
S'A`\xe5\xd0"[\x18@'
tRp129
sg17
Nsa(dp130
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp131
sg19
(lp132
F0.81798911094665527
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp133
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp134
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp135
sg16
F1454698297.917325
sS'trials.thisN'
p136
I3
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp137
sg44
g29
(g69
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp138
sg45
g29
(g31
S'\x92\xed|?5\xde\x1b@'
tRp139
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp140
sg50
VJDMHWQ
p141
sg24
g25
sg52
Vxrtdgl
p142
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp143
sS'trials.thisIndex'
p144
g29
(g84
S'\x03\x00\x00\x00'
tRp145
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp146
sS'trials.thisRepN'
p147
I0
sg49
g29
(g31
S'\x91\xed|?5\xde\x13@'
tRp148
sg26
g11
sS'trials.thisTrialN'
p149
I3
sg53
g29
(g31
S'\xc9v\xbe\x9f\x1a\xef+@'
tRp150
sg17
(lp151
S'7'
asa(dp152
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp153
sg44
g29
(g69
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp154
sg45
g29
(g31
S'\xcd\xcc\xcc\xcc\xccL\x10@'
tRp155
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp156
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp157
sg50
VTJFXRG
p158
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp159
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp160
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp161
sS'trials.thisIndex'
p162
g29
(g84
S'\x04\x00\x00\x00'
tRp163
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp164
sS'trials.thisRepN'
p165
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp166
sg16
F1454698311.8834989
sg28
g32
sS'trials.thisN'
p167
I4
sg49
g29
(g31
S'\xcd\xcc\xcc\xcc\xccL\x10@'
tRp168
sS'trials.thisTrialN'
p169
I4
sg53
g29
(g31
S'fffff&&@'
tRp170
sg17
Nsa(dp171
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp172
sg19
(lp173
F1.2005331516265869
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp174
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp175
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp176
sg16
F1454698322.9537089
sS'trials.thisN'
p177
I5
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp178
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp179
sg45
g29
(g31
S'R\xb8\x1e\x85\xebQ\x18@'
tRp180
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp181
sg50
VWKXGRJ
p182
sg24
g25
sg52
Vnrbfth
p183
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp184
sS'trials.thisIndex'
p185
g29
(g84
S'\x05\x00\x00\x00'
tRp186
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp187
sS'trials.thisRepN'
p188
I0
sg49
g29
(g31
S'R\xb8\x1e\x85\xebQ\x10@'
tRp189
sg26
g11
sS'trials.thisTrialN'
p190
I5
sg53
g29
(g31
S')\\\x8f\xc2\xf5(*@'
tRp191
sg17
(lp192
S'7'
asa(dp193
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp194
sg44
g29
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp195
sg45
g29
(g31
S'\xee|?5^:\x18@'
tRp196
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp197
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp198
sg50
VRYXTHJ
p199
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp200
sg24
g25
sg52
Vmwnbyd
p201
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp202
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp203
sS'trials.thisIndex'
p204
g29
(g84
S'\x06\x00\x00\x00'
tRp205
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp206
sS'trials.thisRepN'
p207
I0
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp208
sg16
F1454698336.0252669
sg28
g32
sS'trials.thisN'
p209
I6
sg49
g29
(g31
S'\xed|?5^:\x10@'
tRp210
sS'trials.thisTrialN'
p211
I6
sg53
g29
(g31
S'w\xbe\x9f\x1a/\x1d*@'
tRp212
sg17
Nsa(dp213
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp214
sg44
g29
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp215
sg45
g29
(g31
S'J\x0c\x02+\x87\x16\x10@'
tRp216
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp217
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp218
sg50
VDHTFLB
p219
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp220
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp221
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp222
sS'trials.thisIndex'
p223
g29
(g84
S'\x07\x00\x00\x00'
tRp224
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp225
sS'trials.thisRepN'
p226
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp227
sg16
F1454698349.079946
sg28
g32
sS'trials.thisN'
p228
I7
sg49
g29
(g31
S'J\x0c\x02+\x87\x16\x10@'
tRp229
sS'trials.thisTrialN'
p230
I7
sg53
g29
(g31
S'%\x06\x81\x95C\x0b&@'
tRp231
sg17
Nsa(dp232
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp233
sg19
(lp234
F0.81807398796081543
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp235
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp236
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp237
sg16
F1454698360.100986
sS'trials.thisN'
p238
I8
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp239
sg44
g29
(g69
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp240
sg45
g29
(g31
S'\x8cl\xe7\xfb\xa9\xf1\x19@'
tRp241
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp242
sg50
VNFJTWY
p243
sg24
g25
sg52
Vxmrbhg
p244
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp245
sS'trials.thisIndex'
p246
g29
(g84
S'\x08\x00\x00\x00'
tRp247
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp248
sS'trials.thisRepN'
p249
I0
sg49
g29
(g31
S'\x8cl\xe7\xfb\xa9\xf1\x11@'
tRp250
sg26
g11
sS'trials.thisTrialN'
p251
I8
sg53
g29
(g31
S'E\xb6\xf3\xfd\xd4\xf8*@'
tRp252
sg17
(lp253
S'8'
asa(dp254
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp255
sg44
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp256
sg45
g29
(g31
S'c\x10X9\xb4\xc8\x12@'
tRp257
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp258
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp259
sg50
VYNXJRW
p260
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp261
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp262
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp263
sS'trials.thisIndex'
p264
g29
(g84
S'\t\x00\x00\x00'
tRp265
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp266
sS'trials.thisRepN'
p267
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp268
sg16
F1454698373.5908389
sg28
g32
sS'trials.thisN'
p269
I9
sg49
g29
(g31
S'c\x10X9\xb4\xc8\x12@'
tRp270
sS'trials.thisTrialN'
p271
I9
sg53
g29
(g31
S"1\x08\xac\x1cZd'@"
tRp272
sg17
Nsa(dp273
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp274
sg44
g29
(g69
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp275
sg45
g29
(g31
S'j\xbct\x93\x18\x04\x10@'
tRp276
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp277
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp278
sg50
VNQYXLJ
p279
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp280
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp281
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp282
sS'trials.thisIndex'
p283
g29
(g84
S'\n\x00\x00\x00'
tRp284
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp285
sS'trials.thisRepN'
p286
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp287
sg16
F1454698385.2792931
sg28
g32
sS'trials.thisN'
p288
I10
sg49
g29
(g31
S'j\xbct\x93\x18\x04\x10@'
tRp289
sS'trials.thisTrialN'
p290
I10
sg53
g29
(g31
S'j\xbct\x93\x18\x04\x18@'
tRp291
sg17
Nsa(dp292
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp293
sg19
(lp294
F1.0513300895690918
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp295
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp296
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp297
sg16
F1454698391.282697
sS'trials.thisN'
p298
I11
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp299
sg44
g29
(g69
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp300
sg45
g29
(g31
S'\xb6\xf3\xfd\xd4xi\x18@'
tRp301
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp302
sg50
VMHFLXR
p303
sg24
g25
sg52
Vjkdtnf
p304
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp305
sS'trials.thisIndex'
p306
g29
(g84
S'\x0b\x00\x00\x00'
tRp307
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp308
sS'trials.thisRepN'
p309
I0
sg49
g29
(g31
S'\xb6\xf3\xfd\xd4xi\x10@'
tRp310
sg26
g11
sS'trials.thisTrialN'
p311
I11
sg53
g29
(g31
S'\xdb\xf9~j\xbc4 @'
tRp312
sg17
(lp313
S'7'
asa(dp314
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp315
sg19
(lp316
F1.3017380237579346
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp317
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp318
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp319
sg16
F1454698399.3870571
sS'trials.thisN'
p320
I12
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp321
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp322
sg45
g29
(g31
S'\x9a\x99\x99\x99\x99\x99\x1a@'
tRp323
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp324
sg50
VHGDJQF
p325
sg24
g25
sg52
Vbqlxwr
p326
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp327
sS'trials.thisIndex'
p328
g29
(g84
S'\x0c\x00\x00\x00'
tRp329
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp330
sS'trials.thisRepN'
p331
I0
sg49
g29
(g31
S'\x9a\x99\x99\x99\x99\x99\x12@'
tRp332
sg26
g11
sS'trials.thisTrialN'
p333
I12
sg53
g29
(g31
S'\xcd\xcc\xcc\xcc\xccL!@'
tRp334
sg17
(lp335
S'7'
asa(dp336
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp337
sg19
(lp338
F1.0178117752075195
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp339
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp340
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp341
sg16
F1454698408.041985
sS'trials.thisN'
p342
I13
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp343
sg44
g29
(g69
S'\x0c\x00\x00\x00\x00\x00\x00\x00'
tRp344
sg45
g29
(g31
S'\xe5\xd0"\xdb\xf9\xfe\x19@'
tRp345
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp346
sg50
VBKGRHD
p347
sg24
g25
sg52
Vnjqxfy
p348
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp349
sS'trials.thisIndex'
p350
g29
(g84
S'\r\x00\x00\x00'
tRp351
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp352
sS'trials.thisRepN'
p353
I0
sg49
g29
(g31
S'\xe5\xd0"\xdb\xf9\xfe\x11@'
tRp354
sg26
g11
sS'trials.thisTrialN'
p355
I13
sg53
g29
(g31
S'sh\x91\xed|\xff*@'
tRp356
sg17
(lp357
S'8'
asa(dp358
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp359
sg19
(lp360
F1.4010229110717773
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp361
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp362
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp363
sg16
F1454698421.539469
sS'trials.thisN'
p364
I14
sg42
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp365
sg44
g29
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp366
sg45
g29
(g31
S'\xa8\xc6K7\x89A\x19@'
tRp367
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp368
sg50
VXKGNRJ
p369
sg24
g25
sg52
Vlytmqh
p370
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp371
sS'trials.thisIndex'
p372
g29
(g84
S'\x0e\x00\x00\x00'
tRp373
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp374
sS'trials.thisRepN'
p375
I0
sg49
g29
(g31
S'\xa8\xc6K7\x89A\x11@'
tRp376
sg26
g11
sS'trials.thisTrialN'
p377
I14
sg53
g29
(g31
S'T\xe3\xa5\x9b\xc4\xa0*@'
tRp378
sg17
(lp379
S'8'
asa(dp380
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp381
sg19
(lp382
F0.81773900985717773
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp383
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp384
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp385
sg16
F1454698434.844389
sS'trials.thisN'
p386
I15
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp387
sg44
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp388
sg45
g29
(g31
S'D\x8bl\xe7\xfb\xa9\x18@'
tRp389
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp390
sg50
VLNRXJH
p391
sg24
g25
sg52
Vkgdyfm
p392
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp393
sS'trials.thisIndex'
p394
g29
(g84
S'\x0f\x00\x00\x00'
tRp395
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp396
sS'trials.thisRepN'
p397
I0
sg49
g29
(g31
S'D\x8bl\xe7\xfb\xa9\x10@'
tRp398
sg26
g11
sS'trials.thisTrialN'
p399
I15
sg53
g29
(g31
S'\xa2E\xb6\xf3\xfdT @'
tRp400
sg17
(lp401
S'8'
asa(dp402
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp403
sg19
(lp404
F1.2847609519958496
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp405
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp406
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp407
sg16
F1454698443.013654
sS'trials.thisN'
p408
I16
sg42
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp409
sg44
g29
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp410
sg45
g29
(g31
S'E\xb6\xf3\xfd\xd4x\x1c@'
tRp411
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp412
sg50
VMDJHWK
p413
sg24
g25
sg52
Vbtfgkr
p414
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp415
sS'trials.thisIndex'
p416
g29
(g84
S'\x10\x00\x00\x00'
tRp417
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp418
sS'trials.thisRepN'
p419
I0
sg49
g29
(g31
S'F\xb6\xf3\xfd\xd4x\x14@'
tRp420
sg26
g11
sS'trials.thisTrialN'
p421
I16
sg53
g29
(g31
S'#\xdb\xf9~j<"@'
tRp422
sg17
(lp423
S'7'
asa(dp424
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp425
sg19
(lp426
F0.73456501960754395
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp427
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp428
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp429
sg16
F1454698452.133673
sS'trials.thisN'
p430
I17
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp431
sg44
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp432
sg45
g29
(g31
S'Nb\x10X94\x18@'
tRp433
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp434
sg50
VMWLDYH
p435
sg24
g25
sg52
Vnkjfgr
p436
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp437
sS'trials.thisIndex'
p438
g29
(g84
S'\x11\x00\x00\x00'
tRp439
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp440
sS'trials.thisRepN'
p441
I0
sg49
g29
(g31
S'Nb\x10X94\x10@'
tRp442
sg26
g11
sS'trials.thisTrialN'
p443
I17
sg53
g29
(g31
S'&1\x08\xac\x1c\x1a*@'
tRp444
sg17
(lp445
S'8'
asa(dp446
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp447
sg19
(lp448
F0.85099601745605469
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp449
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp450
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp451
sg16
F1454698465.189549
sS'trials.thisN'
p452
I18
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp453
sg44
g29
(g69
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp454
sg45
g29
(g31
S'\x08\xac\x1cZd;\x18@'
tRp455
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp456
sg50
VTXJGDQ
p457
sg24
g25
sg52
Vryfbmw
p458
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp459
sS'trials.thisIndex'
p460
g29
(g84
S'\x12\x00\x00\x00'
tRp461
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp462
sS'trials.thisRepN'
p463
I0
sg49
g29
(g31
S'\x08\xac\x1cZd;\x10@'
tRp464
sg26
g11
sS'trials.thisTrialN'
p465
I18
sg53
g29
(g31
S'\x04V\x0e-\xb2\x1d @'
tRp466
sg17
(lp467
S'8'
asa(dp468
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp469
sg19
(lp470
F0.8170781135559082
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp471
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp472
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp473
sg16
F1454698473.2427759
sS'trials.thisN'
p474
I19
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp475
sg44
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp476
sg45
g29
(g31
S'\xda\xce\xf7S\xe3\xa5\x18@'
tRp477
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp478
sg50
VFQHLYT
p479
sg24
g25
sg52
Vxrjdkn
p480
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp481
sS'trials.thisIndex'
p482
g29
(g84
S'\x13\x00\x00\x00'
tRp483
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp484
sS'trials.thisRepN'
p485
I0
sg49
g29
(g31
S'\xd9\xce\xf7S\xe3\xa5\x10@'
tRp486
sg26
g11
sS'trials.thisTrialN'
p487
I19
sg53
g29
(g31
S'm\xe7\xfb\xa9\xf1R*@'
tRp488
sg17
(lp489
S'8'
asa(dp490
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp491
sg19
(lp492
F1.1675281524658203
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp493
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp494
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp495
sg16
F1454698486.3992801
sS'trials.thisN'
p496
I20
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp497
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp498
sg45
g29
(g31
S'7\x89A`\xe5P\x18@'
tRp499
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp500
sg50
VYRBWLK
p501
sg24
g25
sg52
Vmfnhdq
p502
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp503
sS'trials.thisIndex'
p504
g29
(g84
S'\x14\x00\x00\x00'
tRp505
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp506
sS'trials.thisRepN'
p507
I0
sg49
g29
(g31
S'7\x89A`\xe5P\x10@'
tRp508
sg26
g11
sS'trials.thisTrialN'
p509
I20
sg53
g29
(g31
S'\x9c\xc4 \xb0r( @'
tRp510
sg17
(lp511
S'8'
asa(dp512
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp513
sg44
g29
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp514
sg45
g29
(g31
S'`\xe5\xd0"\xdb\xf9\x11@'
tRp515
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp516
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp517
sg50
VNWLGFK
p518
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp519
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp520
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp521
sS'trials.thisIndex'
p522
g29
(g84
S'\x15\x00\x00\x00'
tRp523
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp524
sS'trials.thisRepN'
p525
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp526
sg16
F1454698494.4700749
sg28
g32
sS'trials.thisN'
p527
I21
sg49
g29
(g31
S'`\xe5\xd0"\xdb\xf9\x11@'
tRp528
sS'trials.thisTrialN'
p529
I21
sg53
g29
(g31
S'\xb1rh\x91\xed\xfc&@'
tRp530
sg17
Nsa(dp531
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp532
sg19
(lp533
F1.5845241546630859
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp534
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp535
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp536
sg16
F1454698505.959547
sS'trials.thisN'
p537
I22
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp538
sg44
g29
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp539
sg45
g29
(g31
S'\xa8\xc6K7\x89A\x18@'
tRp540
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp541
sg50
VGYKWTB
p542
sg24
g25
sg52
Vldxqnf
p543
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp544
sS'trials.thisIndex'
p545
g29
(g84
S'\x16\x00\x00\x00'
tRp546
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp547
sS'trials.thisRepN'
p548
I0
sg49
g29
(g31
S'\xa8\xc6K7\x89A\x10@'
tRp549
sg26
g11
sS'trials.thisTrialN'
p550
I22
sg53
g29
(g31
S'T\xe3\xa5\x9b\xc4  @'
tRp551
sg17
(lp552
S'8'
asa(dp553
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp554
sg19
(lp555
F1.5511090755462646
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp556
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp557
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp558
sg16
F1454698514.014199
sS'trials.thisN'
p559
I23
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp560
sg44
g29
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp561
sg45
g29
(g31
S'\x1cZd;\xdf\xcf\x18@'
tRp562
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp563
sg50
VHWRQXK
p564
sg24
g25
sg52
Vfydbng
p565
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp566
sS'trials.thisIndex'
p567
g29
(g84
S'\x17\x00\x00\x00'
tRp568
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp569
sS'trials.thisRepN'
p570
I0
sg49
g29
(g31
S'\x1dZd;\xdf\xcf\x10@'
tRp571
sg26
g11
sS'trials.thisTrialN'
p572
I23
sg53
g29
(g31
S'\x0e-\xb2\x9d\xefg*@'
tRp573
sg17
(lp574
S'8'
asa(dp575
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp576
sg44
g29
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp577
sg45
g29
(g31
S'\x04V\x0e-\xb2\x1d\x11@'
tRp578
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp579
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp580
sg50
VRTDFBG
p581
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp582
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp583
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp584
sS'trials.thisIndex'
p585
g29
(g84
S'\x18\x00\x00\x00'
tRp586
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp587
sS'trials.thisRepN'
p588
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp589
sg16
F1454698527.2111771
sg28
g32
sS'trials.thisN'
p590
I24
sg49
g29
(g31
S'\x04V\x0e-\xb2\x1d\x11@'
tRp591
sS'trials.thisTrialN'
p592
I24
sg53
g29
(g31
S'\x04V\x0e-\xb2\x1d\x19@'
tRp593
sg17
Nsa(dp594
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp595
sg44
g29
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp596
sg45
g29
(g31
S'T\xe3\xa5\x9b\xc4 \x10@'
tRp597
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp598
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp599
sg50
VQJXNDK
p600
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp601
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp602
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp603
sS'trials.thisIndex'
p604
g29
(g84
S'\x19\x00\x00\x00'
tRp605
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp606
sS'trials.thisRepN'
p607
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp608
sg16
F1454698533.4799161
sg28
g32
sS'trials.thisN'
p609
I25
sg49
g29
(g31
S'T\xe3\xa5\x9b\xc4 \x10@'
tRp610
sS'trials.thisTrialN'
p611
I25
sg53
g29
(g31
S'T\xe3\xa5\x9b\xc4 \x18@'
tRp612
sg17
Nsa(dp613
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp614
sg44
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp615
sg45
g29
(g31
S'{\x14\xaeG\xe1\xfa\x10@'
tRp616
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp617
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp618
sg50
VRDXLBF
p619
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp620
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp621
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp622
sS'trials.thisIndex'
p623
g29
(g84
S'\x1a\x00\x00\x00'
tRp624
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp625
sS'trials.thisRepN'
p626
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp627
sg16
F1454698539.5148749
sg28
g32
sS'trials.thisN'
p628
I26
sg49
g29
(g31
S'{\x14\xaeG\xe1\xfa\x10@'
tRp629
sS'trials.thisTrialN'
p630
I26
sg53
g29
(g31
S'{\x14\xaeG\xe1\xfa\x18@'
tRp631
sg17
Nsa(dp632
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp633
sg19
(lp634
F1.5844230651855469
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp635
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp636
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp637
sg16
F1454698545.7508919
sS'trials.thisN'
p638
I27
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp639
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp640
sg45
g29
(g31
S'j\xbct\x93\x18\x04\x18@'
tRp641
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp642
sg50
VYDFHTM
p643
sg24
g25
sg52
Vwrqxbg
p644
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp645
sS'trials.thisIndex'
p646
g29
(g84
S'\x1b\x00\x00\x00'
tRp647
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp648
sS'trials.thisRepN'
p649
I0
sg49
g29
(g31
S'j\xbct\x93\x18\x04\x10@'
tRp650
sg26
g11
sS'trials.thisTrialN'
p651
I27
sg53
g29
(g31
S'6^\xbaI\x0c\x02*@'
tRp652
sg17
(lp653
S'8'
asa(dp654
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp655
sg19
(lp656
F1.3676249980926514
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp657
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp658
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp659
sg16
F1454698558.7558041
sS'trials.thisN'
p660
I28
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp661
sg44
g29
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp662
sg45
g29
(g31
S'\\\x8f\xc2\xf5(\\\x18@'
tRp663
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp664
sg50
VDMYNBQ
p665
sg24
g25
sg52
Vjfrhtl
p666
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp667
sS'trials.thisIndex'
p668
g29
(g84
S'\x1c\x00\x00\x00'
tRp669
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp670
sS'trials.thisRepN'
p671
I0
sg49
g29
(g31
S'\\\x8f\xc2\xf5(\\\x10@'
tRp672
sg26
g11
sS'trials.thisTrialN'
p673
I28
sg53
g29
(g31
S'\xaeG\xe1z\x14. @'
tRp674
sg17
(lp675
S'8'
asa(dp676
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp677
sg19
(lp678
F1.000795841217041
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp679
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp680
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp681
sg16
F1454698566.8423369
sS'trials.thisN'
p682
I29
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp683
sg44
g29
(g69
S'\x0c\x00\x00\x00\x00\x00\x00\x00'
tRp684
sg45
g29
(g31
S'\xc5 \xb0rh\x11\x18@'
tRp685
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp686
sg50
VFTHKMG
p687
sg24
g25
sg52
Vjqwxrb
p688
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp689
sS'trials.thisIndex'
p690
g29
(g84
S'\x1d\x00\x00\x00'
tRp691
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp692
sS'trials.thisRepN'
p693
I0
sg49
g29
(g31
S'\xc4 \xb0rh\x11\x10@'
tRp694
sg26
g11
sS'trials.thisTrialN'
p695
I29
sg53
g29
(g31
S'c\x10X9\xb4\x08*@'
tRp696
sg17
(lp697
S'8'
asa(dp698
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp699
sg19
(lp700
F0.73417997360229492
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp701
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp702
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp703
sg16
F1454698579.864835
sS'trials.thisN'
p704
I30
sg42
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp705
sg44
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp706
sg45
g29
(g31
S'\xb6\xf3\xfd\xd4xi\x19@'
tRp707
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp708
sg50
VNJRKLB
p709
sg24
g25
sg52
Vhdgqkm
p710
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp711
sS'trials.thisIndex'
p712
g29
(g84
S'\x1e\x00\x00\x00'
tRp713
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp714
sS'trials.thisRepN'
p715
I0
sg49
g29
(g31
S'\xb6\xf3\xfd\xd4xi\x11@'
tRp716
sg26
g11
sS'trials.thisTrialN'
p717
I30
sg53
g29
(g31
S'\xdb\xf9~j\xbc\xb4*@'
tRp718
sg17
(lp719
S'7'
asa(dp720
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp721
sg19
(lp722
F0.80095601081848145
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp723
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp724
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp725
sg16
F1454698593.2213731
sS'trials.thisN'
p726
I31
sg42
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp727
sg44
g29
(g69
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp728
sg45
g29
(g31
S'j\xbct\x93\x18\x04\x18@'
tRp729
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp730
sg50
VFKMLQB
p731
sg24
g25
sg52
Vjdwnqr
p732
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp733
sS'trials.thisIndex'
p734
g29
(g84
S'\x1f\x00\x00\x00'
tRp735
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp736
sS'trials.thisRepN'
p737
I0
sg49
g29
(g31
S'j\xbct\x93\x18\x04\x10@'
tRp738
sg26
g11
sS'trials.thisTrialN'
p739
I31
sg53
g29
(g31
S'6^\xbaI\x0c\x02*@'
tRp740
sg17
(lp741
S'7'
asa(dp742
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp743
sg19
(lp744
F1.0677859783172607
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp745
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp746
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp747
sg16
F1454698606.2279601
sS'trials.thisN'
p748
I32
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp749
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp750
sg45
g29
(g31
S'D\x8bl\xe7\xfb\xa9\x18@'
tRp751
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp752
sg50
VNTWHYG
p753
sg24
g25
sg52
Vqdrbjk
p754
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp755
sS'trials.thisIndex'
p756
g29
(g84
S' \x00\x00\x00'
tRp757
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp758
sS'trials.thisRepN'
p759
I0
sg49
g29
(g31
S'D\x8bl\xe7\xfb\xa9\x10@'
tRp760
sg26
g11
sS'trials.thisTrialN'
p761
I32
sg53
g29
(g31
S'\xa1E\xb6\xf3\xfdT*@'
tRp762
sg17
(lp763
S'8'
asa(dp764
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp765
sg19
(lp766
F0.90093994140625
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp767
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp768
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp769
sg16
F1454698619.3848209
sS'trials.thisN'
p770
I33
sg42
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp771
sg44
g29
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp772
sg45
g29
(g31
S'\x93\x18\x04V\x0e-\x19@'
tRp773
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp774
sg50
VBQDTJX
p775
sg24
g25
sg52
Vmrkhdw
p776
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp777
sS'trials.thisIndex'
p778
g29
(g84
S'!\x00\x00\x00'
tRp779
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp780
sS'trials.thisRepN'
p781
I0
sg49
g29
(g31
S'\x93\x18\x04V\x0e-\x11@'
tRp782
sg26
g11
sS'trials.thisTrialN'
p783
I33
sg53
g29
(g31
S'J\x0c\x02+\x87\x96 @'
tRp784
sg17
(lp785
S'7'
asa(dp786
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp787
sg44
g29
(g69
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp788
sg45
g29
(g31
S'\x8cl\xe7\xfb\xa9q\x11@'
tRp789
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp790
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp791
sg50
VHNLYGQ
p792
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp793
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp794
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp795
sS'trials.thisIndex'
p796
g29
(g84
S'"\x00\x00\x00'
tRp797
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp798
sS'trials.thisRepN'
p799
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp800
sg16
F1454698627.680764
sg28
g32
sS'trials.thisN'
p801
I34
sg49
g29
(g31
S'\x8cl\xe7\xfb\xa9q\x11@'
tRp802
sS'trials.thisTrialN'
p803
I34
sg53
g29
(g31
S'E\xb6\xf3\xfd\xd4\xb8&@'
tRp804
sg17
Nsa(dp805
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp806
sg44
g29
(g69
S'"\x00\x00\x00\x00\x00\x00\x00'
tRp807
sg45
g29
(g31
S'\xb0rh\x91\xed\xfc\x10@'
tRp808
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp809
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp810
sg50
VGTQJKD
p811
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp812
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp813
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp814
sS'trials.thisIndex'
p815
g29
(g84
S'#\x00\x00\x00'
tRp816
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp817
sS'trials.thisRepN'
p818
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp819
sg16
F1454698639.03426
sg28
g32
sS'trials.thisN'
p820
I35
sg49
g29
(g31
S'\xb0rh\x91\xed\xfc\x10@'
tRp821
sS'trials.thisTrialN'
p822
I35
sg53
g29
(g31
S'X9\xb4\xc8v~&@'
tRp823
sg17
Nsa(dp824
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp825
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp826
sg45
g29
(g31
S'\x83\xc0\xca\xa1E\xb6\x11@'
tRp827
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp828
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp829
sg50
VDHLTQN
p830
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp831
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp832
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp833
sS'trials.thisIndex'
p834
g29
(g84
S'$\x00\x00\x00'
tRp835
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp836
sS'trials.thisRepN'
p837
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp838
sg16
F1454698650.271939
sg28
g32
sS'trials.thisN'
p839
I36
sg49
g29
(g31
S'\x83\xc0\xca\xa1E\xb6\x11@'
tRp840
sS'trials.thisTrialN'
p841
I36
sg53
g29
(g31
S'A`\xe5\xd0"\xdb&@'
tRp842
sg17
Nsa(dp843
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp844
sg19
(lp845
F2.0014548301696777
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp846
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp847
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp848
sg16
F1454698661.6929419
sS'trials.thisN'
p849
I37
sg42
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp850
sg44
g29
(g69
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp851
sg45
g29
(g31
S'\xca\xa1E\xb6\xf3\xfd\x1a@'
tRp852
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp853
sg50
VMDHTBK
p854
sg24
g25
sg52
Vlnrjbq
p855
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp856
sS'trials.thisIndex'
p857
g29
(g84
S'%\x00\x00\x00'
tRp858
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp859
sS'trials.thisRepN'
p860
I0
sg49
g29
(g31
S'\xcb\xa1E\xb6\xf3\xfd\x12@'
tRp861
sg26
g11
sS'trials.thisTrialN'
p862
I37
sg53
g29
(g31
S'\xe5\xd0"\xdb\xf9~+@'
tRp863
sg17
(lp864
S'7'
asa(dp865
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp866
sg44
g29
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp867
sg45
g29
(g31
S'\xc1\xca\xa1E\xb6s\x13@'
tRp868
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp869
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp870
sg50
VKJQWFN
p871
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp872
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp873
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp874
sS'trials.thisIndex'
p875
g29
(g84
S'&\x00\x00\x00'
tRp876
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp877
sS'trials.thisRepN'
p878
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp879
sg16
F1454698675.4319561
sg28
g32
sS'trials.thisN'
p880
I38
sg49
g29
(g31
S'\xc1\xca\xa1E\xb6s\x13@'
tRp881
sS'trials.thisTrialN'
p882
I38
sg53
g29
(g31
S'\xc0\xca\xa1E\xb6s\x1b@'
tRp883
sg17
Nsa(dp884
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp885
sg19
(lp886
F1.0845270156860352
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp887
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp888
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp889
sg16
F1454698682.284493
sS'trials.thisN'
p890
I39
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp891
sg44
g29
(g69
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp892
sg45
g29
(g31
S'\xcd\xcc\xcc\xcc\xcc\xcc\x1a@'
tRp893
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp894
sg50
VGDHQYL
p895
sg24
g25
sg52
Vxfkbmr
p896
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp897
sS'trials.thisIndex'
p898
g29
(g84
S"'\x00\x00\x00"
tRp899
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp900
sS'trials.thisRepN'
p901
I0
sg49
g29
(g31
S'\xcd\xcc\xcc\xcc\xcc\xcc\x12@'
tRp902
sg26
g11
sS'trials.thisTrialN'
p903
I39
sg53
g29
(g31
S'ffffff!@'
tRp904
sg17
(lp905
S'8'
asa(dp906
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp907
sg44
g29
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp908
sg45
g29
(g31
S'\x11X9\xb4\xc8v\x10@'
tRp909
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp910
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp911
sg50
VDKWJGL
p912
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp913
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp914
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp915
sS'trials.thisIndex'
p916
g29
(g84
S'(\x00\x00\x00'
tRp917
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp918
sS'trials.thisRepN'
p919
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp920
sg16
F1454698690.9892249
sg28
g32
sS'trials.thisN'
p921
I40
sg49
g29
(g31
S'\x11X9\xb4\xc8v\x10@'
tRp922
sS'trials.thisTrialN'
p923
I40
sg53
g29
(g31
S'\x08\xac\x1cZd;&@'
tRp924
sg17
Nsa(dp925
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp926
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp927
sg45
g29
(g31
S'F\xb6\xf3\xfd\xd4\xf8\x12@'
tRp928
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp929
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp930
sg50
VRWYKXJ
p931
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp932
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp933
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp934
sS'trials.thisIndex'
p935
g29
(g84
S')\x00\x00\x00'
tRp936
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp937
sS'trials.thisRepN'
p938
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp939
sg16
F1454698702.094985
sg28
g32
sS'trials.thisN'
p940
I41
sg49
g29
(g31
S'F\xb6\xf3\xfd\xd4\xf8\x12@'
tRp941
sS'trials.thisTrialN'
p942
I41
sg53
g29
(g31
S"#\xdb\xf9~j|'@"
tRp943
sg17
Nsa(dp944
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp945
sg19
(lp946
F0.69343709945678711
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp947
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp948
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp949
sg16
F1454698713.8341701
sS'trials.thisN'
p950
I42
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp951
sg44
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp952
sg45
g29
(g31
S'%\x06\x81\x95C\x0b\x18@'
tRp953
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp954
sg50
VQBXNRY
p955
sg24
g25
sg52
Vlnkmdt
p956
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp957
sS'trials.thisIndex'
p958
g29
(g84
S'*\x00\x00\x00'
tRp959
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp960
sS'trials.thisRepN'
p961
I0
sg49
g29
(g31
S'%\x06\x81\x95C\x0b\x10@'
tRp962
sg26
g11
sS'trials.thisTrialN'
p963
I42
sg53
g29
(g31
S'\x12\x83\xc0\xca\xa1\x05*@'
tRp964
sg17
(lp965
S'7'
asa(dp966
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp967
sg19
(lp968
F0.90126585960388184
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp969
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp970
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp971
sg16
F1454698726.8581009
sS'trials.thisN'
p972
I43
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp973
sg44
g29
(g69
S'8\x00\x00\x00\x00\x00\x00\x00'
tRp974
sg45
g29
(g31
S'R\xb8\x1e\x85\xeb\xd1\x18@'
tRp975
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp976
sg50
VBHNXFR
p977
sg24
g25
sg52
Vqlkrtg
p978
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp979
sS'trials.thisIndex'
p980
g29
(g84
S'+\x00\x00\x00'
tRp981
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp982
sS'trials.thisRepN'
p983
I0
sg49
g29
(g31
S'R\xb8\x1e\x85\xeb\xd1\x10@'
tRp984
sg26
g11
sS'trials.thisTrialN'
p985
I43
sg53
g29
(g31
S')\\\x8f\xc2\xf5h @'
tRp986
sg17
(lp987
S'7'
asa(dp988
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp989
sg44
g29
(g69
S'\x0c\x00\x00\x00\x00\x00\x00\x00'
tRp990
sg45
g29
(g31
S'\x9a\x99\x99\x99\x99\x19\x10@'
tRp991
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp992
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp993
sg50
VHLRYMN
p994
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp995
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp996
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp997
sS'trials.thisIndex'
p998
g29
(g84
S',\x00\x00\x00'
tRp999
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1000
sS'trials.thisRepN'
p1001
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1002
sg16
F1454698735.0529079
sg28
g32
sS'trials.thisN'
p1003
I44
sg49
g29
(g31
S'\x9a\x99\x99\x99\x99\x19\x10@'
tRp1004
sS'trials.thisTrialN'
p1005
I44
sg53
g29
(g31
S'\x9a\x99\x99\x99\x99\x19\x18@'
tRp1006
sg17
Nsa(dp1007
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1008
sg19
(lp1009
F0.9010460376739502
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1010
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1011
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1012
sg16
F1454698741.0710671
sS'trials.thisN'
p1013
I45
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1014
sg44
g29
(g69
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp1015
sg45
g29
(g31
S'ffffff\x18@'
tRp1016
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1017
sg50
VMKWYLR
p1018
sg24
g25
sg52
Vghnjqx
p1019
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1020
sS'trials.thisIndex'
p1021
g29
(g84
S'-\x00\x00\x00'
tRp1022
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1023
sS'trials.thisRepN'
p1024
I0
sg49
g29
(g31
S'ffffff\x10@'
tRp1025
sg26
g11
sS'trials.thisTrialN'
p1026
I45
sg53
g29
(g31
S'333333*@'
tRp1027
sg17
(lp1028
S'8'
asa(dp1029
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1030
sg44
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1031
sg45
g29
(g31
S'\xd1"\xdb\xf9~\xea\x12@'
tRp1032
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1033
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1034
sg50
VRBXYTL
p1035
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1036
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1037
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1038
sS'trials.thisIndex'
p1039
g29
(g84
S'.\x00\x00\x00'
tRp1040
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1041
sS'trials.thisRepN'
p1042
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1043
sg16
F1454698754.1759591
sg28
g32
sS'trials.thisN'
p1044
I46
sg49
g29
(g31
S'\xd1"\xdb\xf9~\xea\x12@'
tRp1045
sS'trials.thisTrialN'
p1046
I46
sg53
g29
(g31
S"i\x91\xed|?u'@"
tRp1047
sg17
Nsa(dp1048
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1049
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1050
sg45
g29
(g31
S'\x02+\x87\x16\xd9N\x10@'
tRp1051
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1052
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1053
sg50
VQBMKWD
p1054
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1055
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1056
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1057
sS'trials.thisIndex'
p1058
g29
(g84
S'/\x00\x00\x00'
tRp1059
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1060
sS'trials.thisRepN'
p1061
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1062
sg16
F1454698765.8968639
sg28
g32
sS'trials.thisN'
p1063
I47
sg49
g29
(g31
S'\x02+\x87\x16\xd9N\x10@'
tRp1064
sS'trials.thisTrialN'
p1065
I47
sg53
g29
(g31
S'\x03+\x87\x16\xd9N\x18@'
tRp1066
sg17
Nsa(dp1067
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1068
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1069
sg45
g29
(g31
S'\xb2\x9d\xef\xa7\xc6\xcb\x11@'
tRp1070
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1071
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1072
sg50
VMYQJWH
p1073
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1074
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1075
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1076
sS'trials.thisIndex'
p1077
g29
(g84
S'0\x00\x00\x00'
tRp1078
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1079
sS'trials.thisRepN'
p1080
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1081
sg16
F1454698771.9661701
sg28
g32
sS'trials.thisN'
p1082
I48
sg49
g29
(g31
S'\xb2\x9d\xef\xa7\xc6\xcb\x11@'
tRp1083
sS'trials.thisTrialN'
p1084
I48
sg53
g29
(g31
S'\xb2\x9d\xef\xa7\xc6\xcb\x19@'
tRp1085
sg17
Nsa(dp1086
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1087
sg19
(lp1088
F0.76732397079467773
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1089
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1090
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1091
sg16
F1454698778.4189041
sS'trials.thisN'
p1092
I49
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1093
sg44
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1094
sg45
g29
(g31
S'\xaeG\xe1z\x14\xae\x1b@'
tRp1095
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1096
sg50
VJKDHQN
p1097
sg24
g25
sg52
Vgbxdtm
p1098
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1099
sS'trials.thisIndex'
p1100
g29
(g84
S'1\x00\x00\x00'
tRp1101
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1102
sS'trials.thisRepN'
p1103
I0
sg49
g29
(g31
S'\xaeG\xe1z\x14\xae\x13@'
tRp1104
sg26
g11
sS'trials.thisTrialN'
p1105
I49
sg53
g29
(g31
S'\xd7\xa3p=\n\xd7!@'
tRp1106
sg17
(lp1107
S'7'
asa(dp1108
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1109
sg19
(lp1110
F0.81760001182556152
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1111
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1112
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1113
sg16
F1454698787.339787
sS'trials.thisN'
p1114
I50
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1115
sg44
g29
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp1116
sg45
g29
(g31
S'\x83\xc0\xca\xa1E6\x18@'
tRp1117
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1118
sg50
VDTQJWX
p1119
sg24
g25
sg52
Vfhqlrm
p1120
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1121
sS'trials.thisIndex'
p1122
g29
(g84
S'2\x00\x00\x00'
tRp1123
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1124
sS'trials.thisRepN'
p1125
I0
sg49
g29
(g31
S'\x83\xc0\xca\xa1E6\x10@'
tRp1126
sg26
g11
sS'trials.thisTrialN'
p1127
I50
sg53
g29
(g31
S'A`\xe5\xd0"\x1b*@'
tRp1128
sg17
(lp1129
S'7'
asa(dp1130
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1131
sg19
(lp1132
F1.5347809791564941
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1133
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1134
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1135
sg16
F1454698800.396131
sS'trials.thisN'
p1136
I51
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1137
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1138
sg45
g29
(g31
S'\xf6(\\\x8f\xc2u\x19@'
tRp1139
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1140
sg50
VNQWRGT
p1141
sg24
g25
sg52
Vlmjhky
p1142
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1143
sS'trials.thisIndex'
p1144
g29
(g84
S'3\x00\x00\x00'
tRp1145
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1146
sS'trials.thisRepN'
p1147
I0
sg49
g29
(g31
S'\xf6(\\\x8f\xc2u\x11@'
tRp1148
sg26
g11
sS'trials.thisTrialN'
p1149
I51
sg53
g29
(g31
S'{\x14\xaeG\xe1\xba*@'
tRp1150
sg17
(lp1151
S'8'
asa(dp1152
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1153
sg44
g29
(g69
S'8\x00\x00\x00\x00\x00\x00\x00'
tRp1154
sg45
g29
(g31
S'\xb0rh\x91\xed|\x10@'
tRp1155
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1156
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1157
sg50
VKLMWHB
p1158
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1159
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1160
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1161
sS'trials.thisIndex'
p1162
g29
(g84
S'4\x00\x00\x00'
tRp1163
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1164
sS'trials.thisRepN'
p1165
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1166
sg16
F1454698813.7532511
sg28
g32
sS'trials.thisN'
p1167
I52
sg49
g29
(g31
S'\xb0rh\x91\xed|\x10@'
tRp1168
sS'trials.thisTrialN'
p1169
I52
sg53
g29
(g31
S'X9\xb4\xc8v>&@'
tRp1170
sg17
Nsa(dp1171
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1172
sg19
(lp1173
F0.71725678443908691
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1174
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1175
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1176
sg16
F1454698824.8755469
sS'trials.thisN'
p1177
I53
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1178
sg44
g29
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1179
sg45
g29
(g31
S'\x18\x04V\x0e-2\x18@'
tRp1180
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1181
sg50
VRBXYLJ
p1182
sg24
g25
sg52
Vbqhgkm
p1183
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1184
sS'trials.thisIndex'
p1185
g29
(g84
S'5\x00\x00\x00'
tRp1186
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1187
sS'trials.thisRepN'
p1188
I0
sg49
g29
(g31
S'\x18\x04V\x0e-2\x10@'
tRp1189
sg26
g11
sS'trials.thisTrialN'
p1190
I53
sg53
g29
(g31
S'\r\x02+\x87\x16\x19*@'
tRp1191
sg17
(lp1192
S'7'
asa(dp1193
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1194
sg19
(lp1195
F0.8675839900970459
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1196
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1197
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1198
sg16
F1454698837.9228051
sS'trials.thisN'
p1199
I54
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1200
sg44
g29
(g69
S'\x0c\x00\x00\x00\x00\x00\x00\x00'
tRp1201
sg45
g29
(g31
S'X9\xb4\xc8v\xbe\x18@'
tRp1202
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1203
sg50
VJXBMFD
p1204
sg24
g25
sg52
Vjtngqh
p1205
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1206
sS'trials.thisIndex'
p1207
g29
(g84
S'6\x00\x00\x00'
tRp1208
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1209
sS'trials.thisRepN'
p1210
I0
sg49
g29
(g31
S'X9\xb4\xc8v\xbe\x10@'
tRp1211
sg26
g11
sS'trials.thisTrialN'
p1212
I54
sg53
g29
(g31
S'\xac\x1cZd;_*@'
tRp1213
sg17
(lp1214
S'7'
asa(dp1215
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1216
sg44
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1217
sg45
g29
(g31
S'\x93\x18\x04V\x0e-\x11@'
tRp1218
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1219
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1220
sg50
VWGHTRM
p1221
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1222
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1223
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1224
sS'trials.thisIndex'
p1225
g29
(g84
S'7\x00\x00\x00'
tRp1226
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1227
sS'trials.thisRepN'
p1228
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1229
sg16
F1454698851.1111879
sg28
g32
sS'trials.thisN'
p1230
I55
sg49
g29
(g31
S'\x93\x18\x04V\x0e-\x11@'
tRp1231
sS'trials.thisTrialN'
p1232
I55
sg53
g29
(g31
S'\x93\x18\x04V\x0e-\x19@'
tRp1233
sg17
Nsa(dp1234
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1235
sg44
g29
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp1236
sg45
g29
(g31
S'/\xdd$\x06\x81\x15\x10@'
tRp1237
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1238
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1239
sg50
VFMGYRL
p1240
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1241
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1242
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1243
sS'trials.thisIndex'
p1244
g29
(g84
S'8\x00\x00\x00'
tRp1245
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1246
sS'trials.thisRepN'
p1247
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1248
sg16
F1454698857.3964739
sg28
g32
sS'trials.thisN'
p1249
I56
sg49
g29
(g31
S'/\xdd$\x06\x81\x15\x10@'
tRp1250
sS'trials.thisTrialN'
p1251
I56
sg53
g29
(g31
S'/\xdd$\x06\x81\x15\x18@'
tRp1252
sg17
Nsa(dp1253
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1254
sg19
(lp1255
F0.93415093421936035
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1256
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1257
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1258
sg16
F1454698863.415272
sS'trials.thisN'
p1259
I57
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1260
sg44
g29
(g69
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp1261
sg45
g29
(g31
S'J\x0c\x02+\x87\x16\x1c@'
tRp1262
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1263
sg50
VNBRLGF
p1264
sg24
g25
sg52
Vyqrtdk
p1265
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1266
sS'trials.thisIndex'
p1267
g29
(g84
S'9\x00\x00\x00'
tRp1268
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1269
sS'trials.thisRepN'
p1270
I0
sg49
g29
(g31
S'J\x0c\x02+\x87\x16\x14@'
tRp1271
sg26
g11
sS'trials.thisTrialN'
p1272
I57
sg53
g29
(g31
S'%\x06\x81\x95C\x0b,@'
tRp1273
sg17
(lp1274
S'7'
asa(dp1275
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1276
sg19
(lp1277
F1.0008080005645752
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1278
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1279
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1280
sg16
F1454698877.4372599
sS'trials.thisN'
p1281
I58
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1282
sg44
g29
(g69
S'\xc8\x01\x00\x00\x00\x00\x00\x00'
tRp1283
sg45
g29
(g31
S'&1\x08\xac\x1c\xda\x19@'
tRp1284
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1285
sg50
VRLDNYJ
p1286
sg24
g25
sg52
Vmqfkxh
p1287
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1288
sS'trials.thisIndex'
p1289
g29
(g84
S':\x00\x00\x00'
tRp1290
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1291
sS'trials.thisRepN'
p1292
I0
sg49
g29
(g31
S"'1\x08\xac\x1c\xda\x11@"
tRp1293
sg26
g11
sS'trials.thisTrialN'
p1294
I58
sg53
g29
(g31
S'\x93\x18\x04V\x0e\xed*@'
tRp1295
sg17
(lp1296
S'8'
asa(dp1297
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1298
sg19
(lp1299
F0.71751284599304199
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1300
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1301
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1302
sg16
F1454698890.8939741
sS'trials.thisN'
p1303
I59
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1304
sg44
g29
(g69
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp1305
sg45
g29
(g31
S'\xa1E\xb6\xf3\xfdT\x1b@'
tRp1306
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1307
sg50
VJGTWRX
p1308
sg24
g25
sg52
Vkdwbnq
p1309
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1310
sS'trials.thisIndex'
p1311
g29
(g84
S';\x00\x00\x00'
tRp1312
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1313
sS'trials.thisRepN'
p1314
I0
sg49
g29
(g31
S'\xa2E\xb6\xf3\xfdT\x13@'
tRp1315
sg26
g11
sS'trials.thisTrialN'
p1316
I59
sg53
g29
(g31
S'\xd1"\xdb\xf9~\xaa+@'
tRp1317
sg17
(lp1318
S'7'
asa(dp1319
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1320
sg44
g29
(g69
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp1321
sg45
g29
(g31
S'\xfa~j\xbct\x13\x11@'
tRp1322
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1323
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1324
sg50
VJGQFDT
p1325
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1326
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1327
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1328
sS'trials.thisIndex'
p1329
g29
(g84
S'<\x00\x00\x00'
tRp1330
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1331
sS'trials.thisRepN'
p1332
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1333
sg16
F1454698904.71734
sg28
g32
sS'trials.thisN'
p1334
I60
sg49
g29
(g31
S'\xfa~j\xbct\x13\x11@'
tRp1335
sS'trials.thisTrialN'
p1336
I60
sg53
g29
(g31
S'}?5^\xba\x89&@'
tRp1337
sg17
Nsa(dp1338
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1339
sg19
(lp1340
F1.6344408988952637
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1341
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1342
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1343
sg16
F1454698915.989912
sS'trials.thisN'
p1344
I61
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1345
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1346
sg45
g29
(g31
S'\x17\xd9\xce\xf7Sc\x18@'
tRp1347
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1348
sg50
VRFTXJW
p1349
sg24
g25
sg52
Vjbkygd
p1350
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1351
sS'trials.thisIndex'
p1352
g29
(g84
S'=\x00\x00\x00'
tRp1353
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1354
sS'trials.thisRepN'
p1355
I0
sg49
g29
(g31
S'\x16\xd9\xce\xf7Sc\x10@'
tRp1356
sg26
g11
sS'trials.thisTrialN'
p1357
I61
sg53
g29
(g31
S'\x8cl\xe7\xfb\xa91*@'
tRp1358
sg17
(lp1359
S'7'
asa(dp1360
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1361
sg19
(lp1362
F1.0092380046844482
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1363
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1364
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1365
sg16
F1454698929.079937
sS'trials.thisN'
p1366
I62
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1367
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1368
sg45
g29
(g31
S'\xc9v\xbe\x9f\x1a\xaf\x19@'
tRp1369
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1370
sg50
VMHFQNW
p1371
sg24
g25
sg52
Vbhxygr
p1372
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1373
sS'trials.thisIndex'
p1374
g29
(g84
S'>\x00\x00\x00'
tRp1375
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1376
sS'trials.thisRepN'
p1377
I0
sg49
g29
(g31
S'\xc9v\xbe\x9f\x1a\xaf\x11@'
tRp1378
sg26
g11
sS'trials.thisTrialN'
p1379
I62
sg53
g29
(g31
S'd;\xdfO\x8d\xd7*@'
tRp1380
sg17
(lp1381
S'7'
asa(dp1382
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1383
sg19
(lp1384
F1.6511530876159668
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1385
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1386
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1387
sg16
F1454698942.4939611
sS'trials.thisN'
p1388
I63
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1389
sg44
g29
(g69
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp1390
sg45
g29
(g31
S'Zd;\xdfO\r\x18@'
tRp1391
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1392
sg50
VRJQXFY
p1393
sg24
g25
sg52
Vqhnmbw
p1394
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1395
sS'trials.thisIndex'
p1396
g29
(g84
S'?\x00\x00\x00'
tRp1397
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1398
sS'trials.thisRepN'
p1399
I0
sg49
g29
(g31
S'Zd;\xdfO\r\x10@'
tRp1400
sg26
g11
sS'trials.thisTrialN'
p1401
I63
sg53
g29
(g31
S'-\xb2\x9d\xef\xa7\x06*@'
tRp1402
sg17
(lp1403
S'7'
asa(dp1404
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1405
sg19
(lp1406
F1.034451961517334
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1407
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1408
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1409
sg16
F1454698955.4983809
sS'trials.thisN'
p1410
I64
sg42
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1411
sg44
g29
(g69
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp1412
sg45
g29
(g31
S'\x1b/\xdd$\x06\x01\x1b@'
tRp1413
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1414
sg50
VGBTKQH
p1415
sg24
g25
sg52
Vdfljwy
p1416
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1417
sS'trials.thisIndex'
p1418
g29
(g84
S'@\x00\x00\x00'
tRp1419
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1420
sS'trials.thisRepN'
p1421
I0
sg49
g29
(g31
S'\x1b/\xdd$\x06\x01\x13@'
tRp1422
sg26
g11
sS'trials.thisTrialN'
p1423
I64
sg53
g29
(g31
S'\x8d\x97n\x12\x83\x80+@'
tRp1424
sg17
(lp1425
S'8'
asa(dp1426
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1427
sg19
(lp1428
F1.4344031810760498
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1429
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1430
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1431
sg16
F1454698969.253804
sS'trials.thisN'
p1432
I65
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1433
sg44
g29
(g69
S'"\x00\x00\x00\x00\x00\x00\x00'
tRp1434
sg45
g29
(g31
S'#\xdb\xf9~j\xbc\x18@'
tRp1435
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1436
sg50
VBLDJFM
p1437
sg24
g25
sg52
Vyjhtwq
p1438
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1439
sS'trials.thisIndex'
p1440
g29
(g84
S'A\x00\x00\x00'
tRp1441
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1442
sS'trials.thisRepN'
p1443
I0
sg49
g29
(g31
S'#\xdb\xf9~j\xbc\x10@'
tRp1444
sg26
g11
sS'trials.thisTrialN'
p1445
I65
sg53
g29
(g31
S'\x92\xed|?5^*@'
tRp1446
sg17
(lp1447
S'8'
asa(dp1448
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1449
sg19
(lp1450
F1.1344740390777588
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1451
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1452
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1453
sg16
F1454698982.4420259
sS'trials.thisN'
p1454
I66
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1455
sg44
g29
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp1456
sg45
g29
(g31
S'\xb1rh\x91\xed|\x19@'
tRp1457
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1458
sg50
VJRGXFB
p1459
sg24
g25
sg52
Vhtlkqm
p1460
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1461
sS'trials.thisIndex'
p1462
g29
(g84
S'B\x00\x00\x00'
tRp1463
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1464
sS'trials.thisRepN'
p1465
I0
sg49
g29
(g31
S'\xb0rh\x91\xed|\x11@'
tRp1466
sg26
g11
sS'trials.thisTrialN'
p1467
I66
sg53
g29
(g31
S'X9\xb4\xc8v\xbe*@'
tRp1468
sg17
(lp1469
S'8'
asa(dp1470
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1471
sg19
(lp1472
F1.9349720478057861
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1473
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1474
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1475
sg16
F1454698995.8148251
sS'trials.thisN'
p1476
I67
sg42
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1477
sg44
g29
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1478
sg45
g29
(g31
S'\xf3\xfd\xd4x\xe9\xa6\x1d@'
tRp1479
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1480
sg50
VXBRTGY
p1481
sg24
g25
sg52
Vfkwnjd
p1482
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1483
sS'trials.thisIndex'
p1484
g29
(g84
S'C\x00\x00\x00'
tRp1485
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1486
sS'trials.thisRepN'
p1487
I0
sg49
g29
(g31
S'\xf3\xfd\xd4x\xe9\xa6\x15@'
tRp1488
sg26
g11
sS'trials.thisTrialN'
p1489
I67
sg53
g29
(g31
S'\xfa~j\xbct\xd3,@'
tRp1490
sg17
(lp1491
S'8'
asa(dp1492
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1493
sg19
(lp1494
F0.98442792892456055
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1495
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1496
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1497
sg16
F1454699010.221864
sS'trials.thisN'
p1498
I68
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1499
sg44
g29
(g69
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp1500
sg45
g29
(g31
S'{\x14\xaeG\xe1\xfa\x18@'
tRp1501
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1502
sg50
VBRFTXJ
p1503
sg24
g25
sg52
Vnhgklm
p1504
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1505
sS'trials.thisIndex'
p1506
g29
(g84
S'D\x00\x00\x00'
tRp1507
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1508
sS'trials.thisRepN'
p1509
I0
sg49
g29
(g31
S'{\x14\xaeG\xe1\xfa\x10@'
tRp1510
sg26
g11
sS'trials.thisTrialN'
p1511
I68
sg53
g29
(g31
S'=\n\xd7\xa3p}*@'
tRp1512
sg17
(lp1513
S'8'
asa(dp1514
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1515
sg19
(lp1516
F1.4349911212921143
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1517
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1518
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1519
sg16
F1454699023.462389
sS'trials.thisN'
p1520
I69
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1521
sg44
g29
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1522
sg45
g29
(g31
S'j\xbct\x93\x18\x04\x18@'
tRp1523
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1524
sg50
VBLNYMG
p1525
sg24
g25
sg52
Vgqdthf
p1526
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1527
sS'trials.thisIndex'
p1528
g29
(g84
S'E\x00\x00\x00'
tRp1529
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1530
sS'trials.thisRepN'
p1531
I0
sg49
g29
(g31
S'j\xbct\x93\x18\x04\x10@'
tRp1532
sg26
g11
sS'trials.thisTrialN'
p1533
I69
sg53
g29
(g31
S'6^\xbaI\x0c\x02*@'
tRp1534
sg17
(lp1535
S'7'
asa(dp1536
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1537
sg44
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1538
sg45
g29
(g31
S'%\x06\x81\x95C\x8b\x18@'
tRp1539
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1540
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1541
sg50
VTMLNFQ
p1542
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1543
sg24
g25
sg52
Vdwrkxm
p1544
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1545
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1546
sS'trials.thisIndex'
p1547
g29
(g84
S'F\x00\x00\x00'
tRp1548
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1549
sS'trials.thisRepN'
p1550
I0
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1551
sg16
F1454699036.46948
sg28
g32
sS'trials.thisN'
p1552
I70
sg49
g29
(g31
S'%\x06\x81\x95C\x8b\x10@'
tRp1553
sS'trials.thisTrialN'
p1554
I70
sg53
g29
(g31
S'\x12\x83\xc0\xca\xa1E*@'
tRp1555
sg17
Nsa(dp1556
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1557
sg19
(lp1558
F0.81752204895019531
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1559
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1560
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1561
sg16
F1454699049.5989139
sS'trials.thisN'
p1562
I71
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1563
sg44
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1564
sg45
g29
(g31
S'\x1f\x85\xebQ\xb8\x1e\x18@'
tRp1565
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1566
sg50
VXLMQBK
p1567
sg24
g25
sg52
Vfhgynw
p1568
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1569
sS'trials.thisIndex'
p1570
g29
(g84
S'G\x00\x00\x00'
tRp1571
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1572
sS'trials.thisRepN'
p1573
I0
sg49
g29
(g31
S'\x1f\x85\xebQ\xb8\x1e\x10@'
tRp1574
sg26
g11
sS'trials.thisTrialN'
p1575
I71
sg53
g29
(g31
S'\x8f\xc2\xf5(\\\x0f*@'
tRp1576
sg17
(lp1577
S'8'
asa(dp1578
g23
I2004
sg26
g11
sg27
I1
sg24
g25
sg28
g32
sg16
F1454699062.6201129
sa(dp1579
g23
I2004
sg26
g11
sg27
I1
sg24
g25
sg28
g32
sg16
F1454699072.622947
sa(dp1580
g23
I2004
sg26
g11
sg27
I1
sg24
g25
sg28
g32
sg16
F1454699072.623039
sasS'loops'
p1581
(lp1582
g1
(cpsychopy.data
TrialHandler
p1583
g3
NtRp1584
(dp1585
S'origin'
p1586
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.01), Thu 24 Sep 2015 11:35:23 AM EDT\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a# from psychopy.hardware.emulator import launchScan\u000aimport time\u000aimport sys\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000aglobal expName\u000aglobal AllowedInputKeys\u000aAllowedInputKeys = ['1', '2','3','4','5','6','7','8','9','down','right']\u000aglobal FullScreenFlag \u000a\u000aFullScreenFlag = True\u000aScreenToUse = 'MacBookPro'\u000aexpName='PartialTrial'\u000a\u000adef TestSomething(subid=9999,visitid=0001):\u000a    expInfo = {u'Visit ID': u'9999', u'Participant ID': u'1'}\u000a    print 'subid is %s'%(subid)\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a    else:\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a    return expInfo\u000a\u000adef PartialTrial(INPUTFILE,filename,subid=9999,visitid=9999):\u000a    #INPUTFILE = 'Optimized60trialsLoads12467_1.xlsx'\u000a    # INPUTFILE = 'TrialListLoads123466_6Repeats_121415_2.csv'\u000a    # INPUTFILE = 'TwoTrials.xlsx'\u000a    IntroTime = 10\u000a    End = 10 # This should be set so that it is at least ten seconds and so the experiment \u000a    # total duration is a multiple of two seconds.\u000a\u000a    MaxLetters = 6\u000a    if MaxLetters == 6:\u000a        SETwrapWidth = 1.5 # The wrap width of text needs to be adjusted based on how manty letters there are\u000a        SETletCycle = 13 # # Spaces are added between letters and this controls the loop which does it\u000a    elif MaxLetters == 7:\u000a        SETwrapWidth = 1.7\u000a        SETletCycle = 15\u000a    expInfo = {u'Visit ID': u'001', u'Participant ID': u''}\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a        if dlg.OK == False: win.close()  # user pressed cancel\u000a    else:\u000a        print "Subid entered is: %s"%(subid)\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a        \u000a    # Store info about the experiment session\u000a\u000a    \u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    # filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=True,\u000a        dataFileName=filename)\u000a    #save a log file for detail verbose info\u000a    logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[1366, 768], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor = ScreenToUse, color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'norm')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial"\u000a    trialClock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    \u000a    # THE AIM IS TO \u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=SETwrapWidth, ## Changed from 1.5 because of 7 letters\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=SETwrapWidth,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=SETwrapWidth,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    WaitForScanner = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Waiting for Scanner, press r to advance',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(INPUTFILE),\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a\u000a\u000a    # PRESENT THE SCREEN TO WAIT FOR THE MRI TRIGGER\u000a    #vol = launchScan(win, MR_settings,  mode='Scan')\u000a\u000a    # ########################################################\u000a    # There should be WAITING FOR SCANNER trial here\u000a    # The test2 routine has these parts in it\u000a    #------Prepare to start Routine "ScanWait"-------\u000a    t = 0\u000a    ScanWaitClock = core.Clock()\u000a    ScanWaitClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    ScannerTrigger = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    ScannerTrigger.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    ScanWaitComponents = []\u000a    ScanWaitComponents.append(WaitForScanner)\u000a    ScanWaitComponents.append(ScannerTrigger)\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "ScanWait"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = ScanWaitClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_4* updates\u000a        if t >= 0.0 and WaitForScanner.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            WaitForScanner.tStart = t  # underestimates by a little under one frame\u000a            WaitForScanner.frameNStart = frameN  # exact frame index\u000a            WaitForScanner.setAutoDraw(True)\u000a        \u000a        # *key_resp_3* updates\u000a        if t >= 0.0 and ScannerTrigger.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ScannerTrigger.tStart = t  # underestimates by a little under one frame\u000a            ScannerTrigger.frameNStart = frameN  # exact frame index\u000a            ScannerTrigger.status = STARTED\u000a            # keyboard checking is just starting\u000a            ScannerTrigger.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if ScannerTrigger.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['r','equal'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                ScannerTrigger.keys = theseKeys[-1]  # just the last key pressed\u000a                ScannerTrigger.rt = ScannerTrigger.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ScanWaitComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            \u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "ScanWait"-------\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if ScannerTrigger.keys in ['', [], None]:  # No response was made\u000a       ScannerTrigger.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('ScannerTrigger.keys',ScannerTrigger.keys)\u000a    if ScannerTrigger.keys != None:  # we had a response\u000a        thisExp.addData('ScannerTrigger.rt', ScannerTrigger.rt)\u000a    thisExp.nextEntry()\u000a    # ########################################################\u000a\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a\u000a    # Write out when the experiment begins\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    #------Prepare to start Routine "intro"-------\u000a    t = 0\u000a    introClock = core.Clock()\u000a    introClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(IntroTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    introComponents = []\u000a    introComponents.append(RestCrossHair)\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "intro"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = introClock.getTime()\u000a        \u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_3* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (0.0 + (IntroTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in introComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "intro"-------\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    # ########################################################\u000a\u000a    for thisTrial in trials:\u000a        # Write to the file the time this trial starts\u000a        trials.addData('TrialStartTime',time.time())\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        # ENCODING SET\u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempStimSet = StimSet\u000a        # Letters for space - letter - space - letter ... - space\u000a        StimSet=' '\u000a        for i in tempStimSet:\u000a            StimSet=StimSet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        UpBrackText = ''\u000a        if UpBrack > 0:\u000a            BracketList = list(str(UpBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,SETletCycle,1):   ## Changed from 13 when using 7 letters\u000a                UpBrackText = UpBrackText+' '\u000a            s = list(UpBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            UpBrackText = ''.join(s)\u000a        \u000a        # PROBE \u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempProbeLet = ProbeLet\u000a        # Letters for space - letter - space - letter ... - space\u000a        ProbeLet=' '\u000a        for i in tempProbeLet:\u000a            ProbeLet = ProbeLet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        BotBrackText = ''\u000a        if BotBrack > 0:\u000a            BracketList = list(str(BotBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,SETletCycle,1):   ## Changed from 13 when using 7 letters\u000a                BotBrackText = BotBrackText+' '\u000a            s = list(BotBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            BotBrackText = ''.join(s)\u000a            \u000a        # update component parameters for each repeat\u000a        UpperText.setText(StimSet)\u000a        UpperBrackets.setText(UpBrackText)\u000a        LowerText.setText(ProbeLet)\u000a        LowerBrackets.setText(BotBrackText)\u000a        \u000a        KeyboardResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        KeyboardResp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(TopUpperLine)\u000a        trialComponents.append(UpperText)\u000a        trialComponents.append(UpperBrackets)\u000a        trialComponents.append(BotUpperLine)\u000a        trialComponents.append(TopLowerLine)\u000a        trialComponents.append(LowerText)\u000a        trialComponents.append(LowerBrackets)\u000a        trialComponents.append(BotLowerLine)\u000a        trialComponents.append(TrialCrossHair)\u000a        trialComponents.append(RestCrossHair)\u000a        trialComponents.append(KeyboardResp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            \u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *TopUpperLine* updates\u000a            if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine.frameNStart = frameN  # exact frame index\u000a                TopUpperLine.setAutoDraw(True)\u000a            elif TopUpperLine.status == STARTED and t >= (0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine.setAutoDraw(False)\u000a            \u000a            # *UpperText* updates\u000a            if t >= 0 and UpperText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText.tStart = t  # underestimates by a little under one frame\u000a                UpperText.frameNStart = frameN  # exact frame index\u000a                UpperText.setAutoDraw(True)\u000a            elif UpperText.status == STARTED and t >= (0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets* updates\u000a            if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets.frameNStart = frameN  # exact frame index\u000a                UpperBrackets.setAutoDraw(True)\u000a            elif UpperBrackets.status == STARTED and t >= (0.0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine* updates\u000a            if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine.frameNStart = frameN  # exact frame index\u000a                BotUpperLine.setAutoDraw(True)\u000a            elif BotUpperLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine* updates\u000a            if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine.frameNStart = frameN  # exact frame index\u000a                TopLowerLine.setAutoDraw(True)\u000a            elif TopLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine.setAutoDraw(False)\u000a            \u000a            # *LowerText* updates\u000a            if t >= ProbeStart and LowerText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText.tStart = t  # underestimates by a little under one frame\u000a                LowerText.frameNStart = frameN  # exact frame index\u000a                LowerText.setAutoDraw(True)\u000a            elif LowerText.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets* updates\u000a            if t >= ProbeStart and LowerBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets.frameNStart = frameN  # exact frame index\u000a                LowerBrackets.setAutoDraw(True)\u000a            elif LowerBrackets.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine* updates\u000a            if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine.frameNStart = frameN  # exact frame index\u000a                BotLowerLine.setAutoDraw(True)\u000a            elif BotLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair* updates\u000a            if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair.setAutoDraw(True)\u000a            elif TrialCrossHair.status == STARTED and t >= (0 + (TrialDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= TrialDur and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            elif RestCrossHair.status == STARTED and t >= (TrialDur + (ITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # *KeyboardResp* updates\u000a            if t >= ProbeStart and KeyboardResp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                KeyboardResp.tStart = t  # underestimates by a little under one frame\u000a                KeyboardResp.frameNStart = frameN  # exact frame index\u000a                KeyboardResp.status = STARTED\u000a                # keyboard checking is just starting\u000a                KeyboardResp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif KeyboardResp.status == STARTED and t >= (ProbeStart + (ProbeDurITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                KeyboardResp.status = STOPPED\u000a            if KeyboardResp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    KeyboardResp.keys.extend(theseKeys)  # storing all keys\u000a                    KeyboardResp.rt.append(KeyboardResp.clock.getTime())\u000a                    # was this 'correct'?\u000a                    if (KeyboardResp.keys == str(Correct)) or (KeyboardResp.keys == Correct):\u000a                        KeyboardResp.corr = 1\u000a                    else:\u000a                        KeyboardResp.corr = 0\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(1)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if KeyboardResp.keys in ['', [], None]:  # No response was made\u000a           KeyboardResp.keys=None\u000a           # was no response the correct answer?!\u000a           if str(Correct).lower() == 'none': KeyboardResp.corr = 1  # correct non-response\u000a           else: KeyboardResp.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('KeyboardResp.keys',KeyboardResp.keys)\u000a        trials.addData('KeyboardResp.corr', KeyboardResp.corr)\u000a        if KeyboardResp.keys != None:  # we had a response\u000a            trials.addData('KeyboardResp.rt', KeyboardResp.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    EndTimeClock = core.Clock()\u000a    EndTimeClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(End)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    EndTimeComponents = []\u000a    EndTimeComponents.append(RestCrossHair)\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = EndTimeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        if RestCrossHair.status == STARTED and t >= (0.0 + (End-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in EndTimeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            #win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # ########################################################\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()    \u000a    # completed 1 repeats of 'trials'\u000a    # the Routine "trial" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    win.close()\u000a    #sys.exit()\u000a    return filename\u000a\u000adef PartialTrialFeedback(INPUTFILE,filename,subid=9999,visitid=9999):\u000a    # filename is for the output file where the data gets written to\u000a    expInfo = {u'Visit ID': u'001', u'Participant ID': u''}\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a        if dlg.OK == False: win.close()  # user pressed cancel\u000a    else:\u000a        print "Subid entered is: %s"%(subid)\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a        \u000a    # Store info about the experiment session\u000a\u000a    \u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    \u000a    # The following line is commented out because now the output file is given as an input. \u000a    # This allows better control over what it is called.\u000a    #filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=True,\u000a        dataFileName=filename)\u000a    #save a log file for detail verbose info\u000a    logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=u'testMonitor', color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'use preferences')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial"\u000a    trialClock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=1.7,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=1.7,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=1.5,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    WaitForScanner = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Waiting for Scanner\u005cn Or press r to advance',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    ThankYou = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Merci\u005cnThank you',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    # Initialize components for Routine "Feedback"\u000a    FeedbackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    FeedbackMsg = visual.TextStim(win=win, ori=0, name='FeedbackMsg',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(INPUTFILE),#TrialListShort1#TrialList5Loads6Repeats\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a\u000a\u000a    # PRESENT THE SCREEN TO WAIT FOR THE MRI TRIGGER\u000a    #vol = launchScan(win, MR_settings,  mode='Scan')\u000a\u000a    # ########################################################\u000a    # There should be WAITING FOR SCANNER trial here\u000a    # The test2 routine has these parts in it\u000a    #------Prepare to start Routine "ScanWait"-------\u000a    t = 0\u000a    ScanWaitClock = core.Clock()\u000a    ScanWaitClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    ScannerTrigger = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    ScannerTrigger.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    ScanWaitComponents = []\u000a    ScanWaitComponents.append(WaitForScanner)\u000a    ScanWaitComponents.append(ScannerTrigger)\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "ScanWait"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = ScanWaitClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_4* updates\u000a        if t >= 0.0 and WaitForScanner.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            WaitForScanner.tStart = t  # underestimates by a little under one frame\u000a            WaitForScanner.frameNStart = frameN  # exact frame index\u000a            WaitForScanner.setAutoDraw(True)\u000a        \u000a        # *key_resp_3* updates\u000a        if t >= 0.0 and ScannerTrigger.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ScannerTrigger.tStart = t  # underestimates by a little under one frame\u000a            ScannerTrigger.frameNStart = frameN  # exact frame index\u000a            ScannerTrigger.status = STARTED\u000a            # keyboard checking is just starting\u000a            ScannerTrigger.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if ScannerTrigger.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['5', 'r'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                ScannerTrigger.keys = theseKeys[-1]  # just the last key pressed\u000a                ScannerTrigger.rt = ScannerTrigger.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ScanWaitComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            #core.quit()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "ScanWait"-------\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if ScannerTrigger.keys in ['', [], None]:  # No response was made\u000a       ScannerTrigger.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('ScannerTrigger.keys',ScannerTrigger.keys)\u000a    if ScannerTrigger.keys != None:  # we had a response\u000a        thisExp.addData('ScannerTrigger.rt', ScannerTrigger.rt)\u000a    thisExp.nextEntry()\u000a    # ########################################################\u000a\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a    IntroTime = 5\u000a    # Write out when the experiment begins\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    #------Prepare to start Routine "intro"-------\u000a    t = 0\u000a    introClock = core.Clock()\u000a    introClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(IntroTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    introComponents = []\u000a    introComponents.append(RestCrossHair)\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "intro"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = introClock.getTime()\u000a        \u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_3* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (0.0 + (IntroTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in introComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "intro"-------\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    # ########################################################\u000a\u000a    for thisTrial in trials:\u000a        # Write to the file the time this trial starts\u000a        trials.addData('TrialStartTime',time.time())\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        # ENCODING SET\u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempStimSet = StimSet\u000a        # Letters for space - letter - space - letter ... - space\u000a        StimSet=' '\u000a        for i in tempStimSet:\u000a            StimSet=StimSet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        UpBrackText = ''\u000a        if UpBrack > 0:\u000a            BracketList = list(str(UpBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,13,1):   ## Changed from 13 when using 7 letters\u000a                UpBrackText = UpBrackText+' '\u000a            s = list(UpBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            UpBrackText = ''.join(s)\u000a        \u000a        # PROBE \u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempProbeLet = ProbeLet\u000a        print '%s'%(tempProbeLet)\u000a        # Letters for space - letter - space - letter ... - space\u000a        ProbeLet=' '\u000a        for i in tempProbeLet:\u000a            ProbeLet = ProbeLet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        BotBrackText = ''\u000a        if BotBrack > 0:\u000a            BracketList = list(str(BotBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,13,1):   ## Changed from 13 when using 7 letters\u000a                BotBrackText = BotBrackText+' '\u000a            s = list(BotBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            BotBrackText = ''.join(s)\u000a            \u000a        # update component parameters for each repeat\u000a        UpperText.setText(StimSet)\u000a        UpperBrackets.setText(UpBrackText)\u000a        LowerText.setText(ProbeLet)\u000a        LowerBrackets.setText(BotBrackText)\u000a        \u000a        KeyboardResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        KeyboardResp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(TopUpperLine)\u000a        trialComponents.append(UpperText)\u000a        trialComponents.append(UpperBrackets)\u000a        trialComponents.append(BotUpperLine)\u000a        trialComponents.append(TopLowerLine)\u000a        trialComponents.append(LowerText)\u000a        trialComponents.append(LowerBrackets)\u000a        trialComponents.append(BotLowerLine)\u000a        trialComponents.append(TrialCrossHair)\u000a        trialComponents.append(RestCrossHair)\u000a        trialComponents.append(KeyboardResp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            \u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *TopUpperLine* updates\u000a            if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine.frameNStart = frameN  # exact frame index\u000a                TopUpperLine.setAutoDraw(True)\u000a            elif TopUpperLine.status == STARTED and t >= (0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine.setAutoDraw(False)\u000a            \u000a            # *UpperText* updates\u000a            if t >= 0 and UpperText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText.tStart = t  # underestimates by a little under one frame\u000a                UpperText.frameNStart = frameN  # exact frame index\u000a                UpperText.setAutoDraw(True)\u000a            elif UpperText.status == STARTED and t >= (0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets* updates\u000a            if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets.frameNStart = frameN  # exact frame index\u000a                UpperBrackets.setAutoDraw(True)\u000a            elif UpperBrackets.status == STARTED and t >= (0.0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine* updates\u000a            if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine.frameNStart = frameN  # exact frame index\u000a                BotUpperLine.setAutoDraw(True)\u000a            elif BotUpperLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine* updates\u000a            if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine.frameNStart = frameN  # exact frame index\u000a                TopLowerLine.setAutoDraw(True)\u000a            elif TopLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine.setAutoDraw(False)\u000a            \u000a            # *LowerText* updates\u000a            if t >= ProbeStart and LowerText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText.tStart = t  # underestimates by a little under one frame\u000a                LowerText.frameNStart = frameN  # exact frame index\u000a                LowerText.setAutoDraw(True)\u000a            elif LowerText.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets* updates\u000a            if t >= ProbeStart and LowerBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets.frameNStart = frameN  # exact frame index\u000a                LowerBrackets.setAutoDraw(True)\u000a            elif LowerBrackets.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine* updates\u000a            if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine.frameNStart = frameN  # exact frame index\u000a                BotLowerLine.setAutoDraw(True)\u000a            elif BotLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair* updates\u000a            if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair.setAutoDraw(True)\u000a            elif TrialCrossHair.status == STARTED and t >= (0 + (TrialDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= TrialDur and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            elif RestCrossHair.status == STARTED and t >= (TrialDur + (ITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # *KeyboardResp* updates\u000a            if t >= ProbeStart and KeyboardResp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                KeyboardResp.tStart = t  # underestimates by a little under one frame\u000a                KeyboardResp.frameNStart = frameN  # exact frame index\u000a                KeyboardResp.status = STARTED\u000a                # keyboard checking is just starting\u000a                KeyboardResp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif KeyboardResp.status == STARTED and t >= (ProbeStart + (ProbeDurITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                KeyboardResp.status = STOPPED\u000a            if KeyboardResp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    #KeyboardResp.keys.extend(theseKeys)  # storing all keys\u000a                    KeyboardResp.keys = theseKeys[-1]  # just the last key pressed\u000a                    #KeyboardResp.rt.append(KeyboardResp.clock.getTime())\u000a                    KeyboardResp.rt = KeyboardResp.clock.getTime()\u000a                    # was this 'correct'?\u000a                    # What if the participant responded whenthey were not supposed to?\u000a                    if str(Correct).lower() == 'none':\u000a                        KeyboardResp.corr = -10 # RESPONSE WHEN NONE WAS EXPECTED\u000a                    else:\u000a                        if (KeyboardResp.keys == str(Correct)) or (KeyboardResp.keys == Correct):\u000a                            KeyboardResp.corr = 1 # CORRECT\u000a                        else:\u000a                            KeyboardResp.corr = 0 # INCORRECT\u000a                    # was this 'correct'?\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(1)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if KeyboardResp.keys in ['', [], None]:  # No response was made\u000a           KeyboardResp.keys=None\u000a           # was no response the correct answer?!\u000a           if str(Correct).lower() == 'none': KeyboardResp.corr = 10  # correct non-response\u000a           else: KeyboardResp.corr = -1  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('KeyboardResp.keys',KeyboardResp.keys)\u000a        trials.addData('KeyboardResp.corr', KeyboardResp.corr)\u000a        if KeyboardResp.keys != None:  # we had a response\u000a            trials.addData('KeyboardResp.rt', KeyboardResp.rt)\u000a        thisExp.nextEntry()\u000a        \u000a        \u000a    # ########################################################    \u000a        #------Prepare to start Routine "Feedback"-------\u000a        FeedbackDur = 1.5\u000a        t = 0\u000a        FeedbackClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(FeedbackDur)\u000a        # update component parameters for each repeat\u000a        if KeyboardResp.corr == 1:#stored on last run routine\u000a          msg="Correct! RT=%.3f" %(KeyboardResp.rt)\u000a        elif KeyboardResp.corr == 0:\u000a          msg="Oops! That was wrong"\u000a        elif KeyboardResp.corr == -1:\u000a          msg="No response...miss"\u000a        elif KeyboardResp.corr == 10:\u000a          msg="No response, good!"\u000a        FeedbackMsg.setText(msg)\u000a        # keep track of which components have finished\u000a        FeedbackComponents = []\u000a        FeedbackComponents.append(FeedbackMsg)\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = FeedbackClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *FeedbackMsg* updates\u000a            if t >= 0.0 and FeedbackMsg.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                FeedbackMsg.tStart = t  # underestimates by a little under one frame\u000a                FeedbackMsg.frameNStart = frameN  # exact frame index\u000a                FeedbackMsg.setAutoDraw(True)\u000a            if FeedbackMsg.status == STARTED and t >= (0.0 + (FeedbackDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                FeedbackMsg.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in FeedbackComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback"-------\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a        #------Prepare to start Routine "REST"-------\u000a        t = 0\u000a        RESTClock = core.Clock()\u000a        RESTClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(1.000000)\u000a        # update component parameters for each repeat\u000a        # keep track of which components have finished\u000a        RESTComponents = []\u000a        RESTComponents.append(RestCrossHair)\u000a        for thisComponent in RESTComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "REST"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = RESTClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            if RestCrossHair.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in RESTComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "REST"-------\u000a        for thisComponent in RESTComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        thisExp.nextEntry()\u000a\u000a\u000a    win.flip()\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a    EndTime = 10\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    EndTimeClock = core.Clock()\u000a    EndTimeClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(EndTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    EndTimeComponents = []\u000a    EndTimeComponents.append(RestCrossHair)\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = EndTimeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        if RestCrossHair.status == STARTED and t >= (0.0 + (EndTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in EndTimeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "EndTime"-------\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a            \u000a    # ########################################################        \u000a    # There should be an intro off trial here also\u000a    ThankYouTime = 3\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    ThankYouClock = core.Clock()\u000a    ThankYouClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(ThankYouTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    ThankYouComponents = []\u000a    ThankYouComponents.append(ThankYou)\u000a    for thisComponent in ThankYouComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = ThankYouClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and ThankYou.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ThankYou.tStart = t  # underestimates by a little under one frame\u000a            ThankYou.frameNStart = frameN  # exact frame index\u000a            ThankYou.setAutoDraw(True)\u000a        if ThankYou.status == STARTED and t >= (0.0 + (ThankYouTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            ThankYou.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ThankYouComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "Thank you"-------\u000a    for thisComponent in ThankYouComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)       \u000a    # ########################################################\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()    \u000a    # completed 1 repeats of 'trials'\u000a    win.close()\u000a#    win.close()\u000a\u000adef Instructions():\u000a    # Store info about the experiment session\u000a    expName = u'Instructions'  # from the Builder filename that created this script\u000a    expInfo = {u'session': u'001', u'participant': u''}\u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=False,\u000a        dataFileName=filename)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=u'UbuntuMon', color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'norm')\u000a\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "ButtonPractice"\u000a    ButtonPracticeClock = core.Clock()\u000a    text_28 = visual.TextStim(win=win, ori=0, name='text_28',\u000a        text="First ...\u005cnLet's make sure the buttons work.\u005cnPress the RIGHT INDEX Finger button.",    font='Courier',\u000a        pos=[0,0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    ISI_14 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_14')\u000a    TopUpperLine_14 = visual.Line(win=win, name='TopUpperLine_14',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_14 = visual.TextStim(win=win, ori=0, name='UpperText_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    UpperBrackets_14 = visual.TextStim(win=win, ori=0, name='UpperBrackets_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    BotUpperLine_14 = visual.Line(win=win, name='BotUpperLine_14',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_14 = visual.Line(win=win, name='TopLowerLine_14',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_14 = visual.TextStim(win=win, ori=0, name='LowerText_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    LowerBrackets_14 = visual.TextStim(win=win, ori=0, name='LowerBrackets_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    BotLowerLine_14 = visual.Line(win=win, name='BotLowerLine_14',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_14 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_14',\u000a        text='\u005cn',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    RestCrossHair_14 = visual.TextStim(win=win, ori=0, name='RestCrossHair_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a\u000a    # Initialize components for Routine "Feedback"\u000a    FeedbackClock = core.Clock()\u000a    msg='?????'\u000a    text_25 = visual.TextStim(win=win, ori=0, name='text_25',\u000a        text='default text',    font='Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Initialize components for Routine "ButtonPractice_MIDDLE"\u000a    ButtonPractice_MIDDLEClock = core.Clock()\u000a    text_29 = visual.TextStim(win=win, ori=0, name='text_29',\u000a        text='Press the RIGHT MIDDLE Finger button.',    font='Courier',\u000a        pos=[0,0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    ISI_15 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_15')\u000a    TopUpperLine_15 = visual.Line(win=win, name='TopUpperLine_15',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_15 = visual.TextStim(win=win, ori=0, name='UpperText_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    UpperBrackets_15 = visual.TextStim(win=win, ori=0, name='UpperBrackets_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    BotUpperLine_15 = visual.Line(win=win, name='BotUpperLine_15',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_15 = visual.Line(win=win, name='TopLowerLine_15',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_15 = visual.TextStim(win=win, ori=0, name='LowerText_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    LowerBrackets_15 = visual.TextStim(win=win, ori=0, name='LowerBrackets_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    BotLowerLine_15 = visual.Line(win=win, name='BotLowerLine_15',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_15 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_15',\u000a        text='\u005cn',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    RestCrossHair_15 = visual.TextStim(win=win, ori=0, name='RestCrossHair_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a\u000a    # Initialize components for Routine "Feedback_MIDDLE"\u000a    Feedback_MIDDLEClock = core.Clock()\u000a    msg='?????'\u000a    text_26 = visual.TextStim(win=win, ori=0, name='text_26',\u000a        text='default text',    font=u'Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_2"\u000a    var_6Letters_2Clock = core.Clock()\u000a    text_13 = visual.TextStim(win=win, ori=0, name='text_13',\u000a        text='This is the screen you will see for each trial',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text_16 = visual.TextStim(win=win, ori=0, name='text_16',\u000a        text='With an UPPER Part',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_18 = visual.TextStim(win=win, ori=0, name='text_18',\u000a        text='And a LOWER part',    font='Courier',\u000a        pos=[0,-0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_21 = visual.TextStim(win=win, ori=0, name='text_21',\u000a        text=None,    font='Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_13 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_13')\u000a    TopUpperLine_13 = visual.Line(win=win, name='TopUpperLine_13',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_13 = visual.TextStim(win=win, ori=0, name='UpperText_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_13 = visual.TextStim(win=win, ori=0, name='UpperBrackets_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_13 = visual.Line(win=win, name='BotUpperLine_13',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_13 = visual.Line(win=win, name='TopLowerLine_13',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_13 = visual.TextStim(win=win, ori=0, name='LowerText_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_13 = visual.TextStim(win=win, ori=0, name='LowerBrackets_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_13 = visual.Line(win=win, name='BotLowerLine_13',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_13 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_13',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_13 = visual.TextStim(win=win, ori=0, name='RestCrossHair_13',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_22 = visual.TextStim(win=win, ori=0, name='text_22',\u000a        text='You will also see a cross hair on the screen',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_23 = visual.TextStim(win=win, ori=0, name='text_23',\u000a        text='Either Green',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_24 = visual.TextStim(win=win, ori=0, name='text_24',\u000a        text='Or RED',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_0"\u000a    var_6Letters_0Clock = core.Clock()\u000a    text_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a        text='For this experiment you will see letters at the top of the screen.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.1,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text = visual.TextStim(win=win, ori=0, name='text',\u000a        text='Some of the letters will be enclosed by brackets.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_6 = visual.TextStim(win=win, ori=0, name='text_6',\u000a        text=u'These are the letters to remember.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a        text='The letters will be removed, focus on the green cross hair.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_11 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_11')\u000a    TopUpperLine_11 = visual.Line(win=win, name='TopUpperLine_11',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_11 = visual.TextStim(win=win, ori=0, name='UpperText_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_11 = visual.TextStim(win=win, ori=0, name='UpperBrackets_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_11 = visual.Line(win=win, name='BotUpperLine_11',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_11 = visual.Line(win=win, name='TopLowerLine_11',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_11 = visual.TextStim(win=win, ori=0, name='LowerText_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_11 = visual.TextStim(win=win, ori=0, name='LowerBrackets_11',\u000a        text='  { }        ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_11 = visual.Line(win=win, name='BotLowerLine_11',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_11 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_11',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_11 = visual.TextStim(win=win, ori=0, name='RestCrossHair_11',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_5 = visual.TextStim(win=win, ori=0, name='text_5',\u000a        text='You will then see letters at the bottom.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.1,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a        text='Only one letter will be in brackets.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a    text_8 = visual.TextStim(win=win, ori=0, name='text_8',\u000a        text='You need to decide whether this letter was one that you had to remember.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-18.0)\u000a    text_9 = visual.TextStim(win=win, ori=0, name='text_9',\u000a        text='YES = INDEX finger button\u005cnNO  = MIDDLE finger button',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-19.0)\u000a    text_10 = visual.TextStim(win=win, ori=0, name='text_10',\u000a        text='The trial is then over and the cross hair turns RED.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-20.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_1"\u000a    var_6Letters_1Clock = core.Clock()\u000a    text_11 = visual.TextStim(win=win, ori=0, name='text_11',\u000a        text=u"Let's Repeat",    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_12 = visual.TextStim(win=win, ori=0, name='text_12',\u000a        text='Remember the letters B and C',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_14 = visual.TextStim(win=win, ori=0, name='text_14',\u000a        text=u'Letters are removed',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    ISI_12 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_12')\u000a    TopUpperLine_12 = visual.Line(win=win, name='TopUpperLine_12',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_12 = visual.TextStim(win=win, ori=0, name='UpperText_12',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-5.0)\u000a    UpperBrackets_12 = visual.TextStim(win=win, ori=0, name='UpperBrackets_12',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    BotUpperLine_12 = visual.Line(win=win, name='BotUpperLine_12',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_12 = visual.Line(win=win, name='TopLowerLine_12',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_12 = visual.TextStim(win=win, ori=0, name='LowerText_12',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    LowerBrackets_12 = visual.TextStim(win=win, ori=0, name='LowerBrackets_12',\u000a        text='  { }        ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    BotLowerLine_12 = visual.Line(win=win, name='BotLowerLine_12',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_12 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_12',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-12.0)\u000a    RestCrossHair_12 = visual.TextStim(win=win, ori=0, name='RestCrossHair_12',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    text_17 = visual.TextStim(win=win, ori=0, name='text_17',\u000a        text=u'Are you trying to remember the letter b?',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_19 = visual.TextStim(win=win, ori=0, name='text_19',\u000a        text=u'Yes you are. You would press the INDEX finger button as quickly as possible.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_20 = visual.TextStim(win=win, ori=0, name='text_20',\u000a        text=u'The trial is over and the cross hair turns RED.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "DemoTrialRealTimes"\u000a    DemoTrialRealTimesClock = core.Clock()\u000a    text_44 = visual.TextStim(win=win, ori=0, name='text_44',\u000a        text=u"Let's repeat at the true pace",    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_45 = visual.TextStim(win=win, ori=0, name='text_45',\u000a        text=u'Remember the letters B and C',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_46 = visual.TextStim(win=win, ori=0, name='text_46',\u000a        text=u'Letters are removed',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    ISI_18 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_18')\u000a    TopUpperLine_18 = visual.Line(win=win, name='TopUpperLine_18',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_18 = visual.TextStim(win=win, ori=0, name='UpperText_18',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-5.0)\u000a    UpperBrackets_18 = visual.TextStim(win=win, ori=0, name='UpperBrackets_18',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    BotUpperLine_18 = visual.Line(win=win, name='BotUpperLine_18',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_18 = visual.Line(win=win, name='TopLowerLine_18',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_17 = visual.TextStim(win=win, ori=0, name='LowerText_17',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    LowerBrackets_17 = visual.TextStim(win=win, ori=0, name='LowerBrackets_17',\u000a        text=u'  { }        ',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    BotLowerLine_18 = visual.Line(win=win, name='BotLowerLine_18',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_18 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_18',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-12.0)\u000a    RestCrossHair_18 = visual.TextStim(win=win, ori=0, name='RestCrossHair_18',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-13.0)\u000a    text_48 = visual.TextStim(win=win, ori=0, name='text_48',\u000a        text=u'Respond as quickly as possible',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_49 = visual.TextStim(win=win, ori=0, name='text_49',\u000a        text=u'The trial is over and the cross hair turns RED.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-16.0)\u000a\u000a    # Initialize components for Routine "NumLettersToRem"\u000a    NumLettersToRemClock = core.Clock()\u000a    text_15 = visual.TextStim(win=win, ori=0, name='text_15',\u000a        text='The number of letters to remember',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text_33 = visual.TextStim(win=win, ori=0, name='text_33',\u000a        text='Varies between 1 and 6',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_34 = visual.TextStim(win=win, ori=0, name='text_34',\u000a        text='There will always be six letters presented',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a        text='It is the brackets that indicate which letters to remember.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    text_35 = visual.TextStim(win=win, ori=0, name='text_35',\u000a        text='Here are some examples',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    UpBrack1 = visual.TextStim(win=win, ori=0, name='UpBrack1',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-5.0)\u000a    ISI_17 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_17')\u000a    TopUpperLine_17 = visual.Line(win=win, name='TopUpperLine_17',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_17 = visual.TextStim(win=win, ori=0, name='UpperText_17',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    UpperBrackets_17 = visual.TextStim(win=win, ori=0, name='UpperBrackets_17',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    BotUpperLine_17 = visual.Line(win=win, name='BotUpperLine_17',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_17 = visual.Line(win=win, name='TopLowerLine_17',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    BotLowerLine_17 = visual.Line(win=win, name='BotLowerLine_17',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_17 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_17',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_17 = visual.TextStim(win=win, ori=0, name='RestCrossHair_17',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    UpBrack2 = visual.TextStim(win=win, ori=0, name='UpBrack2',\u000a        text='{   }        ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    UpBrack3 = visual.TextStim(win=win, ori=0, name='UpBrack3',\u000a        text='      {     }',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='Yellow', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    UpBrack4 = visual.TextStim(win=win, ori=0, name='UpBrack4',\u000a        text='  {       }  ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a    UpBrack5 = visual.TextStim(win=win, ori=0, name='UpBrack5',\u000a        text='{         }  ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-18.0)\u000a    UpBrack6 = visual.TextStim(win=win, ori=0, name='UpBrack6',\u000a        text=u'{           }',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-19.0)\u000a    text_38 = visual.TextStim(win=win, ori=0, name='text_38',\u000a        text=u'One letter',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-20.0)\u000a    text_39 = visual.TextStim(win=win, ori=0, name='text_39',\u000a        text=u'Two letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-21.0)\u000a    text_40 = visual.TextStim(win=win, ori=0, name='text_40',\u000a        text=u'Three letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-22.0)\u000a    text_41 = visual.TextStim(win=win, ori=0, name='text_41',\u000a        text=u'Four letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-23.0)\u000a    text_42 = visual.TextStim(win=win, ori=0, name='text_42',\u000a        text=u'Five letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-24.0)\u000a    text_43 = visual.TextStim(win=win, ori=0, name='text_43',\u000a        text=u'Six letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-25.0)\u000a\u000a    # Initialize components for Routine "TrialParts_1"\u000a    TrialParts_1Clock = core.Clock()\u000a    text_27 = visual.TextStim(win=win, ori=0, name='text_27',\u000a        text=u'To help with the analysis of the brain data.\u005cnSome trials are PARTIAL.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_30 = visual.TextStim(win=win, ori=0, name='text_30',\u000a        text='All trials will have a set of letters to study.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_31 = visual.TextStim(win=win, ori=0, name='text_31',\u000a        text='Some will not require a response',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_32 = visual.TextStim(win=win, ori=0, name='text_32',\u000a        text='Some will have no delay between the letters to study and the response.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_16 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_16')\u000a    TopUpperLine_16 = visual.Line(win=win, name='TopUpperLine_16',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_16 = visual.TextStim(win=win, ori=0, name='UpperText_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_16 = visual.TextStim(win=win, ori=0, name='UpperBrackets_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_16 = visual.Line(win=win, name='BotUpperLine_16',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_16 = visual.Line(win=win, name='TopLowerLine_16',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_16 = visual.TextStim(win=win, ori=0, name='LowerText_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_16 = visual.TextStim(win=win, ori=0, name='LowerBrackets_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_16 = visual.Line(win=win, name='BotLowerLine_16',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_16 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_16 = visual.TextStim(win=win, ori=0, name='RestCrossHair_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_36 = visual.TextStim(win=win, ori=0, name='text_36',\u000a        text='What is important is that when the crosshair turns RED. The trial is over.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_37 = visual.TextStim(win=win, ori=0, name='text_37',\u000a        text='Try to forget any of the studied letters and wait for the next trial',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_50 = visual.TextStim(win=win, ori=0, name='text_50',\u000a        text=u'Here is an example trial with feedback.\u005cnRemember respond as quickly as possible.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "trial5_2"\u000a    trial5_2Clock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'      { }    ',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Initialize components for Routine "TrialFeedBack"\u000a    TrialFeedBackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    text_47 = visual.TextStim(win=win, ori=0, name='text_47',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=10, method='sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a    for thisTrial in trials:\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "ButtonPractice"-------\u000a        t = 0\u000a        ButtonPracticeClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(120.000000)\u000a        # update component parameters for each repeat\u000a        UpperText_14.setText('')\u000a        UpperBrackets_14.setText('')\u000a        LowerText_14.setText('')\u000a        key_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        ButtonPracticeComponents = []\u000a        ButtonPracticeComponents.append(text_28)\u000a        ButtonPracticeComponents.append(ISI_14)\u000a        ButtonPracticeComponents.append(TopUpperLine_14)\u000a        ButtonPracticeComponents.append(UpperText_14)\u000a        ButtonPracticeComponents.append(UpperBrackets_14)\u000a        ButtonPracticeComponents.append(BotUpperLine_14)\u000a        ButtonPracticeComponents.append(TopLowerLine_14)\u000a        ButtonPracticeComponents.append(LowerText_14)\u000a        ButtonPracticeComponents.append(LowerBrackets_14)\u000a        ButtonPracticeComponents.append(BotLowerLine_14)\u000a        ButtonPracticeComponents.append(TrialCrossHair_14)\u000a        ButtonPracticeComponents.append(RestCrossHair_14)\u000a        ButtonPracticeComponents.append(key_resp_2)\u000a        for thisComponent in ButtonPracticeComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "ButtonPractice"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = ButtonPracticeClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_28* updates\u000a            if t >= 0 and text_28.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_28.tStart = t  # underestimates by a little under one frame\u000a                text_28.frameNStart = frameN  # exact frame index\u000a                text_28.setAutoDraw(True)\u000a            elif text_28.status == STARTED and t >= (0 + (60-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_28.setAutoDraw(False)\u000a            \u000a            # *TopUpperLine_14* updates\u000a            if t >= 0 and TopUpperLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine_14.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine_14.frameNStart = frameN  # exact frame index\u000a                TopUpperLine_14.setAutoDraw(True)\u000a            elif TopUpperLine_14.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine_14.setAutoDraw(False)\u000a            \u000a            # *UpperText_14* updates\u000a            if t >= 0 and UpperText_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText_14.tStart = t  # underestimates by a little under one frame\u000a                UpperText_14.frameNStart = frameN  # exact frame index\u000a                UpperText_14.setAutoDraw(True)\u000a            elif UpperText_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText_14.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets_14* updates\u000a            if t >= 0 and UpperBrackets_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets_14.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets_14.frameNStart = frameN  # exact frame index\u000a                UpperBrackets_14.setAutoDraw(True)\u000a            elif UpperBrackets_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets_14.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine_14* updates\u000a            if t >= 0.0 and BotUpperLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine_14.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine_14.frameNStart = frameN  # exact frame index\u000a                BotUpperLine_14.setAutoDraw(True)\u000a            elif BotUpperLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine_14.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine_14* updates\u000a            if t >= 0.0 and TopLowerLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine_14.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine_14.frameNStart = frameN  # exact frame index\u000a                TopLowerLine_14.setAutoDraw(True)\u000a            elif TopLowerLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine_14.setAutoDraw(False)\u000a            \u000a            # *LowerText_14* updates\u000a            if t >= 0 and LowerText_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText_14.tStart = t  # underestimates by a little under one frame\u000a                LowerText_14.frameNStart = frameN  # exact frame index\u000a                LowerText_14.setAutoDraw(True)\u000a            elif LowerText_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText_14.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets_14* updates\u000a            if t >= 0 and LowerBrackets_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets_14.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets_14.frameNStart = frameN  # exact frame index\u000a                LowerBrackets_14.setAutoDraw(True)\u000a            elif LowerBrackets_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets_14.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine_14* updates\u000a            if t >= 0.0 and BotLowerLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine_14.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine_14.frameNStart = frameN  # exact frame index\u000a                BotLowerLine_14.setAutoDraw(True)\u000a            elif BotLowerLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine_14.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair_14* updates\u000a            if t >= 0 and TrialCrossHair_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair_14.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair_14.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair_14.setAutoDraw(True)\u000a            elif TrialCrossHair_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair_14.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair_14* updates\u000a            if t >= 0 and RestCrossHair_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair_14.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair_14.frameNStart = frameN  # exact frame index\u000a                RestCrossHair_14.setAutoDraw(True)\u000a            elif RestCrossHair_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair_14.setAutoDraw(False)\u000a            \u000a            # *key_resp_2* updates\u000a            if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_2.tStart = t  # underestimates by a little under one frame\u000a                key_resp_2.frameNStart = frameN  # exact frame index\u000a                key_resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif key_resp_2.status == STARTED and t >= (0.0 + (60-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_2.status = STOPPED\u000a            if key_resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8', '9','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_2.rt = key_resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_2.keys == str('6')) or (key_resp_2.keys == 'down'):\u000a                        key_resp_2.corr = 1\u000a                    else:\u000a                        key_resp_2.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            # *ISI_14* period\u000a            if t >= 0.0 and ISI_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI_14.tStart = t  # underestimates by a little under one frame\u000a                ISI_14.frameNStart = frameN  # exact frame index\u000a                ISI_14.start(1)\u000a            elif ISI_14.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI_14.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in ButtonPracticeComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                #win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "ButtonPractice"-------\u000a        for thisComponent in ButtonPracticeComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_2.keys in ['', [], None]:  # No response was made\u000a           key_resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str('6').lower() == 'none': key_resp_2.corr = 1  # correct non-response\u000a           else: key_resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('key_resp_2.keys',key_resp_2.keys)\u000a        trials.addData('key_resp_2.corr', key_resp_2.corr)\u000a        if key_resp_2.keys != None:  # we had a response\u000a            trials.addData('key_resp_2.rt', key_resp_2.rt)\u000a        \u000a        #------Prepare to start Routine "Feedback"-------\u000a        t = 0\u000a        FeedbackClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        if len(key_resp_2.keys)<1:\u000a            msg="Please press the RIGHT INDEX Finger button"\u000a            trials.finished = Falses\u000a        elif key_resp_2.corr:#stored on last run routine\u000a            msg="Correct! That button indicates a YES response." \u000a            trials.finished = True\u000a        else:\u000a            msg="Oops! Wrong button, please try again."\u000a            trials.finished = False\u000a        text_25.setText(msg)\u000a        # keep track of which components have finished\u000a        FeedbackComponents = []\u000a        FeedbackComponents.append(text_25)\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = FeedbackClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_25* updates\u000a            if t >= 0.0 and text_25.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_25.tStart = t  # underestimates by a little under one frame\u000a                text_25.frameNStart = frameN  # exact frame index\u000a                text_25.setAutoDraw(True)\u000a            elif text_25.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_25.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in FeedbackComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                \u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback"-------\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 10 repeats of 'trials'\u000a\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials_2 = data.TrialHandler(nReps=10, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='trials_2')\u000a    thisExp.addLoop(trials_2)  # add the loop to the experiment\u000a    thisTrial_2 = trials_2.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_2.rgb)\u000a    if thisTrial_2 != None:\u000a        for paramName in thisTrial_2.keys():\u000a            exec(paramName + '= thisTrial_2.' + paramName)\u000a\u000a    for thisTrial_2 in trials_2:\u000a        currentLoop = trials_2\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_2.rgb)\u000a        if thisTrial_2 != None:\u000a            for paramName in thisTrial_2.keys():\u000a                exec(paramName + '= thisTrial_2.' + paramName)\u000a        \u000a        #------Prepare to start Routine "ButtonPractice_MIDDLE"-------\u000a        t = 0\u000a        ButtonPractice_MIDDLEClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(20.000000)\u000a        # update component parameters for each repeat\u000a        UpperText_15.setText('')\u000a        UpperBrackets_15.setText('')\u000a        LowerText_15.setText('')\u000a        key_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_3.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        ButtonPractice_MIDDLEComponents = []\u000a        ButtonPractice_MIDDLEComponents.append(text_29)\u000a        ButtonPractice_MIDDLEComponents.append(ISI_15)\u000a        ButtonPractice_MIDDLEComponents.append(TopUpperLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(UpperText_15)\u000a        ButtonPractice_MIDDLEComponents.append(UpperBrackets_15)\u000a        ButtonPractice_MIDDLEComponents.append(BotUpperLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(TopLowerLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(LowerText_15)\u000a        ButtonPractice_MIDDLEComponents.append(LowerBrackets_15)\u000a        ButtonPractice_MIDDLEComponents.append(BotLowerLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(TrialCrossHair_15)\u000a        ButtonPractice_MIDDLEComponents.append(RestCrossHair_15)\u000a        ButtonPractice_MIDDLEComponents.append(key_resp_3)\u000a        for thisComponent in ButtonPractice_MIDDLEComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "ButtonPractice_MIDDLE"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = ButtonPractice_MIDDLEClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_29* updates\u000a            if t >= 0 and text_29.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_29.tStart = t  # underestimates by a little under one frame\u000a                text_29.frameNStart = frameN  # exact frame index\u000a                text_29.setAutoDraw(True)\u000a            elif text_29.status == STARTED and t >= (0 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_29.setAutoDraw(False)\u000a            \u000a            # *TopUpperLine_15* updates\u000a            if t >= 0 and TopUpperLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine_15.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine_15.frameNStart = frameN  # exact frame index\u000a                TopUpperLine_15.setAutoDraw(True)\u000a            elif TopUpperLine_15.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine_15.setAutoDraw(False)\u000a            \u000a            # *UpperText_15* updates\u000a            if t >= 0 and UpperText_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText_15.tStart = t  # underestimates by a little under one frame\u000a                UpperText_15.frameNStart = frameN  # exact frame index\u000a                UpperText_15.setAutoDraw(True)\u000a            elif UpperText_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText_15.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets_15* updates\u000a            if t >= 0 and UpperBrackets_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets_15.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets_15.frameNStart = frameN  # exact frame index\u000a                UpperBrackets_15.setAutoDraw(True)\u000a            elif UpperBrackets_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets_15.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine_15* updates\u000a            if t >= 0.0 and BotUpperLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine_15.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine_15.frameNStart = frameN  # exact frame index\u000a                BotUpperLine_15.setAutoDraw(True)\u000a            elif BotUpperLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine_15.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine_15* updates\u000a            if t >= 0.0 and TopLowerLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine_15.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine_15.frameNStart = frameN  # exact frame index\u000a                TopLowerLine_15.setAutoDraw(True)\u000a            elif TopLowerLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine_15.setAutoDraw(False)\u000a            \u000a            # *LowerText_15* updates\u000a            if t >= 0 and LowerText_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText_15.tStart = t  # underestimates by a little under one frame\u000a                LowerText_15.frameNStart = frameN  # exact frame index\u000a                LowerText_15.setAutoDraw(True)\u000a            elif LowerText_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText_15.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets_15* updates\u000a            if t >= 0 and LowerBrackets_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets_15.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets_15.frameNStart = frameN  # exact frame index\u000a                LowerBrackets_15.setAutoDraw(True)\u000a            elif LowerBrackets_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets_15.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine_15* updates\u000a            if t >= 0.0 and BotLowerLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine_15.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine_15.frameNStart = frameN  # exact frame index\u000a                BotLowerLine_15.setAutoDraw(True)\u000a            elif BotLowerLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine_15.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair_15* updates\u000a            if t >= 0 and TrialCrossHair_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair_15.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair_15.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair_15.setAutoDraw(True)\u000a            elif TrialCrossHair_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair_15.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair_15* updates\u000a            if t >= 0 and RestCrossHair_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair_15.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair_15.frameNStart = frameN  # exact frame index\u000a                RestCrossHair_15.setAutoDraw(True)\u000a            elif RestCrossHair_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair_15.setAutoDraw(False)\u000a            \u000a            # *key_resp_3* updates\u000a            if t >= 0.0 and key_resp_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_3.tStart = t  # underestimates by a little under one frame\u000a                key_resp_3.frameNStart = frameN  # exact frame index\u000a                key_resp_3.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_3.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif key_resp_3.status == STARTED and t >= (0.0 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_3.status = STOPPED\u000a            if key_resp_3.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8', '9','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_3.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_3.rt = key_resp_3.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_3.keys == str('7')) or (key_resp_3.keys == 'right'):\u000a                        key_resp_3.corr = 1\u000a                    else:\u000a                        key_resp_3.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            # *ISI_15* period\u000a            if t >= 0.0 and ISI_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI_15.tStart = t  # underestimates by a little under one frame\u000a                ISI_15.frameNStart = frameN  # exact frame index\u000a                ISI_15.start(1)\u000a            elif ISI_15.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI_15.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in ButtonPractice_MIDDLEComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "ButtonPractice_MIDDLE"-------\u000a        for thisComponent in ButtonPractice_MIDDLEComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_3.keys in ['', [], None]:  # No response was made\u000a           key_resp_3.keys=None\u000a           # was no response the correct answer?!\u000a           if str('7').lower() == 'none': key_resp_3.corr = 1  # correct non-response\u000a           else: key_resp_3.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials_2 (TrialHandler)\u000a        trials_2.addData('key_resp_3.keys',key_resp_3.keys)\u000a        trials_2.addData('key_resp_3.corr', key_resp_3.corr)\u000a        if key_resp_3.keys != None:  # we had a response\u000a            trials_2.addData('key_resp_3.rt', key_resp_3.rt)\u000a        \u000a        #------Prepare to start Routine "Feedback_MIDDLE"-------\u000a        t = 0\u000a        Feedback_MIDDLEClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        if len(key_resp_3.keys)<1:\u000a            msg="Please press the RIGHT MIDDLE Finger button"\u000a            trials_2.finished = Falses\u000a        elif key_resp_3.corr:#stored on last run routine\u000a            msg="Good! That button indicates a NO response." \u000a            trials_2.finished = True\u000a        else:\u000a            msg="Oops! Wrong button, please try again."\u000a            trials_2.finished = False\u000a        text_26.setText(msg)\u000a        # keep track of which components have finished\u000a        Feedback_MIDDLEComponents = []\u000a        Feedback_MIDDLEComponents.append(text_26)\u000a        for thisComponent in Feedback_MIDDLEComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback_MIDDLE"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = Feedback_MIDDLEClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_26* updates\u000a            if t >= 0.0 and text_26.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_26.tStart = t  # underestimates by a little under one frame\u000a                text_26.frameNStart = frameN  # exact frame index\u000a                text_26.setAutoDraw(True)\u000a            elif text_26.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_26.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Feedback_MIDDLEComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback_MIDDLE"-------\u000a        for thisComponent in Feedback_MIDDLEComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 10 repeats of 'trials_2'\u000a\u000a\u000a    #------Prepare to start Routine "var_6Letters_2"-------\u000a    t = 0\u000a    var_6Letters_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(20.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_13.setText('')\u000a    UpperBrackets_13.setText('')\u000a    LowerText_13.setText('')\u000a    # keep track of which components have finished\u000a    var_6Letters_2Components = []\u000a    var_6Letters_2Components.append(text_13)\u000a    var_6Letters_2Components.append(text_16)\u000a    var_6Letters_2Components.append(text_18)\u000a    var_6Letters_2Components.append(text_21)\u000a    var_6Letters_2Components.append(ISI_13)\u000a    var_6Letters_2Components.append(TopUpperLine_13)\u000a    var_6Letters_2Components.append(UpperText_13)\u000a    var_6Letters_2Components.append(UpperBrackets_13)\u000a    var_6Letters_2Components.append(BotUpperLine_13)\u000a    var_6Letters_2Components.append(TopLowerLine_13)\u000a    var_6Letters_2Components.append(LowerText_13)\u000a    var_6Letters_2Components.append(LowerBrackets_13)\u000a    var_6Letters_2Components.append(BotLowerLine_13)\u000a    var_6Letters_2Components.append(TrialCrossHair_13)\u000a    var_6Letters_2Components.append(RestCrossHair_13)\u000a    var_6Letters_2Components.append(text_22)\u000a    var_6Letters_2Components.append(text_23)\u000a    var_6Letters_2Components.append(text_24)\u000a    for thisComponent in var_6Letters_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_13* updates\u000a        if t >= 0.0 and text_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_13.tStart = t  # underestimates by a little under one frame\u000a            text_13.frameNStart = frameN  # exact frame index\u000a            text_13.setAutoDraw(True)\u000a        elif text_13.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_13.setAutoDraw(False)\u000a        \u000a        # *text_16* updates\u000a        if t >= 3 and text_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_16.tStart = t  # underestimates by a little under one frame\u000a            text_16.frameNStart = frameN  # exact frame index\u000a            text_16.setAutoDraw(True)\u000a        elif text_16.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_16.setAutoDraw(False)\u000a        \u000a        # *text_18* updates\u000a        if t >= 6 and text_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_18.tStart = t  # underestimates by a little under one frame\u000a            text_18.frameNStart = frameN  # exact frame index\u000a            text_18.setAutoDraw(True)\u000a        elif text_18.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_18.setAutoDraw(False)\u000a        \u000a        # *text_21* updates\u000a        if t >= 0 and text_21.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_21.tStart = t  # underestimates by a little under one frame\u000a            text_21.frameNStart = frameN  # exact frame index\u000a            text_21.setAutoDraw(True)\u000a        elif text_21.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_21.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_13* updates\u000a        if t >= 0 and TopUpperLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_13.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_13.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_13.setAutoDraw(True)\u000a        elif TopUpperLine_13.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_13.setAutoDraw(False)\u000a        \u000a        # *UpperText_13* updates\u000a        if t >= 0 and UpperText_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_13.tStart = t  # underestimates by a little under one frame\u000a            UpperText_13.frameNStart = frameN  # exact frame index\u000a            UpperText_13.setAutoDraw(True)\u000a        elif UpperText_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_13.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_13* updates\u000a        if t >= 0 and UpperBrackets_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_13.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_13.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_13.setAutoDraw(True)\u000a        elif UpperBrackets_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_13.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_13* updates\u000a        if t >= 0.0 and BotUpperLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_13.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_13.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_13.setAutoDraw(True)\u000a        elif BotUpperLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_13.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_13* updates\u000a        if t >= 0.0 and TopLowerLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_13.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_13.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_13.setAutoDraw(True)\u000a        elif TopLowerLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_13.setAutoDraw(False)\u000a        \u000a        # *LowerText_13* updates\u000a        if t >= 0 and LowerText_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_13.tStart = t  # underestimates by a little under one frame\u000a            LowerText_13.frameNStart = frameN  # exact frame index\u000a            LowerText_13.setAutoDraw(True)\u000a        elif LowerText_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_13.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_13* updates\u000a        if t >= 0 and LowerBrackets_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_13.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_13.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_13.setAutoDraw(True)\u000a        elif LowerBrackets_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_13.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_13* updates\u000a        if t >= 0.0 and BotLowerLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_13.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_13.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_13.setAutoDraw(True)\u000a        elif BotLowerLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_13.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_13* updates\u000a        if t >= 12 and TrialCrossHair_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_13.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_13.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_13.setAutoDraw(True)\u000a        elif TrialCrossHair_13.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_13.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_13* updates\u000a        if t >= 15 and RestCrossHair_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_13.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_13.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_13.setAutoDraw(True)\u000a        elif RestCrossHair_13.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_13.setAutoDraw(False)\u000a        \u000a        # *text_22* updates\u000a        if t >= 9 and text_22.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_22.tStart = t  # underestimates by a little under one frame\u000a            text_22.frameNStart = frameN  # exact frame index\u000a            text_22.setAutoDraw(True)\u000a        elif text_22.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_22.setAutoDraw(False)\u000a        \u000a        # *text_23* updates\u000a        if t >= 12 and text_23.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_23.tStart = t  # underestimates by a little under one frame\u000a            text_23.frameNStart = frameN  # exact frame index\u000a            text_23.setAutoDraw(True)\u000a        elif text_23.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_23.setAutoDraw(False)\u000a        \u000a        # *text_24* updates\u000a        if t >= 15 and text_24.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_24.tStart = t  # underestimates by a little under one frame\u000a            text_24.frameNStart = frameN  # exact frame index\u000a            text_24.setAutoDraw(True)\u000a        elif text_24.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_24.setAutoDraw(False)\u000a        # *ISI_13* period\u000a        if t >= 0.0 and ISI_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_13.tStart = t  # underestimates by a little under one frame\u000a            ISI_13.frameNStart = frameN  # exact frame index\u000a            ISI_13.start(1)\u000a        elif ISI_13.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_13.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_2"-------\u000a    for thisComponent in var_6Letters_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "var_6Letters_0"-------\u000a    t = 0\u000a    var_6Letters_0Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(30.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_11.setText(' A B C D E F ')\u000a    UpperBrackets_11.setText('  {   }      ')\u000a    LowerText_11.setText(' a b c d e f ')\u000a    KeyboardResp_11 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_11.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    var_6Letters_0Components = []\u000a    var_6Letters_0Components.append(text_2)\u000a    var_6Letters_0Components.append(text)\u000a    var_6Letters_0Components.append(text_6)\u000a    var_6Letters_0Components.append(text_4)\u000a    var_6Letters_0Components.append(ISI_11)\u000a    var_6Letters_0Components.append(TopUpperLine_11)\u000a    var_6Letters_0Components.append(UpperText_11)\u000a    var_6Letters_0Components.append(UpperBrackets_11)\u000a    var_6Letters_0Components.append(BotUpperLine_11)\u000a    var_6Letters_0Components.append(TopLowerLine_11)\u000a    var_6Letters_0Components.append(LowerText_11)\u000a    var_6Letters_0Components.append(LowerBrackets_11)\u000a    var_6Letters_0Components.append(BotLowerLine_11)\u000a    var_6Letters_0Components.append(TrialCrossHair_11)\u000a    var_6Letters_0Components.append(RestCrossHair_11)\u000a    var_6Letters_0Components.append(KeyboardResp_11)\u000a    var_6Letters_0Components.append(text_5)\u000a    var_6Letters_0Components.append(text_7)\u000a    var_6Letters_0Components.append(text_8)\u000a    var_6Letters_0Components.append(text_9)\u000a    var_6Letters_0Components.append(text_10)\u000a    for thisComponent in var_6Letters_0Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_0"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_0Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_2* updates\u000a        if t >= 0.0 and text_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_2.tStart = t  # underestimates by a little under one frame\u000a            text_2.frameNStart = frameN  # exact frame index\u000a            text_2.setAutoDraw(True)\u000a        elif text_2.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_2.setAutoDraw(False)\u000a        \u000a        # *text* updates\u000a        if t >= 3 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        elif text.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # *text_6* updates\u000a        if t >= 6 and text_6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_6.tStart = t  # underestimates by a little under one frame\u000a            text_6.frameNStart = frameN  # exact frame index\u000a            text_6.setAutoDraw(True)\u000a        elif text_6.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_6.setAutoDraw(False)\u000a        \u000a        # *text_4* updates\u000a        if t >= 9 and text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_4.tStart = t  # underestimates by a little under one frame\u000a            text_4.frameNStart = frameN  # exact frame index\u000a            text_4.setAutoDraw(True)\u000a        elif text_4.status == STARTED and t >= (9 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_4.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_11* updates\u000a        if t >= 0 and TopUpperLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_11.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_11.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_11.setAutoDraw(True)\u000a        elif TopUpperLine_11.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_11.setAutoDraw(False)\u000a        \u000a        # *UpperText_11* updates\u000a        if t >= 0 and UpperText_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_11.tStart = t  # underestimates by a little under one frame\u000a            UpperText_11.frameNStart = frameN  # exact frame index\u000a            UpperText_11.setAutoDraw(True)\u000a        elif UpperText_11.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_11.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_11* updates\u000a        if t >= 3 and UpperBrackets_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_11.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_11.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_11.setAutoDraw(True)\u000a        elif UpperBrackets_11.status == STARTED and t >= (3 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_11.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_11* updates\u000a        if t >= 0.0 and BotUpperLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_11.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_11.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_11.setAutoDraw(True)\u000a        elif BotUpperLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_11.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_11* updates\u000a        if t >= 0.0 and TopLowerLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_11.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_11.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_11.setAutoDraw(True)\u000a        elif TopLowerLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_11.setAutoDraw(False)\u000a        \u000a        # *LowerText_11* updates\u000a        if t >= 14 and LowerText_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_11.tStart = t  # underestimates by a little under one frame\u000a            LowerText_11.frameNStart = frameN  # exact frame index\u000a            LowerText_11.setAutoDraw(True)\u000a        elif LowerText_11.status == STARTED and t >= (14 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_11.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_11* updates\u000a        if t >= 17 and LowerBrackets_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_11.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_11.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_11.setAutoDraw(True)\u000a        elif LowerBrackets_11.status == STARTED and t >= (17 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_11.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_11* updates\u000a        if t >= 0.0 and BotLowerLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_11.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_11.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_11.setAutoDraw(True)\u000a        elif BotLowerLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_11.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_11* updates\u000a        if t >= 0 and TrialCrossHair_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_11.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_11.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_11.setAutoDraw(True)\u000a        elif TrialCrossHair_11.status == STARTED and t >= (0 + (26-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_11.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_11* updates\u000a        if t >= 26 and RestCrossHair_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_11.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_11.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_11.setAutoDraw(True)\u000a        elif RestCrossHair_11.status == STARTED and t >= (26 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_11.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_11* updates\u000a        if t >= 0 and KeyboardResp_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_11.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_11.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_11.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_11.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_11.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_11.status = STOPPED\u000a        if KeyboardResp_11.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_11.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_11.rt.append(KeyboardResp_11.clock.getTime())\u000a        \u000a        # *text_5* updates\u000a        if t >= 14 and text_5.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_5.tStart = t  # underestimates by a little under one frame\u000a            text_5.frameNStart = frameN  # exact frame index\u000a            text_5.setAutoDraw(True)\u000a        elif text_5.status == STARTED and t >= (14 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_5.setAutoDraw(False)\u000a        \u000a        # *text_7* updates\u000a        if t >= 17 and text_7.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_7.tStart = t  # underestimates by a little under one frame\u000a            text_7.frameNStart = frameN  # exact frame index\u000a            text_7.setAutoDraw(True)\u000a        elif text_7.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_7.setAutoDraw(False)\u000a        \u000a        # *text_8* updates\u000a        if t >= 20 and text_8.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_8.tStart = t  # underestimates by a little under one frame\u000a            text_8.frameNStart = frameN  # exact frame index\u000a            text_8.setAutoDraw(True)\u000a        elif text_8.status == STARTED and t >= (20 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_8.setAutoDraw(False)\u000a        \u000a        # *text_9* updates\u000a        if t >= 23 and text_9.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_9.tStart = t  # underestimates by a little under one frame\u000a            text_9.frameNStart = frameN  # exact frame index\u000a            text_9.setAutoDraw(True)\u000a        elif text_9.status == STARTED and t >= (23 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_9.setAutoDraw(False)\u000a        \u000a        # *text_10* updates\u000a        if t >= 26 and text_10.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_10.tStart = t  # underestimates by a little under one frame\u000a            text_10.frameNStart = frameN  # exact frame index\u000a            text_10.setAutoDraw(True)\u000a        elif text_10.status == STARTED and t >= (26 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_10.setAutoDraw(False)\u000a        # *ISI_11* period\u000a        if t >= 0.0 and ISI_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_11.tStart = t  # underestimates by a little under one frame\u000a            ISI_11.frameNStart = frameN  # exact frame index\u000a            ISI_11.start(1)\u000a        elif ISI_11.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_11.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_0Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_0"-------\u000a    for thisComponent in var_6Letters_0Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_11.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_11.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_11.keys',KeyboardResp_11.keys)\u000a    if KeyboardResp_11.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_11.rt', KeyboardResp_11.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "var_6Letters_1"-------\u000a    t = 0\u000a    var_6Letters_1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(22.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_12.setText(' A B C D E F ')\u000a    UpperBrackets_12.setText('  {   }      ')\u000a    LowerText_12.setText(u' a b c d e f ')\u000a    KeyboardResp_12 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_12.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    var_6Letters_1Components = []\u000a    var_6Letters_1Components.append(text_11)\u000a    var_6Letters_1Components.append(text_12)\u000a    var_6Letters_1Components.append(text_14)\u000a    var_6Letters_1Components.append(ISI_12)\u000a    var_6Letters_1Components.append(TopUpperLine_12)\u000a    var_6Letters_1Components.append(UpperText_12)\u000a    var_6Letters_1Components.append(UpperBrackets_12)\u000a    var_6Letters_1Components.append(BotUpperLine_12)\u000a    var_6Letters_1Components.append(TopLowerLine_12)\u000a    var_6Letters_1Components.append(LowerText_12)\u000a    var_6Letters_1Components.append(LowerBrackets_12)\u000a    var_6Letters_1Components.append(BotLowerLine_12)\u000a    var_6Letters_1Components.append(TrialCrossHair_12)\u000a    var_6Letters_1Components.append(RestCrossHair_12)\u000a    var_6Letters_1Components.append(KeyboardResp_12)\u000a    var_6Letters_1Components.append(text_17)\u000a    var_6Letters_1Components.append(text_19)\u000a    var_6Letters_1Components.append(text_20)\u000a    for thisComponent in var_6Letters_1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_11* updates\u000a        if t >= 0.0 and text_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_11.tStart = t  # underestimates by a little under one frame\u000a            text_11.frameNStart = frameN  # exact frame index\u000a            text_11.setAutoDraw(True)\u000a        elif text_11.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_11.setAutoDraw(False)\u000a        \u000a        # *text_12* updates\u000a        if t >= 3 and text_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_12.tStart = t  # underestimates by a little under one frame\u000a            text_12.frameNStart = frameN  # exact frame index\u000a            text_12.setAutoDraw(True)\u000a        elif text_12.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_12.setAutoDraw(False)\u000a        \u000a        # *text_14* updates\u000a        if t >= 6 and text_14.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_14.tStart = t  # underestimates by a little under one frame\u000a            text_14.frameNStart = frameN  # exact frame index\u000a            text_14.setAutoDraw(True)\u000a        elif text_14.status == STARTED and t >= (6 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_14.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_12* updates\u000a        if t >= 0 and TopUpperLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_12.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_12.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_12.setAutoDraw(True)\u000a        elif TopUpperLine_12.status == STARTED and t >= (0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_12.setAutoDraw(False)\u000a        \u000a        # *UpperText_12* updates\u000a        if t >= 0 and UpperText_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_12.tStart = t  # underestimates by a little under one frame\u000a            UpperText_12.frameNStart = frameN  # exact frame index\u000a            UpperText_12.setAutoDraw(True)\u000a        elif UpperText_12.status == STARTED and t >= (0 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_12.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_12* updates\u000a        if t >= 3 and UpperBrackets_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_12.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_12.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_12.setAutoDraw(True)\u000a        elif UpperBrackets_12.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_12.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_12* updates\u000a        if t >= 0.0 and BotUpperLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_12.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_12.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_12.setAutoDraw(True)\u000a        elif BotUpperLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_12.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_12* updates\u000a        if t >= 0.0 and TopLowerLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_12.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_12.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_12.setAutoDraw(True)\u000a        elif TopLowerLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_12.setAutoDraw(False)\u000a        \u000a        # *LowerText_12* updates\u000a        if t >= 11 and LowerText_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_12.tStart = t  # underestimates by a little under one frame\u000a            LowerText_12.frameNStart = frameN  # exact frame index\u000a            LowerText_12.setAutoDraw(True)\u000a        elif LowerText_12.status == STARTED and t >= (11 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_12.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_12* updates\u000a        if t >= 11 and LowerBrackets_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_12.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_12.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_12.setAutoDraw(True)\u000a        elif LowerBrackets_12.status == STARTED and t >= (11 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_12.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_12* updates\u000a        if t >= 0.0 and BotLowerLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_12.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_12.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_12.setAutoDraw(True)\u000a        elif BotLowerLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_12.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_12* updates\u000a        if t >= 0 and TrialCrossHair_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_12.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_12.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_12.setAutoDraw(True)\u000a        elif TrialCrossHair_12.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_12.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_12* updates\u000a        if t >= 17 and RestCrossHair_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_12.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_12.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_12.setAutoDraw(True)\u000a        elif RestCrossHair_12.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_12.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_12* updates\u000a        if t >= 0 and KeyboardResp_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_12.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_12.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_12.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_12.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_12.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_12.status = STOPPED\u000a        if KeyboardResp_12.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_12.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_12.rt.append(KeyboardResp_12.clock.getTime())\u000a        \u000a        # *text_17* updates\u000a        if t >= 11 and text_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_17.tStart = t  # underestimates by a little under one frame\u000a            text_17.frameNStart = frameN  # exact frame index\u000a            text_17.setAutoDraw(True)\u000a        elif text_17.status == STARTED and t >= (11 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_17.setAutoDraw(False)\u000a        \u000a        # *text_19* updates\u000a        if t >= 14 and text_19.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_19.tStart = t  # underestimates by a little under one frame\u000a            text_19.frameNStart = frameN  # exact frame index\u000a            text_19.setAutoDraw(True)\u000a        elif text_19.status == STARTED and t >= (14 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_19.setAutoDraw(False)\u000a        \u000a        # *text_20* updates\u000a        if t >= 17 and text_20.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_20.tStart = t  # underestimates by a little under one frame\u000a            text_20.frameNStart = frameN  # exact frame index\u000a            text_20.setAutoDraw(True)\u000a        elif text_20.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_20.setAutoDraw(False)\u000a        # *ISI_12* period\u000a        if t >= 0.0 and ISI_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_12.tStart = t  # underestimates by a little under one frame\u000a            ISI_12.frameNStart = frameN  # exact frame index\u000a            ISI_12.start(1)\u000a        elif ISI_12.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_12.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_1"-------\u000a    for thisComponent in var_6Letters_1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_12.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_12.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_12.keys',KeyboardResp_12.keys)\u000a    if KeyboardResp_12.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_12.rt', KeyboardResp_12.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "DemoTrialRealTimes"-------\u000a    t = 0\u000a    DemoTrialRealTimesClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(17.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_18.setText(u' A B C D E F ')\u000a    UpperBrackets_18.setText(u'  {   }      ')\u000a    LowerText_17.setText(u' a b c d e f ')\u000a    KeyboardResp_13 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_13.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    DemoTrialRealTimesComponents = []\u000a    DemoTrialRealTimesComponents.append(text_44)\u000a    DemoTrialRealTimesComponents.append(text_45)\u000a    DemoTrialRealTimesComponents.append(text_46)\u000a    DemoTrialRealTimesComponents.append(ISI_18)\u000a    DemoTrialRealTimesComponents.append(TopUpperLine_18)\u000a    DemoTrialRealTimesComponents.append(UpperText_18)\u000a    DemoTrialRealTimesComponents.append(UpperBrackets_18)\u000a    DemoTrialRealTimesComponents.append(BotUpperLine_18)\u000a    DemoTrialRealTimesComponents.append(TopLowerLine_18)\u000a    DemoTrialRealTimesComponents.append(LowerText_17)\u000a    DemoTrialRealTimesComponents.append(LowerBrackets_17)\u000a    DemoTrialRealTimesComponents.append(BotLowerLine_18)\u000a    DemoTrialRealTimesComponents.append(TrialCrossHair_18)\u000a    DemoTrialRealTimesComponents.append(RestCrossHair_18)\u000a    DemoTrialRealTimesComponents.append(KeyboardResp_13)\u000a    DemoTrialRealTimesComponents.append(text_48)\u000a    DemoTrialRealTimesComponents.append(text_49)\u000a    for thisComponent in DemoTrialRealTimesComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "DemoTrialRealTimes"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = DemoTrialRealTimesClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_44* updates\u000a        if t >= 0.0 and text_44.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_44.tStart = t  # underestimates by a little under one frame\u000a            text_44.frameNStart = frameN  # exact frame index\u000a            text_44.setAutoDraw(True)\u000a        elif text_44.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_44.setAutoDraw(False)\u000a        \u000a        # *text_45* updates\u000a        if t >= 3 and text_45.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_45.tStart = t  # underestimates by a little under one frame\u000a            text_45.frameNStart = frameN  # exact frame index\u000a            text_45.setAutoDraw(True)\u000a        elif text_45.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_45.setAutoDraw(False)\u000a        \u000a        # *text_46* updates\u000a        if t >= 5 and text_46.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_46.tStart = t  # underestimates by a little under one frame\u000a            text_46.frameNStart = frameN  # exact frame index\u000a            text_46.setAutoDraw(True)\u000a        elif text_46.status == STARTED and t >= (5 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_46.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_18* updates\u000a        if t >= 0 and TopUpperLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_18.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_18.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_18.setAutoDraw(True)\u000a        elif TopUpperLine_18.status == STARTED and t >= (0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_18.setAutoDraw(False)\u000a        \u000a        # *UpperText_18* updates\u000a        if t >= 3 and UpperText_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_18.tStart = t  # underestimates by a little under one frame\u000a            UpperText_18.frameNStart = frameN  # exact frame index\u000a            UpperText_18.setAutoDraw(True)\u000a        elif UpperText_18.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_18.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_18* updates\u000a        if t >= 3 and UpperBrackets_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_18.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_18.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_18.setAutoDraw(True)\u000a        elif UpperBrackets_18.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_18.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_18* updates\u000a        if t >= 0.0 and BotUpperLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_18.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_18.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_18.setAutoDraw(True)\u000a        elif BotUpperLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_18.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_18* updates\u000a        if t >= 0.0 and TopLowerLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_18.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_18.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_18.setAutoDraw(True)\u000a        elif TopLowerLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_18.setAutoDraw(False)\u000a        \u000a        # *LowerText_17* updates\u000a        if t >= 10 and LowerText_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_17.tStart = t  # underestimates by a little under one frame\u000a            LowerText_17.frameNStart = frameN  # exact frame index\u000a            LowerText_17.setAutoDraw(True)\u000a        elif LowerText_17.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_17.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_17* updates\u000a        if t >= 10 and LowerBrackets_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_17.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_17.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_17.setAutoDraw(True)\u000a        elif LowerBrackets_17.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_17.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_18* updates\u000a        if t >= 0.0 and BotLowerLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_18.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_18.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_18.setAutoDraw(True)\u000a        elif BotLowerLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_18.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_18* updates\u000a        if t >= 0 and TrialCrossHair_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_18.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_18.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_18.setAutoDraw(True)\u000a        elif TrialCrossHair_18.status == STARTED and t >= (0 + (12-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_18.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_18* updates\u000a        if t >= 12 and RestCrossHair_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_18.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_18.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_18.setAutoDraw(True)\u000a        elif RestCrossHair_18.status == STARTED and t >= (12 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_18.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_13* updates\u000a        if t >= 0 and KeyboardResp_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_13.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_13.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_13.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_13.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_13.status = STOPPED\u000a        if KeyboardResp_13.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_13.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_13.rt.append(KeyboardResp_13.clock.getTime())\u000a        \u000a        # *text_48* updates\u000a        if t >= 10 and text_48.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_48.tStart = t  # underestimates by a little under one frame\u000a            text_48.frameNStart = frameN  # exact frame index\u000a            text_48.setAutoDraw(True)\u000a        elif text_48.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_48.setAutoDraw(False)\u000a        \u000a        # *text_49* updates\u000a        if t >= 12 and text_49.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_49.tStart = t  # underestimates by a little under one frame\u000a            text_49.frameNStart = frameN  # exact frame index\u000a            text_49.setAutoDraw(True)\u000a        elif text_49.status == STARTED and t >= (12 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_49.setAutoDraw(False)\u000a        # *ISI_18* period\u000a        if t >= 0.0 and ISI_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_18.tStart = t  # underestimates by a little under one frame\u000a            ISI_18.frameNStart = frameN  # exact frame index\u000a            ISI_18.start(1)\u000a        elif ISI_18.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_18.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in DemoTrialRealTimesComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "DemoTrialRealTimes"-------\u000a    for thisComponent in DemoTrialRealTimesComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_13.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_13.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_13.keys',KeyboardResp_13.keys)\u000a    if KeyboardResp_13.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_13.rt', KeyboardResp_13.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "NumLettersToRem"-------\u000a    t = 0\u000a    NumLettersToRemClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(30.000000)\u000a    # update component parameters for each repeat\u000a    UpBrack1.setText('        { }  ')\u000a    UpperText_17.setText(' A B C D E F ')\u000a    UpperBrackets_17.setText('')\u000a    # keep track of which components have finished\u000a    NumLettersToRemComponents = []\u000a    NumLettersToRemComponents.append(text_15)\u000a    NumLettersToRemComponents.append(text_33)\u000a    NumLettersToRemComponents.append(text_34)\u000a    NumLettersToRemComponents.append(text_3)\u000a    NumLettersToRemComponents.append(text_35)\u000a    NumLettersToRemComponents.append(UpBrack1)\u000a    NumLettersToRemComponents.append(ISI_17)\u000a    NumLettersToRemComponents.append(TopUpperLine_17)\u000a    NumLettersToRemComponents.append(UpperText_17)\u000a    NumLettersToRemComponents.append(UpperBrackets_17)\u000a    NumLettersToRemComponents.append(BotUpperLine_17)\u000a    NumLettersToRemComponents.append(TopLowerLine_17)\u000a    NumLettersToRemComponents.append(BotLowerLine_17)\u000a    NumLettersToRemComponents.append(TrialCrossHair_17)\u000a    NumLettersToRemComponents.append(RestCrossHair_17)\u000a    NumLettersToRemComponents.append(UpBrack2)\u000a    NumLettersToRemComponents.append(UpBrack3)\u000a    NumLettersToRemComponents.append(UpBrack4)\u000a    NumLettersToRemComponents.append(UpBrack5)\u000a    NumLettersToRemComponents.append(UpBrack6)\u000a    NumLettersToRemComponents.append(text_38)\u000a    NumLettersToRemComponents.append(text_39)\u000a    NumLettersToRemComponents.append(text_40)\u000a    NumLettersToRemComponents.append(text_41)\u000a    NumLettersToRemComponents.append(text_42)\u000a    NumLettersToRemComponents.append(text_43)\u000a    for thisComponent in NumLettersToRemComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "NumLettersToRem"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = NumLettersToRemClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_15* updates\u000a        if t >= 0.0 and text_15.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_15.tStart = t  # underestimates by a little under one frame\u000a            text_15.frameNStart = frameN  # exact frame index\u000a            text_15.setAutoDraw(True)\u000a        elif text_15.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_15.setAutoDraw(False)\u000a        \u000a        # *text_33* updates\u000a        if t >= 3 and text_33.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_33.tStart = t  # underestimates by a little under one frame\u000a            text_33.frameNStart = frameN  # exact frame index\u000a            text_33.setAutoDraw(True)\u000a        elif text_33.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_33.setAutoDraw(False)\u000a        \u000a        # *text_34* updates\u000a        if t >= 6 and text_34.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_34.tStart = t  # underestimates by a little under one frame\u000a            text_34.frameNStart = frameN  # exact frame index\u000a            text_34.setAutoDraw(True)\u000a        elif text_34.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_34.setAutoDraw(False)\u000a        \u000a        # *text_3* updates\u000a        if t >= 9 and text_3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_3.tStart = t  # underestimates by a little under one frame\u000a            text_3.frameNStart = frameN  # exact frame index\u000a            text_3.setAutoDraw(True)\u000a        elif text_3.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_3.setAutoDraw(False)\u000a        \u000a        # *text_35* updates\u000a        if t >= 12 and text_35.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_35.tStart = t  # underestimates by a little under one frame\u000a            text_35.frameNStart = frameN  # exact frame index\u000a            text_35.setAutoDraw(True)\u000a        elif text_35.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_35.setAutoDraw(False)\u000a        \u000a        # *UpBrack1* updates\u000a        if t >= 15 and UpBrack1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack1.tStart = t  # underestimates by a little under one frame\u000a            UpBrack1.frameNStart = frameN  # exact frame index\u000a            UpBrack1.setAutoDraw(True)\u000a        elif UpBrack1.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack1.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_17* updates\u000a        if t >= 0 and TopUpperLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_17.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_17.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_17.setAutoDraw(True)\u000a        elif TopUpperLine_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_17.setAutoDraw(False)\u000a        \u000a        # *UpperText_17* updates\u000a        if t >= 0 and UpperText_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_17.tStart = t  # underestimates by a little under one frame\u000a            UpperText_17.frameNStart = frameN  # exact frame index\u000a            UpperText_17.setAutoDraw(True)\u000a        elif UpperText_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_17.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_17* updates\u000a        if t >= 0.0 and UpperBrackets_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_17.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_17.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_17.setAutoDraw(True)\u000a        elif UpperBrackets_17.status == STARTED and t >= (0.0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_17.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_17* updates\u000a        if t >= 0.0 and BotUpperLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_17.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_17.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_17.setAutoDraw(True)\u000a        elif BotUpperLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_17.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_17* updates\u000a        if t >= 0.0 and TopLowerLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_17.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_17.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_17.setAutoDraw(True)\u000a        elif TopLowerLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_17.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_17* updates\u000a        if t >= 0.0 and BotLowerLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_17.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_17.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_17.setAutoDraw(True)\u000a        elif BotLowerLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_17.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_17* updates\u000a        if t >= 0 and TrialCrossHair_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_17.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_17.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_17.setAutoDraw(True)\u000a        elif TrialCrossHair_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_17.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_17* updates\u000a        if t >= 0.0 and RestCrossHair_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_17.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_17.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_17.setAutoDraw(True)\u000a        elif RestCrossHair_17.status == STARTED and t >= (0.0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_17.setAutoDraw(False)\u000a        \u000a        # *UpBrack2* updates\u000a        if t >= 18 and UpBrack2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack2.tStart = t  # underestimates by a little under one frame\u000a            UpBrack2.frameNStart = frameN  # exact frame index\u000a            UpBrack2.setAutoDraw(True)\u000a        elif UpBrack2.status == STARTED and t >= (18 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack2.setAutoDraw(False)\u000a        \u000a        # *UpBrack3* updates\u000a        if t >= 20 and UpBrack3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack3.tStart = t  # underestimates by a little under one frame\u000a            UpBrack3.frameNStart = frameN  # exact frame index\u000a            UpBrack3.setAutoDraw(True)\u000a        elif UpBrack3.status == STARTED and t >= (20 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack3.setAutoDraw(False)\u000a        \u000a        # *UpBrack4* updates\u000a        if t >= 22 and UpBrack4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack4.tStart = t  # underestimates by a little under one frame\u000a            UpBrack4.frameNStart = frameN  # exact frame index\u000a            UpBrack4.setAutoDraw(True)\u000a        elif UpBrack4.status == STARTED and t >= (22 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack4.setAutoDraw(False)\u000a        \u000a        # *UpBrack5* updates\u000a        if t >= 24 and UpBrack5.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack5.tStart = t  # underestimates by a little under one frame\u000a            UpBrack5.frameNStart = frameN  # exact frame index\u000a            UpBrack5.setAutoDraw(True)\u000a        elif UpBrack5.status == STARTED and t >= (24 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack5.setAutoDraw(False)\u000a        \u000a        # *UpBrack6* updates\u000a        if t >= 26 and UpBrack6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack6.tStart = t  # underestimates by a little under one frame\u000a            UpBrack6.frameNStart = frameN  # exact frame index\u000a            UpBrack6.setAutoDraw(True)\u000a        elif UpBrack6.status == STARTED and t >= (26 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack6.setAutoDraw(False)\u000a        \u000a        # *text_38* updates\u000a        if t >= 15 and text_38.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_38.tStart = t  # underestimates by a little under one frame\u000a            text_38.frameNStart = frameN  # exact frame index\u000a            text_38.setAutoDraw(True)\u000a        elif text_38.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_38.setAutoDraw(False)\u000a        \u000a        # *text_39* updates\u000a        if t >= 18 and text_39.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_39.tStart = t  # underestimates by a little under one frame\u000a            text_39.frameNStart = frameN  # exact frame index\u000a            text_39.setAutoDraw(True)\u000a        elif text_39.status == STARTED and t >= (18 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_39.setAutoDraw(False)\u000a        \u000a        # *text_40* updates\u000a        if t >= 20 and text_40.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_40.tStart = t  # underestimates by a little under one frame\u000a            text_40.frameNStart = frameN  # exact frame index\u000a            text_40.setAutoDraw(True)\u000a        elif text_40.status == STARTED and t >= (20 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_40.setAutoDraw(False)\u000a        \u000a        # *text_41* updates\u000a        if t >= 22 and text_41.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_41.tStart = t  # underestimates by a little under one frame\u000a            text_41.frameNStart = frameN  # exact frame index\u000a            text_41.setAutoDraw(True)\u000a        elif text_41.status == STARTED and t >= (22 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_41.setAutoDraw(False)\u000a        \u000a        # *text_42* updates\u000a        if t >= 24 and text_42.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_42.tStart = t  # underestimates by a little under one frame\u000a            text_42.frameNStart = frameN  # exact frame index\u000a            text_42.setAutoDraw(True)\u000a        elif text_42.status == STARTED and t >= (24 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_42.setAutoDraw(False)\u000a        \u000a        # *text_43* updates\u000a        if t >= 26 and text_43.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_43.tStart = t  # underestimates by a little under one frame\u000a            text_43.frameNStart = frameN  # exact frame index\u000a            text_43.setAutoDraw(True)\u000a        elif text_43.status == STARTED and t >= (26 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_43.setAutoDraw(False)\u000a        # *ISI_17* period\u000a        if t >= 0.0 and ISI_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_17.tStart = t  # underestimates by a little under one frame\u000a            ISI_17.frameNStart = frameN  # exact frame index\u000a            ISI_17.start(1)\u000a        elif ISI_17.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_17.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in NumLettersToRemComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "NumLettersToRem"-------\u000a    for thisComponent in NumLettersToRemComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "TrialParts_1"-------\u000a    t = 0\u000a    TrialParts_1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(25.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_16.setText('')\u000a    UpperBrackets_16.setText('')\u000a    LowerText_16.setText('')\u000a    # keep track of which components have finished\u000a    TrialParts_1Components = []\u000a    TrialParts_1Components.append(text_27)\u000a    TrialParts_1Components.append(text_30)\u000a    TrialParts_1Components.append(text_31)\u000a    TrialParts_1Components.append(text_32)\u000a    TrialParts_1Components.append(ISI_16)\u000a    TrialParts_1Components.append(TopUpperLine_16)\u000a    TrialParts_1Components.append(UpperText_16)\u000a    TrialParts_1Components.append(UpperBrackets_16)\u000a    TrialParts_1Components.append(BotUpperLine_16)\u000a    TrialParts_1Components.append(TopLowerLine_16)\u000a    TrialParts_1Components.append(LowerText_16)\u000a    TrialParts_1Components.append(LowerBrackets_16)\u000a    TrialParts_1Components.append(BotLowerLine_16)\u000a    TrialParts_1Components.append(TrialCrossHair_16)\u000a    TrialParts_1Components.append(RestCrossHair_16)\u000a    TrialParts_1Components.append(text_36)\u000a    TrialParts_1Components.append(text_37)\u000a    TrialParts_1Components.append(text_50)\u000a    for thisComponent in TrialParts_1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialParts_1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialParts_1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_27* updates\u000a        if t >= 0.0 and text_27.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_27.tStart = t  # underestimates by a little under one frame\u000a            text_27.frameNStart = frameN  # exact frame index\u000a            text_27.setAutoDraw(True)\u000a        elif text_27.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_27.setAutoDraw(False)\u000a        \u000a        # *text_30* updates\u000a        if t >= 3 and text_30.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_30.tStart = t  # underestimates by a little under one frame\u000a            text_30.frameNStart = frameN  # exact frame index\u000a            text_30.setAutoDraw(True)\u000a        elif text_30.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_30.setAutoDraw(False)\u000a        \u000a        # *text_31* updates\u000a        if t >= 6 and text_31.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_31.tStart = t  # underestimates by a little under one frame\u000a            text_31.frameNStart = frameN  # exact frame index\u000a            text_31.setAutoDraw(True)\u000a        elif text_31.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_31.setAutoDraw(False)\u000a        \u000a        # *text_32* updates\u000a        if t >= 9 and text_32.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_32.tStart = t  # underestimates by a little under one frame\u000a            text_32.frameNStart = frameN  # exact frame index\u000a            text_32.setAutoDraw(True)\u000a        elif text_32.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_32.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_16* updates\u000a        if t >= 0 and TopUpperLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_16.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_16.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_16.setAutoDraw(True)\u000a        elif TopUpperLine_16.status == STARTED and t >= (0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_16.setAutoDraw(False)\u000a        \u000a        # *UpperText_16* updates\u000a        if t >= 0 and UpperText_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_16.tStart = t  # underestimates by a little under one frame\u000a            UpperText_16.frameNStart = frameN  # exact frame index\u000a            UpperText_16.setAutoDraw(True)\u000a        elif UpperText_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_16.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_16* updates\u000a        if t >= 0 and UpperBrackets_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_16.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_16.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_16.setAutoDraw(True)\u000a        elif UpperBrackets_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_16.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_16* updates\u000a        if t >= 0.0 and BotUpperLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_16.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_16.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_16.setAutoDraw(True)\u000a        elif BotUpperLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_16.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_16* updates\u000a        if t >= 0.0 and TopLowerLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_16.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_16.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_16.setAutoDraw(True)\u000a        elif TopLowerLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_16.setAutoDraw(False)\u000a        \u000a        # *LowerText_16* updates\u000a        if t >= 0 and LowerText_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_16.tStart = t  # underestimates by a little under one frame\u000a            LowerText_16.frameNStart = frameN  # exact frame index\u000a            LowerText_16.setAutoDraw(True)\u000a        elif LowerText_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_16.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_16* updates\u000a        if t >= 0 and LowerBrackets_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_16.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_16.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_16.setAutoDraw(True)\u000a        elif LowerBrackets_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_16.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_16* updates\u000a        if t >= 0.0 and BotLowerLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_16.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_16.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_16.setAutoDraw(True)\u000a        elif BotLowerLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_16.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_16* updates\u000a        if t >= 0 and TrialCrossHair_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_16.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_16.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_16.setAutoDraw(True)\u000a        elif TrialCrossHair_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_16.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_16* updates\u000a        if t >= 0 and RestCrossHair_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_16.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_16.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_16.setAutoDraw(True)\u000a        elif RestCrossHair_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_16.setAutoDraw(False)\u000a        \u000a        # *text_36* updates\u000a        if t >= 12 and text_36.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_36.tStart = t  # underestimates by a little under one frame\u000a            text_36.frameNStart = frameN  # exact frame index\u000a            text_36.setAutoDraw(True)\u000a        elif text_36.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_36.setAutoDraw(False)\u000a        \u000a        # *text_37* updates\u000a        if t >= 15 and text_37.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_37.tStart = t  # underestimates by a little under one frame\u000a            text_37.frameNStart = frameN  # exact frame index\u000a            text_37.setAutoDraw(True)\u000a        elif text_37.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_37.setAutoDraw(False)\u000a        \u000a        # *text_50* updates\u000a        if t >= 20 and text_50.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_50.tStart = t  # underestimates by a little under one frame\u000a            text_50.frameNStart = frameN  # exact frame index\u000a            text_50.setAutoDraw(True)\u000a        elif text_50.status == STARTED and t >= (20 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_50.setAutoDraw(False)\u000a        # *ISI_16* period\u000a        if t >= 0.0 and ISI_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_16.tStart = t  # underestimates by a little under one frame\u000a            ISI_16.frameNStart = frameN  # exact frame index\u000a            ISI_16.start(1)\u000a        elif ISI_16.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_16.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialParts_1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialParts_1"-------\u000a    for thisComponent in TrialParts_1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "trial5_2"-------\u000a    t = 0\u000a    trial5_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    UpperText.setText(u' L K R G M X ')\u000a    UpperBrackets.setText(u'  {         }')\u000a    LowerText.setText(u' b t y g q j ')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trial5_2Components = []\u000a    trial5_2Components.append(ISI)\u000a    trial5_2Components.append(TopUpperLine)\u000a    trial5_2Components.append(UpperText)\u000a    trial5_2Components.append(UpperBrackets)\u000a    trial5_2Components.append(BotUpperLine)\u000a    trial5_2Components.append(TopLowerLine)\u000a    trial5_2Components.append(LowerText)\u000a    trial5_2Components.append(LowerBrackets)\u000a    trial5_2Components.append(BotLowerLine)\u000a    trial5_2Components.append(TrialCrossHair)\u000a    trial5_2Components.append(RestCrossHair)\u000a    trial5_2Components.append(resp)\u000a    for thisComponent in trial5_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "trial5_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial5_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *TopUpperLine* updates\u000a        if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine.frameNStart = frameN  # exact frame index\u000a            TopUpperLine.setAutoDraw(True)\u000a        elif TopUpperLine.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine.setAutoDraw(False)\u000a        \u000a        # *UpperText* updates\u000a        if t >= 0 and UpperText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText.tStart = t  # underestimates by a little under one frame\u000a            UpperText.frameNStart = frameN  # exact frame index\u000a            UpperText.setAutoDraw(True)\u000a        elif UpperText.status == STARTED and t >= (0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets* updates\u000a        if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets.frameNStart = frameN  # exact frame index\u000a            UpperBrackets.setAutoDraw(True)\u000a        elif UpperBrackets.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine* updates\u000a        if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine.frameNStart = frameN  # exact frame index\u000a            BotUpperLine.setAutoDraw(True)\u000a        elif BotUpperLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine* updates\u000a        if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine.frameNStart = frameN  # exact frame index\u000a            TopLowerLine.setAutoDraw(True)\u000a        elif TopLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine.setAutoDraw(False)\u000a        \u000a        # *LowerText* updates\u000a        if t >= 7 and LowerText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText.tStart = t  # underestimates by a little under one frame\u000a            LowerText.frameNStart = frameN  # exact frame index\u000a            LowerText.setAutoDraw(True)\u000a        elif LowerText.status == STARTED and t >= (7 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets* updates\u000a        if t >= 7 and LowerBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets.frameNStart = frameN  # exact frame index\u000a            LowerBrackets.setAutoDraw(True)\u000a        elif LowerBrackets.status == STARTED and t >= (7 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine* updates\u000a        if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine.frameNStart = frameN  # exact frame index\u000a            BotLowerLine.setAutoDraw(True)\u000a        elif BotLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair* updates\u000a        if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair.setAutoDraw(True)\u000a        elif TrialCrossHair.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair* updates\u000a        if t >= 9 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (9 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # *resp* updates\u000a        if t >= 7 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif resp.status == STARTED and t >= (7 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(u'6')) or (resp.keys == u'6'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(1)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial5_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "trial5_2"-------\u000a    for thisComponent in trial5_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(u'6').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('resp.keys',resp.keys)\u000a    thisExp.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        thisExp.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "TrialFeedBack"-------\u000a    t = 0\u000a    TrialFeedBackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.000000)\u000a    # update component parameters for each repeat\u000a    if ((resp.corr) & (resp.rt < 2.0)):#stored on last run routine\u000a      msg="Correct and on time! RT=%.3f" %(resp.rt)\u000a    elif ((resp.corr) & (resp.rt > 2.0)):#stored on last run routine\u000a      msg="Correct, but too slow!\u005cn RT=%.3f\u005cnResponse time should be less than two seconds." %(resp.rt)\u000a    else:\u000a      if resp.rt < 2.0:\u000a        msg="Oops! That was incorrect, but on time!"\u000a      else: \u000a        msg="Oops! That was incorrect and too slow!"\u000a    text_47.setText(msg)\u000a    # keep track of which components have finished\u000a    TrialFeedBackComponents = []\u000a    TrialFeedBackComponents.append(text_47)\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialFeedBack"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialFeedBackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text_47* updates\u000a        if t >= 0.0 and text_47.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_47.tStart = t  # underestimates by a little under one frame\u000a            text_47.frameNStart = frameN  # exact frame index\u000a            text_47.setAutoDraw(True)\u000a        elif text_47.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_47.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialFeedBackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialFeedBack"-------\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    msg='Ended'\u000a    win.close()\u000a#    win.close()\u000a\u000adef Test(subid,visitid):\u000a    expInfo = {u'Visit ID': u'9999', u'Participant ID': u'1'}\u000a    print 'subid is %s'%(subid)\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a    else:\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid    \u000a    # Store info about the experiment session\u000a\u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'],expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=False,\u000a        dataFileName=filename)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=ScreenToUse, color=[-1,-1,-1], colorSpace='rgb',\u000a        blendMode='average', useFBO=True,\u000a        units='cm')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial_2"\u000a    trial_2Clock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text='      { }    ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Initialize components for Routine "TrialFeedBack"\u000a    TrialFeedBackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    text = visual.TextStim(win=win, ori=0, name='text',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    #------Prepare to start Routine "trial_2"-------\u000a    t = 0\u000a    trial_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    UpperText.setText(' A B C D E F ')\u000a    UpperBrackets.setText('  {         }')\u000a    LowerText.setText(' a b c d e f ')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trial_2Components = []\u000a    trial_2Components.append(ISI)\u000a    trial_2Components.append(TopUpperLine)\u000a    trial_2Components.append(UpperText)\u000a    trial_2Components.append(UpperBrackets)\u000a    trial_2Components.append(BotUpperLine)\u000a    trial_2Components.append(TopLowerLine)\u000a    trial_2Components.append(LowerText)\u000a    trial_2Components.append(LowerBrackets)\u000a    trial_2Components.append(BotLowerLine)\u000a    trial_2Components.append(TrialCrossHair)\u000a    trial_2Components.append(RestCrossHair)\u000a    trial_2Components.append(resp)\u000a    for thisComponent in trial_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "trial_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *TopUpperLine* updates\u000a        if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine.frameNStart = frameN  # exact frame index\u000a            TopUpperLine.setAutoDraw(True)\u000a        elif TopUpperLine.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine.setAutoDraw(False)\u000a        \u000a        # *UpperText* updates\u000a        if t >= 0 and UpperText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText.tStart = t  # underestimates by a little under one frame\u000a            UpperText.frameNStart = frameN  # exact frame index\u000a            UpperText.setAutoDraw(True)\u000a        elif UpperText.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets* updates\u000a        if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets.frameNStart = frameN  # exact frame index\u000a            UpperBrackets.setAutoDraw(True)\u000a        elif UpperBrackets.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine* updates\u000a        if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine.frameNStart = frameN  # exact frame index\u000a            BotUpperLine.setAutoDraw(True)\u000a        elif BotUpperLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine* updates\u000a        if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine.frameNStart = frameN  # exact frame index\u000a            TopLowerLine.setAutoDraw(True)\u000a        elif TopLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine.setAutoDraw(False)\u000a        \u000a        # *LowerText* updates\u000a        if t >= 7 and LowerText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText.tStart = t  # underestimates by a little under one frame\u000a            LowerText.frameNStart = frameN  # exact frame index\u000a            LowerText.setAutoDraw(True)\u000a        elif LowerText.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets* updates\u000a        if t >= 7 and LowerBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets.frameNStart = frameN  # exact frame index\u000a            LowerBrackets.setAutoDraw(True)\u000a        elif LowerBrackets.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine* updates\u000a        if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine.frameNStart = frameN  # exact frame index\u000a            BotLowerLine.setAutoDraw(True)\u000a        elif BotLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair* updates\u000a        if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair.setAutoDraw(True)\u000a        elif TrialCrossHair.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair* updates\u000a        if t >= 9 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (9 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # *resp* updates\u000a        if t >= 7 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif resp.status == STARTED and t >= (7 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(u'6')) or (resp.keys == u'6'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(1)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "trial_2"-------\u000a    for thisComponent in trial_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(u'6').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('resp.keys',resp.keys)\u000a    thisExp.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        thisExp.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "TrialFeedBack"-------\u000a    t = 0\u000a    TrialFeedBackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.000000)\u000a    # update component parameters for each repeat\u000a    if ((resp.corr) & (resp.rt < 2.0)):#stored on last run routine\u000a      msg="Correct and on time! RT=%.3f" %(resp.rt)\u000a    elif ((resp.corr) & (resp.rt > 2.0)):#stored on last run routine\u000a      msg="Correct, but too slow!\u005cn RT=%.3f\u005cnResponse time should be less than two seconds." %(resp.rt)\u000a    else:\u000a      if resp.rt < 2.0:\u000a        msg="Oops! That was incorrect, but on time!"\u000a      else: \u000a        msg="Oops! That was incorrect and too slow!"\u000a    text.setText(msg)\u000a    # keep track of which components have finished\u000a    TrialFeedBackComponents = []\u000a    TrialFeedBackComponents.append(text)\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialFeedBack"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialFeedBackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        elif text.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialFeedBackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialFeedBack"-------\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    msg='Ended'\u000a\u000a    win.close()\u000a\u000a
p1587
sS'thisTrial'
p1588
(lp1589
sS'_exp'
p1590
I149533712
sg10
S'trials'
p1591
sg6
S'PartialTrialFunction.py'
p1592
sS'thisRepN'
p1593
I1
sg20
I01
sg21
g22
sS'data'
p1594
g1
(cpsychopy.data
DataHandler
p1595
c__builtin__
dict
p1596
(dp1597
g18
cnumpy.ma.core
_mareconstruct
p1598
(cnumpy.ma.core
MaskedArray
p1599
cnumpy
ndarray
p1600
(I0
tp1601
S'b'
tRp1602
(I1
(I72
I1
tg30
(S'f4'
I0
I1
tRp1603
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
cnumpy.core.multiarray
_reconstruct
p1604
(g1600
(I0
tS'b'
tRp1605
(I1
(I72
I1
tg30
(S'O4'
I0
I1
tRp1606
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp1607
g71
aS'--'
p1608
aS'--'
p1609
ag132
aS'--'
p1610
ag173
aS'--'
p1611
aS'--'
p1612
ag234
aS'--'
p1613
aS'--'
p1614
ag294
ag316
ag338
ag360
ag382
ag404
ag426
ag448
ag470
ag492
aS'--'
p1615
ag533
ag555
aS'--'
p1616
aS'--'
p1617
aS'--'
p1618
ag634
ag656
ag678
ag700
ag722
ag744
ag766
aS'--'
p1619
aS'--'
p1620
aS'--'
p1621
ag845
aS'--'
p1622
ag886
aS'--'
p1623
aS'--'
p1624
ag946
ag968
aS'--'
p1625
ag1009
aS'--'
p1626
aS'--'
p1627
aS'--'
p1628
ag1088
ag1110
ag1132
aS'--'
p1629
ag1173
ag1195
aS'--'
p1630
aS'--'
p1631
ag1255
ag1277
ag1299
aS'--'
p1632
ag1340
ag1362
ag1384
ag1406
ag1428
ag1450
ag1472
ag1494
ag1516
aS'--'
p1633
ag1558
atbsS'ran'
p1634
g1598
(g1599
g1600
g1601
S'b'
tRp1635
(I1
(I72
I1
tg1603
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
g1604
(g1600
(I0
tS'b'
tRp1636
(I1
(I72
I1
tg1606
I00
(lp1637
g91
aNaNag151
aNag192
aNaNag253
aNaNag313
ag335
ag357
ag379
ag401
ag423
ag445
ag467
ag489
ag511
aNag552
ag574
aNaNaNag653
ag675
ag697
ag719
ag741
ag763
ag785
aNaNaNag864
aNag905
aNaNag965
ag987
aNag1028
aNaNaNag1107
ag1129
ag1151
aNag1192
ag1214
aNaNag1274
ag1296
ag1318
aNag1359
ag1381
ag1403
ag1425
ag1447
ag1469
ag1491
ag1513
ag1535
aNag1577
atbsg16
g1598
(g1599
g1600
g1601
S'b'
tRp1638
(I1
(I72
I1
tg1603
I00
S'\xdei\xadN\xdei\xadN\xdei\xadN\xdei\xadN\xdfi\xadN\xdfi\xadN\xdfi\xadN\xdfi\xadN\xdfi\xadN\xdfi\xadN\xdfi\xadN\xdfi\xadN\xdfi\xadN\xdfi\xadN\xdfi\xadN\xe0i\xadN\xe0i\xadN\xe0i\xadN\xe0i\xadN\xe0i\xadN\xe0i\xadN\xe0i\xadN\xe0i\xadN\xe0i\xadN\xe0i\xadN\xe0i\xadN\xe0i\xadN\xe0i\xadN\xe0i\xadN\xe1i\xadN\xe1i\xadN\xe1i\xadN\xe1i\xadN\xe1i\xadN\xe1i\xadN\xe1i\xadN\xe1i\xadN\xe1i\xadN\xe1i\xadN\xe1i\xadN\xe2i\xadN\xe2i\xadN\xe2i\xadN\xe2i\xadN\xe2i\xadN\xe2i\xadN\xe2i\xadN\xe2i\xadN\xe2i\xadN\xe2i\xadN\xe2i\xadN\xe2i\xadN\xe2i\xadN\xe3i\xadN\xe3i\xadN\xe3i\xadN\xe3i\xadN\xe3i\xadN\xe3i\xadN\xe3i\xadN\xe3i\xadN\xe3i\xadN\xe3i\xadN\xe3i\xadN\xe4i\xadN\xe4i\xadN\xe4i\xadN\xe4i\xadN\xe4i\xadN\xe4i\xadN\xe4i\xadN\xe4i\xadN'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p1639
g1598
(g1599
g1600
g1601
S'b'
tRp1640
(I1
(I72
I1
tg1603
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB\x00\x00 B\x00\x00$B\x00\x00(B\x00\x00,B\x00\x000B\x00\x004B\x00\x008B\x00\x00<B\x00\x00@B\x00\x00DB\x00\x00HB\x00\x00LB\x00\x00PB\x00\x00TB\x00\x00XB\x00\x00\\B\x00\x00`B\x00\x00dB\x00\x00hB\x00\x00lB\x00\x00pB\x00\x00tB\x00\x00xB\x00\x00|B\x00\x00\x80B\x00\x00\x82B\x00\x00\x84B\x00\x00\x86B\x00\x00\x88B\x00\x00\x8aB\x00\x00\x8cB\x00\x00\x8eB'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1641
(dp1642
S'isNumeric'
p1643
(dp1644
g18
I01
sg1634
I01
sg16
I01
sg19
I00
sg17
I00
sg1639
I01
ssg1591
g1584
sS'dataTypes'
p1645
(lp1646
g1634
ag1639
ag16
ag17
ag18
ag19
asS'dataShape'
p1647
(lp1648
I72
aI1
asbsS'method'
p1649
Vsequential
p1650
sS'sequenceIndices'
p1651
g1604
(g1600
(I0
tS'b'
tRp1652
(I1
(I72
I1
tg84
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00(\x00\x00\x00)\x00\x00\x00*\x00\x00\x00+\x00\x00\x00,\x00\x00\x00-\x00\x00\x00.\x00\x00\x00/\x00\x00\x000\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x004\x00\x00\x005\x00\x00\x006\x00\x00\x007\x00\x00\x008\x00\x00\x009\x00\x00\x00:\x00\x00\x00;\x00\x00\x00<\x00\x00\x00=\x00\x00\x00>\x00\x00\x00?\x00\x00\x00@\x00\x00\x00A\x00\x00\x00B\x00\x00\x00C\x00\x00\x00D\x00\x00\x00E\x00\x00\x00F\x00\x00\x00G\x00\x00\x00'
tbsS'finished'
p1653
I01
sS'nReps'
p1654
I1
sS'nRemaining'
p1655
I-1
sS'trialList'
p1656
(lp1657
g1
(cpsychopy.data
TrialType
p1658
g1596
(dp1659
g41
g82
sg42
g76
sg43
g86
sg44
g77
sg45
g78
sg46
g74
sg47
g79
sg48
g70
sg49
g88
sg50
g80
sg51
g72
sg52
g81
sg53
g90
sg54
g73
stRp1660
ag1
(g1658
g1596
(dp1661
g41
g101
sg42
g93
sg43
g104
sg44
g94
sg45
g95
sg46
g106
sg47
g96
sg48
g97
sg49
g108
sg50
g98
sg51
g99
sg52
V 
sg53
g110
sg54
g100
stRp1662
ag1
(g1658
g1596
(dp1663
g41
g120
sg42
g112
sg43
g123
sg44
g113
sg45
g114
sg46
g125
sg47
g115
sg48
g116
sg49
g127
sg50
g117
sg51
g118
sg52
V 
sg53
g129
sg54
g119
stRp1664
ag1
(g1658
g1596
(dp1665
g41
g143
sg42
g137
sg43
g146
sg44
g138
sg45
g139
sg46
g135
sg47
g140
sg48
g131
sg49
g148
sg50
g141
sg51
g133
sg52
g142
sg53
g150
sg54
g134
stRp1666
ag1
(g1658
g1596
(dp1667
g41
g161
sg42
g153
sg43
g164
sg44
g154
sg45
g155
sg46
g166
sg47
g156
sg48
g157
sg49
g168
sg50
g158
sg51
g159
sg52
V 
sg53
g170
sg54
g160
stRp1668
ag1
(g1658
g1596
(dp1669
g41
g184
sg42
g178
sg43
g187
sg44
g179
sg45
g180
sg46
g176
sg47
g181
sg48
g172
sg49
g189
sg50
g182
sg51
g174
sg52
g183
sg53
g191
sg54
g175
stRp1670
ag1
(g1658
g1596
(dp1671
g41
g203
sg42
g194
sg43
g206
sg44
g195
sg45
g196
sg46
g208
sg47
g197
sg48
g198
sg49
g210
sg50
g199
sg51
g200
sg52
g201
sg53
g212
sg54
g202
stRp1672
ag1
(g1658
g1596
(dp1673
g41
g222
sg42
g214
sg43
g225
sg44
g215
sg45
g216
sg46
g227
sg47
g217
sg48
g218
sg49
g229
sg50
g219
sg51
g220
sg52
V 
sg53
g231
sg54
g221
stRp1674
ag1
(g1658
g1596
(dp1675
g41
g245
sg42
g239
sg43
g248
sg44
g240
sg45
g241
sg46
g237
sg47
g242
sg48
g233
sg49
g250
sg50
g243
sg51
g235
sg52
g244
sg53
g252
sg54
g236
stRp1676
ag1
(g1658
g1596
(dp1677
g41
g263
sg42
g255
sg43
g266
sg44
g256
sg45
g257
sg46
g268
sg47
g258
sg48
g259
sg49
g270
sg50
g260
sg51
g261
sg52
V 
sg53
g272
sg54
g262
stRp1678
ag1
(g1658
g1596
(dp1679
g41
g282
sg42
g274
sg43
g285
sg44
g275
sg45
g276
sg46
g287
sg47
g277
sg48
g278
sg49
g289
sg50
g279
sg51
g280
sg52
V 
sg53
g291
sg54
g281
stRp1680
ag1
(g1658
g1596
(dp1681
g41
g305
sg42
g299
sg43
g308
sg44
g300
sg45
g301
sg46
g297
sg47
g302
sg48
g293
sg49
g310
sg50
g303
sg51
g295
sg52
g304
sg53
g312
sg54
g296
stRp1682
ag1
(g1658
g1596
(dp1683
g41
g327
sg42
g321
sg43
g330
sg44
g322
sg45
g323
sg46
g319
sg47
g324
sg48
g315
sg49
g332
sg50
g325
sg51
g317
sg52
g326
sg53
g334
sg54
g318
stRp1684
ag1
(g1658
g1596
(dp1685
g41
g349
sg42
g343
sg43
g352
sg44
g344
sg45
g345
sg46
g341
sg47
g346
sg48
g337
sg49
g354
sg50
g347
sg51
g339
sg52
g348
sg53
g356
sg54
g340
stRp1686
ag1
(g1658
g1596
(dp1687
g41
g371
sg42
g365
sg43
g374
sg44
g366
sg45
g367
sg46
g363
sg47
g368
sg48
g359
sg49
g376
sg50
g369
sg51
g361
sg52
g370
sg53
g378
sg54
g362
stRp1688
ag1
(g1658
g1596
(dp1689
g41
g393
sg42
g387
sg43
g396
sg44
g388
sg45
g389
sg46
g385
sg47
g390
sg48
g381
sg49
g398
sg50
g391
sg51
g383
sg52
g392
sg53
g400
sg54
g384
stRp1690
ag1
(g1658
g1596
(dp1691
g41
g415
sg42
g409
sg43
g418
sg44
g410
sg45
g411
sg46
g407
sg47
g412
sg48
g403
sg49
g420
sg50
g413
sg51
g405
sg52
g414
sg53
g422
sg54
g406
stRp1692
ag1
(g1658
g1596
(dp1693
g41
g437
sg42
g431
sg43
g440
sg44
g432
sg45
g433
sg46
g429
sg47
g434
sg48
g425
sg49
g442
sg50
g435
sg51
g427
sg52
g436
sg53
g444
sg54
g428
stRp1694
ag1
(g1658
g1596
(dp1695
g41
g459
sg42
g453
sg43
g462
sg44
g454
sg45
g455
sg46
g451
sg47
g456
sg48
g447
sg49
g464
sg50
g457
sg51
g449
sg52
g458
sg53
g466
sg54
g450
stRp1696
ag1
(g1658
g1596
(dp1697
g41
g481
sg42
g475
sg43
g484
sg44
g476
sg45
g477
sg46
g473
sg47
g478
sg48
g469
sg49
g486
sg50
g479
sg51
g471
sg52
g480
sg53
g488
sg54
g472
stRp1698
ag1
(g1658
g1596
(dp1699
g41
g503
sg42
g497
sg43
g506
sg44
g498
sg45
g499
sg46
g495
sg47
g500
sg48
g491
sg49
g508
sg50
g501
sg51
g493
sg52
g502
sg53
g510
sg54
g494
stRp1700
ag1
(g1658
g1596
(dp1701
g41
g521
sg42
g513
sg43
g524
sg44
g514
sg45
g515
sg46
g526
sg47
g516
sg48
g517
sg49
g528
sg50
g518
sg51
g519
sg52
V 
sg53
g530
sg54
g520
stRp1702
ag1
(g1658
g1596
(dp1703
g41
g544
sg42
g538
sg43
g547
sg44
g539
sg45
g540
sg46
g536
sg47
g541
sg48
g532
sg49
g549
sg50
g542
sg51
g534
sg52
g543
sg53
g551
sg54
g535
stRp1704
ag1
(g1658
g1596
(dp1705
g41
g566
sg42
g560
sg43
g569
sg44
g561
sg45
g562
sg46
g558
sg47
g563
sg48
g554
sg49
g571
sg50
g564
sg51
g556
sg52
g565
sg53
g573
sg54
g557
stRp1706
ag1
(g1658
g1596
(dp1707
g41
g584
sg42
g576
sg43
g587
sg44
g577
sg45
g578
sg46
g589
sg47
g579
sg48
g580
sg49
g591
sg50
g581
sg51
g582
sg52
V 
sg53
g593
sg54
g583
stRp1708
ag1
(g1658
g1596
(dp1709
g41
g603
sg42
g595
sg43
g606
sg44
g596
sg45
g597
sg46
g608
sg47
g598
sg48
g599
sg49
g610
sg50
g600
sg51
g601
sg52
V 
sg53
g612
sg54
g602
stRp1710
ag1
(g1658
g1596
(dp1711
g41
g622
sg42
g614
sg43
g625
sg44
g615
sg45
g616
sg46
g627
sg47
g617
sg48
g618
sg49
g629
sg50
g619
sg51
g620
sg52
V 
sg53
g631
sg54
g621
stRp1712
ag1
(g1658
g1596
(dp1713
g41
g645
sg42
g639
sg43
g648
sg44
g640
sg45
g641
sg46
g637
sg47
g642
sg48
g633
sg49
g650
sg50
g643
sg51
g635
sg52
g644
sg53
g652
sg54
g636
stRp1714
ag1
(g1658
g1596
(dp1715
g41
g667
sg42
g661
sg43
g670
sg44
g662
sg45
g663
sg46
g659
sg47
g664
sg48
g655
sg49
g672
sg50
g665
sg51
g657
sg52
g666
sg53
g674
sg54
g658
stRp1716
ag1
(g1658
g1596
(dp1717
g41
g689
sg42
g683
sg43
g692
sg44
g684
sg45
g685
sg46
g681
sg47
g686
sg48
g677
sg49
g694
sg50
g687
sg51
g679
sg52
g688
sg53
g696
sg54
g680
stRp1718
ag1
(g1658
g1596
(dp1719
g41
g711
sg42
g705
sg43
g714
sg44
g706
sg45
g707
sg46
g703
sg47
g708
sg48
g699
sg49
g716
sg50
g709
sg51
g701
sg52
g710
sg53
g718
sg54
g702
stRp1720
ag1
(g1658
g1596
(dp1721
g41
g733
sg42
g727
sg43
g736
sg44
g728
sg45
g729
sg46
g725
sg47
g730
sg48
g721
sg49
g738
sg50
g731
sg51
g723
sg52
g732
sg53
g740
sg54
g724
stRp1722
ag1
(g1658
g1596
(dp1723
g41
g755
sg42
g749
sg43
g758
sg44
g750
sg45
g751
sg46
g747
sg47
g752
sg48
g743
sg49
g760
sg50
g753
sg51
g745
sg52
g754
sg53
g762
sg54
g746
stRp1724
ag1
(g1658
g1596
(dp1725
g41
g777
sg42
g771
sg43
g780
sg44
g772
sg45
g773
sg46
g769
sg47
g774
sg48
g765
sg49
g782
sg50
g775
sg51
g767
sg52
g776
sg53
g784
sg54
g768
stRp1726
ag1
(g1658
g1596
(dp1727
g41
g795
sg42
g787
sg43
g798
sg44
g788
sg45
g789
sg46
g800
sg47
g790
sg48
g791
sg49
g802
sg50
g792
sg51
g793
sg52
V 
sg53
g804
sg54
g794
stRp1728
ag1
(g1658
g1596
(dp1729
g41
g814
sg42
g806
sg43
g817
sg44
g807
sg45
g808
sg46
g819
sg47
g809
sg48
g810
sg49
g821
sg50
g811
sg51
g812
sg52
V 
sg53
g823
sg54
g813
stRp1730
ag1
(g1658
g1596
(dp1731
g41
g833
sg42
g825
sg43
g836
sg44
g826
sg45
g827
sg46
g838
sg47
g828
sg48
g829
sg49
g840
sg50
g830
sg51
g831
sg52
V 
sg53
g842
sg54
g832
stRp1732
ag1
(g1658
g1596
(dp1733
g41
g856
sg42
g850
sg43
g859
sg44
g851
sg45
g852
sg46
g848
sg47
g853
sg48
g844
sg49
g861
sg50
g854
sg51
g846
sg52
g855
sg53
g863
sg54
g847
stRp1734
ag1
(g1658
g1596
(dp1735
g41
g874
sg42
g866
sg43
g877
sg44
g867
sg45
g868
sg46
g879
sg47
g869
sg48
g870
sg49
g881
sg50
g871
sg51
g872
sg52
V 
sg53
g883
sg54
g873
stRp1736
ag1
(g1658
g1596
(dp1737
g41
g897
sg42
g891
sg43
g900
sg44
g892
sg45
g893
sg46
g889
sg47
g894
sg48
g885
sg49
g902
sg50
g895
sg51
g887
sg52
g896
sg53
g904
sg54
g888
stRp1738
ag1
(g1658
g1596
(dp1739
g41
g915
sg42
g907
sg43
g918
sg44
g908
sg45
g909
sg46
g920
sg47
g910
sg48
g911
sg49
g922
sg50
g912
sg51
g913
sg52
V 
sg53
g924
sg54
g914
stRp1740
ag1
(g1658
g1596
(dp1741
g41
g934
sg42
g926
sg43
g937
sg44
g927
sg45
g928
sg46
g939
sg47
g929
sg48
g930
sg49
g941
sg50
g931
sg51
g932
sg52
V 
sg53
g943
sg54
g933
stRp1742
ag1
(g1658
g1596
(dp1743
g41
g957
sg42
g951
sg43
g960
sg44
g952
sg45
g953
sg46
g949
sg47
g954
sg48
g945
sg49
g962
sg50
g955
sg51
g947
sg52
g956
sg53
g964
sg54
g948
stRp1744
ag1
(g1658
g1596
(dp1745
g41
g979
sg42
g973
sg43
g982
sg44
g974
sg45
g975
sg46
g971
sg47
g976
sg48
g967
sg49
g984
sg50
g977
sg51
g969
sg52
g978
sg53
g986
sg54
g970
stRp1746
ag1
(g1658
g1596
(dp1747
g41
g997
sg42
g989
sg43
g1000
sg44
g990
sg45
g991
sg46
g1002
sg47
g992
sg48
g993
sg49
g1004
sg50
g994
sg51
g995
sg52
V 
sg53
g1006
sg54
g996
stRp1748
ag1
(g1658
g1596
(dp1749
g41
g1020
sg42
g1014
sg43
g1023
sg44
g1015
sg45
g1016
sg46
g1012
sg47
g1017
sg48
g1008
sg49
g1025
sg50
g1018
sg51
g1010
sg52
g1019
sg53
g1027
sg54
g1011
stRp1750
ag1
(g1658
g1596
(dp1751
g41
g1038
sg42
g1030
sg43
g1041
sg44
g1031
sg45
g1032
sg46
g1043
sg47
g1033
sg48
g1034
sg49
g1045
sg50
g1035
sg51
g1036
sg52
V 
sg53
g1047
sg54
g1037
stRp1752
ag1
(g1658
g1596
(dp1753
g41
g1057
sg42
g1049
sg43
g1060
sg44
g1050
sg45
g1051
sg46
g1062
sg47
g1052
sg48
g1053
sg49
g1064
sg50
g1054
sg51
g1055
sg52
V 
sg53
g1066
sg54
g1056
stRp1754
ag1
(g1658
g1596
(dp1755
g41
g1076
sg42
g1068
sg43
g1079
sg44
g1069
sg45
g1070
sg46
g1081
sg47
g1071
sg48
g1072
sg49
g1083
sg50
g1073
sg51
g1074
sg52
V 
sg53
g1085
sg54
g1075
stRp1756
ag1
(g1658
g1596
(dp1757
g41
g1099
sg42
g1093
sg43
g1102
sg44
g1094
sg45
g1095
sg46
g1091
sg47
g1096
sg48
g1087
sg49
g1104
sg50
g1097
sg51
g1089
sg52
g1098
sg53
g1106
sg54
g1090
stRp1758
ag1
(g1658
g1596
(dp1759
g41
g1121
sg42
g1115
sg43
g1124
sg44
g1116
sg45
g1117
sg46
g1113
sg47
g1118
sg48
g1109
sg49
g1126
sg50
g1119
sg51
g1111
sg52
g1120
sg53
g1128
sg54
g1112
stRp1760
ag1
(g1658
g1596
(dp1761
g41
g1143
sg42
g1137
sg43
g1146
sg44
g1138
sg45
g1139
sg46
g1135
sg47
g1140
sg48
g1131
sg49
g1148
sg50
g1141
sg51
g1133
sg52
g1142
sg53
g1150
sg54
g1134
stRp1762
ag1
(g1658
g1596
(dp1763
g41
g1161
sg42
g1153
sg43
g1164
sg44
g1154
sg45
g1155
sg46
g1166
sg47
g1156
sg48
g1157
sg49
g1168
sg50
g1158
sg51
g1159
sg52
V 
sg53
g1170
sg54
g1160
stRp1764
ag1
(g1658
g1596
(dp1765
g41
g1184
sg42
g1178
sg43
g1187
sg44
g1179
sg45
g1180
sg46
g1176
sg47
g1181
sg48
g1172
sg49
g1189
sg50
g1182
sg51
g1174
sg52
g1183
sg53
g1191
sg54
g1175
stRp1766
ag1
(g1658
g1596
(dp1767
g41
g1206
sg42
g1200
sg43
g1209
sg44
g1201
sg45
g1202
sg46
g1198
sg47
g1203
sg48
g1194
sg49
g1211
sg50
g1204
sg51
g1196
sg52
g1205
sg53
g1213
sg54
g1197
stRp1768
ag1
(g1658
g1596
(dp1769
g41
g1224
sg42
g1216
sg43
g1227
sg44
g1217
sg45
g1218
sg46
g1229
sg47
g1219
sg48
g1220
sg49
g1231
sg50
g1221
sg51
g1222
sg52
V 
sg53
g1233
sg54
g1223
stRp1770
ag1
(g1658
g1596
(dp1771
g41
g1243
sg42
g1235
sg43
g1246
sg44
g1236
sg45
g1237
sg46
g1248
sg47
g1238
sg48
g1239
sg49
g1250
sg50
g1240
sg51
g1241
sg52
V 
sg53
g1252
sg54
g1242
stRp1772
ag1
(g1658
g1596
(dp1773
g41
g1266
sg42
g1260
sg43
g1269
sg44
g1261
sg45
g1262
sg46
g1258
sg47
g1263
sg48
g1254
sg49
g1271
sg50
g1264
sg51
g1256
sg52
g1265
sg53
g1273
sg54
g1257
stRp1774
ag1
(g1658
g1596
(dp1775
g41
g1288
sg42
g1282
sg43
g1291
sg44
g1283
sg45
g1284
sg46
g1280
sg47
g1285
sg48
g1276
sg49
g1293
sg50
g1286
sg51
g1278
sg52
g1287
sg53
g1295
sg54
g1279
stRp1776
ag1
(g1658
g1596
(dp1777
g41
g1310
sg42
g1304
sg43
g1313
sg44
g1305
sg45
g1306
sg46
g1302
sg47
g1307
sg48
g1298
sg49
g1315
sg50
g1308
sg51
g1300
sg52
g1309
sg53
g1317
sg54
g1301
stRp1778
ag1
(g1658
g1596
(dp1779
g41
g1328
sg42
g1320
sg43
g1331
sg44
g1321
sg45
g1322
sg46
g1333
sg47
g1323
sg48
g1324
sg49
g1335
sg50
g1325
sg51
g1326
sg52
V 
sg53
g1337
sg54
g1327
stRp1780
ag1
(g1658
g1596
(dp1781
g41
g1351
sg42
g1345
sg43
g1354
sg44
g1346
sg45
g1347
sg46
g1343
sg47
g1348
sg48
g1339
sg49
g1356
sg50
g1349
sg51
g1341
sg52
g1350
sg53
g1358
sg54
g1342
stRp1782
ag1
(g1658
g1596
(dp1783
g41
g1373
sg42
g1367
sg43
g1376
sg44
g1368
sg45
g1369
sg46
g1365
sg47
g1370
sg48
g1361
sg49
g1378
sg50
g1371
sg51
g1363
sg52
g1372
sg53
g1380
sg54
g1364
stRp1784
ag1
(g1658
g1596
(dp1785
g41
g1395
sg42
g1389
sg43
g1398
sg44
g1390
sg45
g1391
sg46
g1387
sg47
g1392
sg48
g1383
sg49
g1400
sg50
g1393
sg51
g1385
sg52
g1394
sg53
g1402
sg54
g1386
stRp1786
ag1
(g1658
g1596
(dp1787
g41
g1417
sg42
g1411
sg43
g1420
sg44
g1412
sg45
g1413
sg46
g1409
sg47
g1414
sg48
g1405
sg49
g1422
sg50
g1415
sg51
g1407
sg52
g1416
sg53
g1424
sg54
g1408
stRp1788
ag1
(g1658
g1596
(dp1789
g41
g1439
sg42
g1433
sg43
g1442
sg44
g1434
sg45
g1435
sg46
g1431
sg47
g1436
sg48
g1427
sg49
g1444
sg50
g1437
sg51
g1429
sg52
g1438
sg53
g1446
sg54
g1430
stRp1790
ag1
(g1658
g1596
(dp1791
g41
g1461
sg42
g1455
sg43
g1464
sg44
g1456
sg45
g1457
sg46
g1453
sg47
g1458
sg48
g1449
sg49
g1466
sg50
g1459
sg51
g1451
sg52
g1460
sg53
g1468
sg54
g1452
stRp1792
ag1
(g1658
g1596
(dp1793
g41
g1483
sg42
g1477
sg43
g1486
sg44
g1478
sg45
g1479
sg46
g1475
sg47
g1480
sg48
g1471
sg49
g1488
sg50
g1481
sg51
g1473
sg52
g1482
sg53
g1490
sg54
g1474
stRp1794
ag1
(g1658
g1596
(dp1795
g41
g1505
sg42
g1499
sg43
g1508
sg44
g1500
sg45
g1501
sg46
g1497
sg47
g1502
sg48
g1493
sg49
g1510
sg50
g1503
sg51
g1495
sg52
g1504
sg53
g1512
sg54
g1496
stRp1796
ag1
(g1658
g1596
(dp1797
g41
g1527
sg42
g1521
sg43
g1530
sg44
g1522
sg45
g1523
sg46
g1519
sg47
g1524
sg48
g1515
sg49
g1532
sg50
g1525
sg51
g1517
sg52
g1526
sg53
g1534
sg54
g1518
stRp1798
ag1
(g1658
g1596
(dp1799
g41
g1546
sg42
g1537
sg43
g1549
sg44
g1538
sg45
g1539
sg46
g1551
sg47
g1540
sg48
g1541
sg49
g1553
sg50
g1542
sg51
g1543
sg52
g1544
sg53
g1555
sg54
g1545
stRp1800
ag1
(g1658
g1596
(dp1801
g41
g1569
sg42
g1563
sg43
g1572
sg44
g1564
sg45
g1565
sg46
g1561
sg47
g1566
sg48
g1557
sg49
g1574
sg50
g1567
sg51
g1559
sg52
g1568
sg53
g1576
sg54
g1560
stRp1802
asS'seed'
p1803
NsS'thisIndex'
p1804
g1571
sS'thisN'
p1805
I72
sS'thisTrialN'
p1806
I0
sS'nTotal'
p1807
I72
sS'_warnUseOfNext'
p1808
I01
sbasS'savePickle'
p1809
I00
sb.