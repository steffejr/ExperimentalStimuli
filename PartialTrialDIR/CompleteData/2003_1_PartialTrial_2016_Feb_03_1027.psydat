ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Users/jason/Dropbox/SteffenerColumbia/Scripts/ExperimentalStimuli/PartialTrialDIR/Scripts/PsychoPyTask/data/2003_1_PartialTrial_2016_Feb_03_1027
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'PartialTrial'
p11
sS'dataNames'
p12
(lp13
S'ScannerTrigger.keys'
p14
aS'ScannerTrigger.rt'
p15
aS'TrialStartTime'
p16
aS'KeyboardResp.keys'
p17
aS'KeyboardResp.corr'
p18
aS'KeyboardResp.rt'
p19
asS'autoLog'
p20
I01
sS'extraInfo'
p21
(dp22
VParticipant ID
p23
S'2003'
p24
sS'date'
p25
V2016_Feb_03_1027
p26
sS'expName'
p27
g11
sVVisit ID
p28
S'1'
sS'frameRate'
p29
cnumpy.core.multiarray
scalar
p30
(cnumpy
dtype
p31
(S'f8'
I0
I1
tRp32
(I3
S'<'
NNNI-1
I-1
I0
tbS'Z\x98Ix\x8f\xfbM@'
tRp33
ssS'loopsUnfinished'
p34
(lp35
sS'saveWideText'
p36
I01
sS'thisEntry'
p37
(dp38
sS'version'
p39
S''
sS'_paramNamesSoFar'
p40
(lp41
S'RetDur'
p42
aS'BotBrack'
p43
aS'StimDur'
p44
aS'UpBrack'
p45
aS'ProbeDurITI'
p46
aS'ProbeDur'
p47
aS'ProbeStart'
p48
aS'TrialDur'
p49
aS'ITI'
p50
aS'StimSet'
p51
aS'RetStart'
p52
aS'ProbeLet'
p53
aS'TrialITIDur'
p54
aS'Correct'
p55
asS'entries'
p56
(lp57
(dp58
g23
g24
sS'trials.thisIndex'
p59
I0
sg27
g11
sg28
S'1'
sS'trials.thisRepN'
p60
I0
sg29
g33
sS'trials.thisN'
p61
I-1
sg15
F95.959900856018066
sS'trials.thisTrialN'
p62
I-1
sg25
g26
sg14
S'r'
sa(dp63
g23
g24
sS'trials.thisIndex'
p64
I0
sg28
S'1'
sS'trials.thisRepN'
p65
I0
sg29
g33
sg16
F1454513361.638644
sS'trials.thisN'
p66
I-1
sg27
g11
sS'trials.thisTrialN'
p67
I-1
sg25
g26
sa(dp68
g23
g24
sg27
g11
sg43
g30
(g31
(S'i8'
I0
I1
tRp69
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp70
sg45
g30
(g69
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp71
sg46
g30
(g32
S'\x7fj\xbct\x93\x18\x10@'
tRp72
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp73
sg49
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp74
sg51
S'QGHFKR'
p75
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp76
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp77
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp78
sS'trials.thisIndex'
p79
g30
(g31
(S'i4'
I0
I1
tRp80
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00'
tRp81
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp82
sS'trials.thisRepN'
p83
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp84
sg16
F1454513371.6416781
sg29
g33
sS'trials.thisN'
p85
I0
sg50
g30
(g32
S'\x7fj\xbct\x93\x18\x10@'
tRp86
sS'trials.thisTrialN'
p87
I0
sg54
g30
(g32
S'@5^\xbaI\x0c&@'
tRp88
sg17
Nsa(dp89
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp90
sg45
g30
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp91
sg46
g30
(g32
S'\x85\xebQ\xb8\x1e\x85\x10@'
tRp92
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp93
sg49
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp94
sg51
S'XDJLTM'
p95
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp96
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp97
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp98
sS'trials.thisIndex'
p99
g30
(g80
S'\x01\x00\x00\x00'
tRp100
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp101
sS'trials.thisRepN'
p102
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp103
sg16
F1454513382.6633799
sg29
g33
sS'trials.thisN'
p104
I1
sg50
g30
(g32
S'\x85\xebQ\xb8\x1e\x85\x10@'
tRp105
sS'trials.thisTrialN'
p106
I1
sg54
g30
(g32
S'\xc3\xf5(\\\x8fB&@'
tRp107
sg17
Nsa(dp108
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp109
sg19
(lp110
F1.2014830112457275
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp111
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp112
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp113
sg16
F1454513393.7834671
sS'trials.thisN'
p114
I2
sg43
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp115
sg45
g30
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp116
sg46
g30
(g32
S'\xda\xce\xf7S\xe3%\x19@'
tRp117
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp118
sg51
S'XYNBRF'
p119
sg25
g26
sg53
S'gkqdtj'
p120
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp121
sS'trials.thisIndex'
p122
g30
(g80
S'\x02\x00\x00\x00'
tRp123
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp124
sS'trials.thisRepN'
p125
I0
sg50
g30
(g32
S'\xd9\xce\xf7S\xe3%\x11@'
tRp126
sg27
g11
sS'trials.thisTrialN'
p127
I2
sg54
g30
(g32
S'm\xe7\xfb\xa9\xf1\x92*@'
tRp128
sg17
(lp129
S'8'
asa(dp130
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp131
sg19
(lp132
F1.7517158985137939
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp133
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp134
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp135
sg16
F1454513407.071615
sS'trials.thisN'
p136
I3
sg43
g30
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp137
sg45
g30
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp138
sg46
g30
(g32
S'\xbct\x93\x18\x04\xd6\x18@'
tRp139
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp140
sg51
S'FKMTQG'
p141
sg25
g26
sg53
S'yhdlwb'
p142
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp143
sS'trials.thisIndex'
p144
g30
(g80
S'\x03\x00\x00\x00'
tRp145
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp146
sS'trials.thisRepN'
p147
I0
sg50
g30
(g32
S'\xbct\x93\x18\x04\xd6\x10@'
tRp148
sg27
g11
sS'trials.thisTrialN'
p149
I3
sg54
g30
(g32
S'_\xbaI\x0c\x02k*@'
tRp150
sg17
(lp151
S'8'
asa(dp152
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp153
sg19
(lp154
F1.3684151172637939
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp155
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp156
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp157
sg16
F1454513420.2756851
sS'trials.thisN'
p158
I4
sg43
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp159
sg45
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp160
sg46
g30
(g32
S'-\xb2\x9d\xef\xa7F\x1a@'
tRp161
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp162
sg51
S'TNJDWB'
p163
sg25
g26
sg53
S'qxhyfl'
p164
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp165
sS'trials.thisIndex'
p166
g30
(g80
S'\x04\x00\x00\x00'
tRp167
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp168
sS'trials.thisRepN'
p169
I0
sg50
g30
(g32
S'-\xb2\x9d\xef\xa7F\x12@'
tRp170
sg27
g11
sS'trials.thisTrialN'
p171
I4
sg54
g30
(g32
S'\x17\xd9\xce\xf7S#+@'
tRp172
sg17
(lp173
S'8'
asa(dp174
g23
g24
sg29
g33
sg49
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp175
sg19
(lp176
F1.0847339630126953
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp177
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp178
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp179
sg16
F1454513433.8481541
sS'trials.thisN'
p180
I5
sg43
g30
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp181
sg45
g30
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp182
sg46
g30
(g32
S'\xaeG\xe1z\x14\xae\x1a@'
tRp183
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp184
sg51
S'LRHKMY'
p185
sg25
g26
sg53
S'qgrnfw'
p186
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp187
sS'trials.thisIndex'
p188
g30
(g80
S'\x05\x00\x00\x00'
tRp189
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp190
sS'trials.thisRepN'
p191
I0
sg50
g30
(g32
S'\xaeG\xe1z\x14\xae\x12@'
tRp192
sg27
g11
sS'trials.thisTrialN'
p193
I5
sg54
g30
(g32
S'\xd7\xa3p=\nW!@'
tRp194
sg17
(lp195
S'7'
asa(dp196
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp197
sg19
(lp198
F0.9168388843536377
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp199
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp200
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp201
sg16
F1454513442.51807
sS'trials.thisN'
p202
I6
sg43
g30
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp203
sg45
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp204
sg46
g30
(g32
S'\xc3\xf5(\\\x8fB\x1a@'
tRp205
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp206
sg51
S'WRBDHN'
p207
sg25
g26
sg53
S'myqxgl'
p208
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp209
sS'trials.thisIndex'
p210
g30
(g80
S'\x06\x00\x00\x00'
tRp211
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp212
sS'trials.thisRepN'
p213
I0
sg50
g30
(g32
S'\xc3\xf5(\\\x8fB\x12@'
tRp214
sg27
g11
sS'trials.thisTrialN'
p215
I6
sg54
g30
(g32
S'\xe1z\x14\xaeG!+@'
tRp216
sg17
(lp217
S'8'
asa(dp218
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp219
sg19
(lp220
F1.0345239639282227
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp221
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp222
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp223
sg16
F1454513456.089164
sS'trials.thisN'
p224
I7
sg43
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp225
sg45
g30
(g69
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp226
sg46
g30
(g32
S'\xa6\x9b\xc4 \xb0r\x18@'
tRp227
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp228
sg51
S'XLTFHQ'
p229
sg25
g26
sg53
S'rgjdbh'
p230
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp231
sS'trials.thisIndex'
p232
g30
(g80
S'\x07\x00\x00\x00'
tRp233
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp234
sS'trials.thisRepN'
p235
I0
sg50
g30
(g32
S'\xa6\x9b\xc4 \xb0r\x10@'
tRp236
sg27
g11
sS'trials.thisTrialN'
p237
I7
sg54
g30
(g32
S'\xd3Mb\x10X9*@'
tRp238
sg17
(lp239
S'8'
asa(dp240
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp241
sg19
(lp242
F1.5018010139465332
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp243
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp244
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp245
sg16
F1454513469.193639
sS'trials.thisN'
p246
I8
sg43
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp247
sg45
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp248
sg46
g30
(g32
S'333333\x18@'
tRp249
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp250
sg51
S'WBFJTY'
p251
sg25
g26
sg53
S'rmhqyd'
p252
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp253
sS'trials.thisIndex'
p254
g30
(g80
S'\x08\x00\x00\x00'
tRp255
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp256
sS'trials.thisRepN'
p257
I0
sg50
g30
(g32
S'333333\x10@'
tRp258
sg27
g11
sS'trials.thisTrialN'
p259
I8
sg54
g30
(g32
S'\x9a\x99\x99\x99\x99\x19*@'
tRp260
sg17
(lp261
S'7'
asa(dp262
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp263
sg45
g30
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp264
sg46
g30
(g32
S'\xd1"\xdb\xf9~j\x10@'
tRp265
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp266
sg49
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp267
sg51
S'JGMQFB'
p268
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp269
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp270
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp271
sS'trials.thisIndex'
p272
g30
(g80
S'\t\x00\x00\x00'
tRp273
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp274
sS'trials.thisRepN'
p275
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp276
sg16
F1454513482.248925
sg29
g33
sS'trials.thisN'
p277
I9
sg50
g30
(g32
S'\xd1"\xdb\xf9~j\x10@'
tRp278
sS'trials.thisTrialN'
p279
I9
sg54
g30
(g32
S'\xd1"\xdb\xf9~j\x18@'
tRp280
sg17
Nsa(dp281
g23
g24
sg29
g33
sg49
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp282
sg19
(lp283
F1.150629997253418
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp284
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp285
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp286
sg16
F1454513488.350899
sS'trials.thisN'
p287
I10
sg43
g30
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp288
sg45
g30
(g69
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp289
sg46
g30
(g32
S'\x00\x00\x00\x00\x00\x80\x18@'
tRp290
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp291
sg51
S'KTMWNL'
p292
sg25
g26
sg53
S'drbgfq'
p293
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp294
sS'trials.thisIndex'
p295
g30
(g80
S'\n\x00\x00\x00'
tRp296
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp297
sS'trials.thisRepN'
p298
I0
sg50
g30
(g32
S'\x00\x00\x00\x00\x00\x80\x10@'
tRp299
sg27
g11
sS'trials.thisTrialN'
p300
I10
sg54
g30
(g32
S'\x00\x00\x00\x00\x00@ @'
tRp301
sg17
(lp302
S'8'
asa(dp303
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp304
sg19
(lp305
F1.68379807472229
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp306
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp307
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp308
sg16
F1454513496.4711881
sS'trials.thisN'
p309
I11
sg43
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp310
sg45
g30
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp311
sg46
g30
(g32
S'\x9a\x99\x99\x99\x99\x19\x18@'
tRp312
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp313
sg51
S'KLQMGW'
p314
sg25
g26
sg53
S'ydjrtb'
p315
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp316
sS'trials.thisIndex'
p317
g30
(g80
S'\x0b\x00\x00\x00'
tRp318
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp319
sS'trials.thisRepN'
p320
I0
sg50
g30
(g32
S'\x9a\x99\x99\x99\x99\x19\x10@'
tRp321
sg27
g11
sS'trials.thisTrialN'
p322
I11
sg54
g30
(g32
S'\xcd\xcc\xcc\xcc\xcc\x0c*@'
tRp323
sg17
(lp324
S'8'
asa(dp325
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp326
sg45
g30
(g69
S'"\x00\x00\x00\x00\x00\x00\x00'
tRp327
sg46
g30
(g32
S'\x9a\x99\x99\x99\x99\x99\x11@'
tRp328
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp329
sg49
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp330
sg51
S'KMNFBQ'
p331
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp332
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp333
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp334
sS'trials.thisIndex'
p335
g30
(g80
S'\x0c\x00\x00\x00'
tRp336
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp337
sS'trials.thisRepN'
p338
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp339
sg16
F1454513509.4915681
sg29
g33
sS'trials.thisN'
p340
I12
sg50
g30
(g32
S'\x9a\x99\x99\x99\x99\x99\x11@'
tRp341
sS'trials.thisTrialN'
p342
I12
sg54
g30
(g32
S'\x9a\x99\x99\x99\x99\x99\x19@'
tRp343
sg17
Nsa(dp344
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp345
sg19
(lp346
F1.2013030052185059
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp347
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp348
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp349
sg16
F1454513515.893434
sS'trials.thisN'
p350
I13
sg43
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp351
sg45
g30
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp352
sg46
g30
(g32
S'\xf3\xfd\xd4x\xe9&\x18@'
tRp353
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp354
sg51
S'GJBMRN'
p355
sg25
g26
sg53
S'hjxlqk'
p356
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp357
sS'trials.thisIndex'
p358
g30
(g80
S'\r\x00\x00\x00'
tRp359
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp360
sS'trials.thisRepN'
p361
I0
sg50
g30
(g32
S'\xf4\xfd\xd4x\xe9&\x10@'
tRp362
sg27
g11
sS'trials.thisTrialN'
p363
I13
sg54
g30
(g32
S'\xfa~j\xbct\x13*@'
tRp364
sg17
(lp365
S'7'
asa(dp366
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp367
sg45
g30
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp368
sg46
g30
(g32
S'\x14\xaeG\xe1z\x14\x10@'
tRp369
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp370
sg49
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp371
sg51
S'YRMBKD'
p372
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp373
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp374
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp375
sS'trials.thisIndex'
p376
g30
(g80
S'\x0e\x00\x00\x00'
tRp377
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp378
sS'trials.thisRepN'
p379
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp380
sg16
F1454513528.932225
sg29
g33
sS'trials.thisN'
p381
I14
sg50
g30
(g32
S'\x14\xaeG\xe1z\x14\x10@'
tRp382
sS'trials.thisTrialN'
p383
I14
sg54
g30
(g32
S'\n\xd7\xa3p=\n&@'
tRp384
sg17
Nsa(dp385
g23
g24
sg29
g33
sg49
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp386
sg19
(lp387
F1.6016128063201904
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp388
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp389
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp390
sg16
F1454513539.952745
sS'trials.thisN'
p391
I15
sg43
g30
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp392
sg45
g30
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp393
sg46
g30
(g32
S'@5^\xbaI\x8c\x1c@'
tRp394
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp395
sg51
S'WHQBYD'
p396
sg25
g26
sg53
S'gntfrx'
p397
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp398
sS'trials.thisIndex'
p399
g30
(g80
S'\x0f\x00\x00\x00'
tRp400
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp401
sS'trials.thisRepN'
p402
I0
sg50
g30
(g32
S'@5^\xbaI\x8c\x14@'
tRp403
sg27
g11
sS'trials.thisTrialN'
p404
I15
sg54
g30
(g32
S'\xa0\x1a/\xdd$F"@'
tRp405
sg17
(lp406
S'8'
asa(dp407
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp408
sg19
(lp409
F1.2012770175933838
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp410
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp411
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp412
sg16
F1454513549.0895519
sS'trials.thisN'
p413
I16
sg43
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp414
sg45
g30
(g69
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp415
sg46
g30
(g32
S'\x11X9\xb4\xc8v\x18@'
tRp416
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp417
sg51
S'XYDNTF'
p418
sg25
g26
sg53
S'kgmjwn'
p419
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp420
sS'trials.thisIndex'
p421
g30
(g80
S'\x10\x00\x00\x00'
tRp422
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp423
sS'trials.thisRepN'
p424
I0
sg50
g30
(g32
S'\x11X9\xb4\xc8v\x10@'
tRp425
sg27
g11
sS'trials.thisTrialN'
p426
I16
sg54
g30
(g32
S'\x08\xac\x1cZd;*@'
tRp427
sg17
(lp428
S'7'
asa(dp429
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp430
sg19
(lp431
F1.2684681415557861
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp432
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp433
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp434
sg16
F1454513562.210655
sS'trials.thisN'
p435
I17
sg43
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp436
sg45
g30
(g69
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp437
sg46
g30
(g32
S't\x93\x18\x04V\x8e\x1c@'
tRp438
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp439
sg51
S'LMBRKW'
p440
sg25
g26
sg53
S'fnxgtj'
p441
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp442
sS'trials.thisIndex'
p443
g30
(g80
S'\x11\x00\x00\x00'
tRp444
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp445
sS'trials.thisRepN'
p446
I0
sg50
g30
(g32
S't\x93\x18\x04V\x8e\x14@'
tRp447
sg27
g11
sS'trials.thisTrialN'
p448
I17
sg54
g30
(g32
S'\xbbI\x0c\x02+G,@'
tRp449
sg17
(lp450
S'8'
asa(dp451
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp452
sg19
(lp453
F1.3008639812469482
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp454
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp455
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp456
sg16
F1454513576.349113
sS'trials.thisN'
p457
I18
sg43
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp458
sg45
g30
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp459
sg46
g30
(g32
S'E\xb6\xf3\xfd\xd4x\x1a@'
tRp460
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp461
sg51
S'MFXWDL'
p462
sg25
g26
sg53
S'jhrbkd'
p463
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp464
sS'trials.thisIndex'
p465
g30
(g80
S'\x12\x00\x00\x00'
tRp466
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp467
sS'trials.thisRepN'
p468
I0
sg50
g30
(g32
S'F\xb6\xf3\xfd\xd4x\x12@'
tRp469
sg27
g11
sS'trials.thisTrialN'
p470
I18
sg54
g30
(g32
S'#\xdb\xf9~j<+@'
tRp471
sg17
(lp472
S'7'
asa(dp473
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp474
sg19
(lp475
F1.4850199222564697
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp476
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp477
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp478
sg16
F1454513589.970324
sS'trials.thisN'
p479
I19
sg43
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp480
sg45
g30
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp481
sg46
g30
(g32
S'\x1b/\xdd$\x06\x01\x18@'
tRp482
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp483
sg51
S'JRHKTN'
p484
sg25
g26
sg53
S'mlyxbd'
p485
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp486
sS'trials.thisIndex'
p487
g30
(g80
S'\x13\x00\x00\x00'
tRp488
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp489
sS'trials.thisRepN'
p490
I0
sg50
g30
(g32
S'\x1b/\xdd$\x06\x01\x10@'
tRp491
sg27
g11
sS'trials.thisTrialN'
p492
I19
sg54
g30
(g32
S'\x8d\x97n\x12\x83\x00*@'
tRp493
sg17
(lp494
S'8'
asa(dp495
g23
g24
sg29
g33
sg49
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp496
sg19
(lp497
F1.1179280281066895
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp498
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp499
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp500
sg16
F1454513602.9746971
sS'trials.thisN'
p501
I20
sg43
g30
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp502
sg45
g30
(g69
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp503
sg46
g30
(g32
S'\x00\x00\x00\x00\x00\x00\x18@'
tRp504
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp505
sg51
S'GJDXLW'
p506
sg25
g26
sg53
S'jqmrhf'
p507
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp508
sS'trials.thisIndex'
p509
g30
(g80
S'\x14\x00\x00\x00'
tRp510
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp511
sS'trials.thisRepN'
p512
I0
sg50
g30
(g32
S'\x00\x00\x00\x00\x00\x00\x10@'
tRp513
sg27
g11
sS'trials.thisTrialN'
p514
I20
sg54
g30
(g32
S'\x00\x00\x00\x00\x00\x00 @'
tRp515
sg17
(lp516
S'7'
asa(dp517
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp518
sg19
(lp519
F0.88478803634643555
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp520
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp521
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp522
sg16
F1454513610.9777031
sS'trials.thisN'
p523
I21
sg43
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp524
sg45
g30
(g69
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp525
sg46
g30
(g32
S'{\x14\xaeG\xe1z\x18@'
tRp526
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp527
sg51
S'XWMYTB'
p528
sg25
g26
sg53
S'hdnmfk'
p529
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp530
sS'trials.thisIndex'
p531
g30
(g80
S'\x15\x00\x00\x00'
tRp532
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp533
sS'trials.thisRepN'
p534
I0
sg50
g30
(g32
S'{\x14\xaeG\xe1z\x10@'
tRp535
sg27
g11
sS'trials.thisTrialN'
p536
I21
sg54
g30
(g32
S'=\n\xd7\xa3p=*@'
tRp537
sg17
(lp538
S'7'
asa(dp539
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp540
sg19
(lp541
F1.2847771644592285
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp542
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp543
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp544
sg16
F1454513624.099565
sS'trials.thisN'
p545
I22
sg43
g30
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp546
sg45
g30
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp547
sg46
g30
(g32
S'_\xbaI\x0c\x02\xab\x19@'
tRp548
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp549
sg51
S'JKFLDH'
p550
sg25
g26
sg53
S'ynqxrg'
p551
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp552
sS'trials.thisIndex'
p553
g30
(g80
S'\x16\x00\x00\x00'
tRp554
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp555
sS'trials.thisRepN'
p556
I0
sg50
g30
(g32
S'^\xbaI\x0c\x02\xab\x11@'
tRp557
sg27
g11
sS'trials.thisTrialN'
p558
I22
sg54
g30
(g32
S'/\xdd$\x06\x81\xd5*@'
tRp559
sg17
(lp560
S'8'
asa(dp561
g23
g24
sg29
g33
sg49
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp562
sg19
(lp563
F2.1180760860443115
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp564
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp565
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp566
sg16
F1454513637.5214181
sS'trials.thisN'
p567
I23
sg43
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp568
sg45
g30
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp569
sg46
g30
(g32
S'\x17\xd9\xce\xf7S\xe3\x1f@'
tRp570
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp571
sg51
S'NHWFQR'
p572
sg25
g26
sg53
S'xbktqj'
p573
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp574
sS'trials.thisIndex'
p575
g30
(g80
S'\x17\x00\x00\x00'
tRp576
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp577
sS'trials.thisRepN'
p578
I0
sg50
g30
(g32
S'\x17\xd9\xce\xf7S\xe3\x17@'
tRp579
sg27
g11
sS'trials.thisTrialN'
p580
I23
sg54
g30
(g32
S'\x8cl\xe7\xfb\xa9\xf1#@'
tRp581
sg17
(lp582
S'7'
asa(dp583
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp584
sg45
g30
(g69
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp585
sg46
g30
(g32
S'\x7fj\xbct\x93\x18\x10@'
tRp586
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp587
sg49
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp588
sg51
S'QWYKRB'
p589
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp590
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp591
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp592
sS'trials.thisIndex'
p593
g30
(g80
S'\x18\x00\x00\x00'
tRp594
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp595
sS'trials.thisRepN'
p596
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp597
sg16
F1454513647.4918461
sg29
g33
sS'trials.thisN'
p598
I24
sg50
g30
(g32
S'\x7fj\xbct\x93\x18\x10@'
tRp599
sS'trials.thisTrialN'
p600
I24
sg54
g30
(g32
S'@5^\xbaI\x0c&@'
tRp601
sg17
Nsa(dp602
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp603
sg45
g30
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp604
sg46
g30
(g32
S'5^\xbaI\x0c\x02\x10@'
tRp605
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp606
sg49
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp607
sg51
S'HXTQMD'
p608
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp609
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp610
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp611
sS'trials.thisIndex'
p612
g30
(g80
S'\x19\x00\x00\x00'
tRp613
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp614
sS'trials.thisRepN'
p615
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp616
sg16
F1454513658.5121901
sg29
g33
sS'trials.thisN'
p617
I25
sg50
g30
(g32
S'5^\xbaI\x0c\x02\x10@'
tRp618
sS'trials.thisTrialN'
p619
I25
sg54
g30
(g32
S'6^\xbaI\x0c\x02\x18@'
tRp620
sg17
Nsa(dp621
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp622
sg19
(lp623
F1.3843882083892822
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp624
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp625
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp626
sg16
F1454513664.5142021
sS'trials.thisN'
p627
I26
sg43
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp628
sg45
g30
(g69
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp629
sg46
g30
(g32
S'/\xdd$\x06\x81\x15\x18@'
tRp630
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp631
sg51
S'GRKBTJ'
p632
sg25
g26
sg53
S'nymxql'
p633
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp634
sS'trials.thisIndex'
p635
g30
(g80
S'\x1a\x00\x00\x00'
tRp636
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp637
sS'trials.thisRepN'
p638
I0
sg50
g30
(g32
S'/\xdd$\x06\x81\x15\x10@'
tRp639
sg27
g11
sS'trials.thisTrialN'
p640
I26
sg54
g30
(g32
S'\x97n\x12\x83\xc0\n*@'
tRp641
sg17
(lp642
S'8'
asa(dp643
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp644
sg45
g30
(g69
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp645
sg46
g30
(g32
S'%\x06\x81\x95C\x8b\x11@'
tRp646
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp647
sg49
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp648
sg51
S'XTRNKH'
p649
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp650
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp651
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp652
sS'trials.thisIndex'
p653
g30
(g80
S'\x1b\x00\x00\x00'
tRp654
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp655
sS'trials.thisRepN'
p656
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp657
sg16
F1454513677.535249
sg29
g33
sS'trials.thisN'
p658
I27
sg50
g30
(g32
S'%\x06\x81\x95C\x8b\x11@'
tRp659
sS'trials.thisTrialN'
p660
I27
sg54
g30
(g32
S'\x12\x83\xc0\xca\xa1\xc5&@'
tRp661
sg17
Nsa(dp662
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp663
sg45
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp664
sg46
g30
(g32
S'\xf4\xfd\xd4x\xe9&\x10@'
tRp665
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp666
sg49
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp667
sg51
S'WLRJNG'
p668
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp669
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp670
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp671
sS'trials.thisIndex'
p672
g30
(g80
S'\x1c\x00\x00\x00'
tRp673
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp674
sS'trials.thisRepN'
p675
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp676
sg16
F1454513688.922998
sg29
g33
sS'trials.thisN'
p677
I28
sg50
g30
(g32
S'\xf4\xfd\xd4x\xe9&\x10@'
tRp678
sS'trials.thisTrialN'
p679
I28
sg54
g30
(g32
S'\xf3\xfd\xd4x\xe9&\x18@'
tRp680
sg17
Nsa(dp681
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp682
sg19
(lp683
F1.1682021617889404
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp684
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp685
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp686
sg16
F1454513694.958657
sS'trials.thisN'
p687
I29
sg43
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp688
sg45
g30
(g69
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp689
sg46
g30
(g32
S')\\\x8f\xc2\xf5\xa8\x19@'
tRp690
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp691
sg51
S'XTNJWF'
p692
sg25
g26
sg53
S'ygbqdh'
p693
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp694
sS'trials.thisIndex'
p695
g30
(g80
S'\x1d\x00\x00\x00'
tRp696
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp697
sS'trials.thisRepN'
p698
I0
sg50
g30
(g32
S')\\\x8f\xc2\xf5\xa8\x11@'
tRp699
sg27
g11
sS'trials.thisTrialN'
p700
I29
sg54
g30
(g32
S'\x14\xaeG\xe1z\xd4*@'
tRp701
sg17
(lp702
S'8'
asa(dp703
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp704
sg19
(lp705
F0.96833992004394531
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp706
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp707
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp708
sg16
F1454513708.379699
sS'trials.thisN'
p709
I30
sg43
g30
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp710
sg45
g30
(g69
S'\x0c\x00\x00\x00\x00\x00\x00\x00'
tRp711
sg46
g30
(g32
S'O\x8d\x97n\x12\x83\x18@'
tRp712
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp713
sg51
S'KXBLTD'
p714
sg25
g26
sg53
S'mnygrf'
p715
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp716
sS'trials.thisIndex'
p717
g30
(g80
S'\x1e\x00\x00\x00'
tRp718
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp719
sS'trials.thisRepN'
p720
I0
sg50
g30
(g32
S'P\x8d\x97n\x12\x83\x10@'
tRp721
sg27
g11
sS'trials.thisTrialN'
p722
I30
sg54
g30
(g32
S'\xa8\xc6K7\x89A*@'
tRp723
sg17
(lp724
S'8'
asa(dp725
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp726
sg45
g30
(g69
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp727
sg46
g30
(g32
S'\x8f\xc2\xf5(\\\x0f\x10@'
tRp728
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp729
sg49
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp730
sg51
S'QRFJDH'
p731
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp732
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp733
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp734
sS'trials.thisIndex'
p735
g30
(g80
S'\x1f\x00\x00\x00'
tRp736
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp737
sS'trials.thisRepN'
p738
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp739
sg16
F1454513721.5007839
sg29
g33
sS'trials.thisN'
p740
I31
sg50
g30
(g32
S'\x8f\xc2\xf5(\\\x0f\x10@'
tRp741
sS'trials.thisTrialN'
p742
I31
sg54
g30
(g32
S'H\xe1z\x14\xae\x07&@'
tRp743
sg17
Nsa(dp744
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp745
sg19
(lp746
F1.7683329582214355
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp747
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp748
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp749
sg16
F1454513732.5052719
sS'trials.thisN'
p750
I32
sg43
g30
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp751
sg45
g30
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp752
sg46
g30
(g32
S'\x0e-\xb2\x9d\xef\xa7\x18@'
tRp753
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp754
sg51
S'MXRTLF'
p755
sg25
g26
sg53
S'bylqkd'
p756
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp757
sS'trials.thisIndex'
p758
g30
(g80
S' \x00\x00\x00'
tRp759
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp760
sS'trials.thisRepN'
p761
I0
sg50
g30
(g32
S'\x0e-\xb2\x9d\xef\xa7\x10@'
tRp762
sg27
g11
sS'trials.thisTrialN'
p763
I32
sg54
g30
(g32
S'\x88\x16\xd9\xce\xf7S*@'
tRp764
sg17
(lp765
S'7'
asa(dp766
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp767
sg45
g30
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp768
sg46
g30
(g32
S'\xc4 \xb0rh\x11\x12@'
tRp769
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp770
sg49
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp771
sg51
S'FJKMBQ'
p772
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp773
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp774
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp775
sS'trials.thisIndex'
p776
g30
(g80
S'!\x00\x00\x00'
tRp777
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp778
sS'trials.thisRepN'
p779
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp780
sg16
F1454513745.659899
sg29
g33
sS'trials.thisN'
p781
I33
sg50
g30
(g32
S'\xc4 \xb0rh\x11\x12@'
tRp782
sS'trials.thisTrialN'
p783
I33
sg54
g30
(g32
S'\xc5 \xb0rh\x11\x1a@'
tRp784
sg17
Nsa(dp785
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp786
sg19
(lp787
F1.7184770107269287
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp788
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp789
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp790
sg16
F1454513752.178731
sS'trials.thisN'
p791
I34
sg43
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp792
sg45
g30
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp793
sg46
g30
(g32
S'\xb2\x9d\xef\xa7\xc6K\x18@'
tRp794
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp795
sg51
S'YMQHXG'
p796
sg25
g26
sg53
S'twrkjy'
p797
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp798
sS'trials.thisIndex'
p799
g30
(g80
S'"\x00\x00\x00'
tRp800
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp801
sS'trials.thisRepN'
p802
I0
sg50
g30
(g32
S'\xb2\x9d\xef\xa7\xc6K\x10@'
tRp803
sg27
g11
sS'trials.thisTrialN'
p804
I34
sg54
g30
(g32
S'\xda\xce\xf7S\xe3%*@'
tRp805
sg17
(lp806
S'7'
asa(dp807
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp808
sg19
(lp809
F1.6177890300750732
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp810
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp811
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp812
sg16
F1454513765.2501619
sS'trials.thisN'
p813
I35
sg43
g30
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp814
sg45
g30
(g69
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp815
sg46
g30
(g32
S'\x85\xebQ\xb8\x1e\x05\x1d@'
tRp816
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp817
sg51
S'JFRBMN'
p818
sg25
g26
sg53
S'nhgxqt'
p819
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp820
sS'trials.thisIndex'
p821
g30
(g80
S'#\x00\x00\x00'
tRp822
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp823
sS'trials.thisRepN'
p824
I0
sg50
g30
(g32
S'\x85\xebQ\xb8\x1e\x05\x15@'
tRp825
sg27
g11
sS'trials.thisTrialN'
p826
I35
sg54
g30
(g32
S'\xc3\xf5(\\\x8f\x82,@'
tRp827
sg17
(lp828
S'7'
asa(dp829
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp830
sg19
(lp831
F1.6178121566772461
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp832
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp833
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp834
sg16
F1454513779.505233
sS'trials.thisN'
p835
I36
sg43
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp836
sg45
g30
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp837
sg46
g30
(g32
S'\xaa\xf1\xd2Mb\x10\x1a@'
tRp838
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp839
sg51
S'GMBFLX'
p840
sg25
g26
sg53
S'hqydrt'
p841
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp842
sS'trials.thisIndex'
p843
g30
(g80
S'$\x00\x00\x00'
tRp844
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp845
sS'trials.thisRepN'
p846
I0
sg50
g30
(g32
S'\xaa\xf1\xd2Mb\x10\x12@'
tRp847
sg27
g11
sS'trials.thisTrialN'
p848
I36
sg54
g30
(g32
S'\xd4x\xe9&1\x08+@'
tRp849
sg17
(lp850
S'8'
asa(dp851
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp852
sg45
g30
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp853
sg46
g30
(g32
S'Nb\x10X94\x11@'
tRp854
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp855
sg49
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp856
sg51
S'MGJHDF'
p857
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp858
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp859
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp860
sS'trials.thisIndex'
p861
g30
(g80
S'%\x00\x00\x00'
tRp862
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp863
sS'trials.thisRepN'
p864
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp865
sg16
F1454513793.0270569
sg29
g33
sS'trials.thisN'
p866
I37
sg50
g30
(g32
S'Nb\x10X94\x11@'
tRp867
sS'trials.thisTrialN'
p868
I37
sg54
g30
(g32
S'Nb\x10X94\x19@'
tRp869
sg17
Nsa(dp870
g23
g24
sg29
g33
sg49
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp871
sg19
(lp872
F1.4348680973052979
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp873
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp874
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp875
sg16
F1454513799.3294339
sS'trials.thisN'
p876
I38
sg43
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp877
sg45
g30
(g69
S'\xc8\x01\x00\x00\x00\x00\x00\x00'
tRp878
sg46
g30
(g32
S'\x9a\x99\x99\x99\x99\x19\x18@'
tRp879
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp880
sg51
S'WMJNLK'
p881
sg25
g26
sg53
S'tdyxhb'
p882
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp883
sS'trials.thisIndex'
p884
g30
(g80
S'&\x00\x00\x00'
tRp885
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp886
sS'trials.thisRepN'
p887
I0
sg50
g30
(g32
S'\x9a\x99\x99\x99\x99\x19\x10@'
tRp888
sg27
g11
sS'trials.thisTrialN'
p889
I38
sg54
g30
(g32
S'\xcd\xcc\xcc\xcc\xcc\x0c @'
tRp890
sg17
(lp891
S'8'
asa(dp892
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp893
sg19
(lp894
F1.0178840160369873
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp895
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp896
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp897
sg16
F1454513807.3488381
sS'trials.thisN'
p898
I39
sg43
g30
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp899
sg45
g30
(g69
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp900
sg46
g30
(g32
S'sh\x91\xed|?\x19@'
tRp901
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp902
sg51
S'QGMLKT'
p903
sg25
g26
sg53
S'qhyndw'
p904
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp905
sS'trials.thisIndex'
p906
g30
(g80
S"'\x00\x00\x00"
tRp907
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp908
sS'trials.thisRepN'
p909
I0
sg50
g30
(g32
S'sh\x91\xed|?\x11@'
tRp910
sg27
g11
sS'trials.thisTrialN'
p911
I39
sg54
g30
(g32
S':\xb4\xc8v\xbe\x9f*@'
tRp912
sg17
(lp913
S'7'
asa(dp914
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp915
sg19
(lp916
F1.3346059322357178
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp917
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp918
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp919
sg16
F1454513820.6532371
sS'trials.thisN'
p920
I40
sg43
g30
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp921
sg45
g30
(g69
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp922
sg46
g30
(g32
S'O\x8d\x97n\x12\x03\x18@'
tRp923
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp924
sg51
S'NHQMRX'
p925
sg25
g26
sg53
S'ljhtbw'
p926
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp927
sS'trials.thisIndex'
p928
g30
(g80
S'(\x00\x00\x00'
tRp929
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp930
sS'trials.thisRepN'
p931
I0
sg50
g30
(g32
S'P\x8d\x97n\x12\x03\x10@'
tRp932
sg27
g11
sS'trials.thisTrialN'
p933
I40
sg54
g30
(g32
S'\xa8\xc6K7\x89\x01*@'
tRp934
sg17
(lp935
S'7'
asa(dp936
g23
g24
sg29
g33
sg49
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp937
sg19
(lp938
F0.88387894630432129
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp939
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp940
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp941
sg16
F1454513833.6582479
sS'trials.thisN'
p942
I41
sg43
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp943
sg45
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp944
sg46
g30
(g32
S'ffffff\x1a@'
tRp945
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp946
sg51
S'NTKWBY'
p947
sg25
g26
sg53
S'dxmrgw'
p948
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp949
sS'trials.thisIndex'
p950
g30
(g80
S')\x00\x00\x00'
tRp951
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp952
sS'trials.thisRepN'
p953
I0
sg50
g30
(g32
S'ffffff\x12@'
tRp954
sg27
g11
sS'trials.thisTrialN'
p955
I41
sg54
g30
(g32
S'333333!@'
tRp956
sg17
(lp957
S'7'
asa(dp958
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp959
sg45
g30
(g69
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp960
sg46
g30
(g32
S"\x0e-\xb2\x9d\xef'\x10@"
tRp961
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp962
sg49
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp963
sg51
S'YLTXNK'
p964
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp965
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp966
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp967
sS'trials.thisIndex'
p968
g30
(g80
S'*\x00\x00\x00'
tRp969
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp970
sS'trials.thisRepN'
p971
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp972
sg16
F1454513842.2623811
sg29
g33
sS'trials.thisN'
p973
I42
sg50
g30
(g32
S"\x0e-\xb2\x9d\xef'\x10@"
tRp974
sS'trials.thisTrialN'
p975
I42
sg54
g30
(g32
S"\x0e-\xb2\x9d\xef'\x18@"
tRp976
sg17
Nsa(dp977
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp978
sg19
(lp979
F1.285236120223999
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp980
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp981
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp982
sg16
F1454513848.296917
sS'trials.thisN'
p983
I43
sg43
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp984
sg45
g30
(g69
S'\xc8\x01\x00\x00\x00\x00\x00\x00'
tRp985
sg46
g30
(g32
S'J\x0c\x02+\x87\x96\x18@'
tRp986
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp987
sg51
g418
sg25
g26
sg53
S'btmrgk'
p988
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp989
sS'trials.thisIndex'
p990
g30
(g80
S'+\x00\x00\x00'
tRp991
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp992
sS'trials.thisRepN'
p993
I0
sg50
g30
(g32
S'J\x0c\x02+\x87\x96\x10@'
tRp994
sg27
g11
sS'trials.thisTrialN'
p995
I43
sg54
g30
(g32
S'%\x06\x81\x95CK*@'
tRp996
sg17
(lp997
S'7'
asa(dp998
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp999
sg19
(lp1000
F0.93468189239501953
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1001
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1002
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1003
sg16
F1454513861.4352109
sS'trials.thisN'
p1004
I44
sg43
g30
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1005
sg45
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1006
sg46
g30
(g32
S'\xfd\xd4x\xe9&\xb1\x18@'
tRp1007
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1008
sg51
S'DHWBGK'
p1009
sg25
g26
sg53
S'grxjnq'
p1010
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1011
sS'trials.thisIndex'
p1012
g30
(g80
S',\x00\x00\x00'
tRp1013
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1014
sS'trials.thisRepN'
p1015
I0
sg50
g30
(g32
S'\xfe\xd4x\xe9&\xb1\x10@'
tRp1016
sg27
g11
sS'trials.thisTrialN'
p1017
I44
sg54
g30
(g32
S'\x7fj\xbct\x93X*@'
tRp1018
sg17
(lp1019
S'7'
asa(dp1020
g23
g24
sg29
g33
sg49
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1021
sg19
(lp1022
F1.0345158576965332
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1023
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1024
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1025
sg16
F1454513874.6065011
sS'trials.thisN'
p1026
I45
sg43
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1027
sg45
g30
(g69
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp1028
sg46
g30
(g32
S'\xfc\xa9\xf1\xd2Mb\x18@'
tRp1029
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1030
sg51
S'BMLJWY'
p1031
sg25
g26
sg53
S'ktnxfh'
p1032
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1033
sS'trials.thisIndex'
p1034
g30
(g80
S'-\x00\x00\x00'
tRp1035
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1036
sS'trials.thisRepN'
p1037
I0
sg50
g30
(g32
S'\xfc\xa9\xf1\xd2Mb\x10@'
tRp1038
sg27
g11
sS'trials.thisTrialN'
p1039
I45
sg54
g30
(g32
S'\xfe\xd4x\xe9&1 @'
tRp1040
sg17
(lp1041
S'8'
asa(dp1042
g23
g24
sg29
g33
sg49
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1043
sg19
(lp1044
F1.5514280796051025
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1045
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1046
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1047
sg16
F1454513882.692353
sS'trials.thisN'
p1048
I46
sg43
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1049
sg45
g30
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1050
sg46
g30
(g32
S'\x03+\x87\x16\xd9\xce\x18@'
tRp1051
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1052
sg51
S'KHGWLF'
p1053
sg25
g26
sg53
S'dqyxtn'
p1054
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1055
sS'trials.thisIndex'
p1056
g30
(g80
S'.\x00\x00\x00'
tRp1057
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1058
sS'trials.thisRepN'
p1059
I0
sg50
g30
(g32
S'\x02+\x87\x16\xd9\xce\x10@'
tRp1060
sg27
g11
sS'trials.thisTrialN'
p1061
I46
sg54
g30
(g32
S'\x81\x95C\x8blg @'
tRp1062
sg17
(lp1063
S'8'
asa(dp1064
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1065
sg19
(lp1066
F1.7516939640045166
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1067
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1068
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1069
sg16
F1454513890.8955071
sS'trials.thisN'
p1070
I47
sg43
g30
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1071
sg45
g30
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp1072
sg46
g30
(g32
S'\xc9v\xbe\x9f\x1a\xaf\x1e@'
tRp1073
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1074
sg51
S'KYTQLJ'
p1075
sg25
g26
sg53
S'qxgwrd'
p1076
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1077
sS'trials.thisIndex'
p1078
g30
(g80
S'/\x00\x00\x00'
tRp1079
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1080
sS'trials.thisRepN'
p1081
I0
sg50
g30
(g32
S'\xc9v\xbe\x9f\x1a\xaf\x16@'
tRp1082
sg27
g11
sS'trials.thisTrialN'
p1083
I47
sg54
g30
(g32
S'd;\xdfO\x8dW-@'
tRp1084
sg17
(lp1085
S'7'
asa(dp1086
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1087
sg45
g30
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1088
sg46
g30
(g32
S'\xa8\xc6K7\x89\xc1\x10@'
tRp1089
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1090
sg49
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1091
sg51
S'XYLWHD'
p1092
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1093
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1094
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1095
sS'trials.thisIndex'
p1096
g30
(g80
S'0\x00\x00\x00'
tRp1097
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1098
sS'trials.thisRepN'
p1099
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1100
sg16
F1454513905.56829
sg29
g33
sS'trials.thisN'
p1101
I48
sg50
g30
(g32
S'\xa8\xc6K7\x89\xc1\x10@'
tRp1102
sS'trials.thisTrialN'
p1103
I48
sg54
g30
(g32
S'\xa8\xc6K7\x89\xc1\x18@'
tRp1104
sg17
Nsa(dp1105
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1106
sg45
g30
(g69
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp1107
sg46
g30
(g32
S'\xc1\xca\xa1E\xb6s\x11@'
tRp1108
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1109
sg49
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1110
sg51
S'LNFKGJ'
p1111
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1112
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1113
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1114
sS'trials.thisIndex'
p1115
g30
(g80
S'1\x00\x00\x00'
tRp1116
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1117
sS'trials.thisRepN'
p1118
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1119
sg16
F1454513911.7534029
sg29
g33
sS'trials.thisN'
p1120
I49
sg50
g30
(g32
S'\xc1\xca\xa1E\xb6s\x11@'
tRp1121
sS'trials.thisTrialN'
p1122
I49
sg54
g30
(g32
S'`\xe5\xd0"\xdb\xb9&@'
tRp1123
sg17
Nsa(dp1124
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1125
sg19
(lp1126
F1.234717845916748
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1127
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1128
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1129
sg16
F1454513923.10659
sS'trials.thisN'
p1130
I50
sg43
g30
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1131
sg45
g30
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1132
sg46
g30
(g32
S'i\x91\xed|?5\x18@'
tRp1133
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1134
sg51
S'GYHWQK'
p1135
sg25
g26
sg53
S'djxnrf'
p1136
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1137
sS'trials.thisIndex'
p1138
g30
(g80
S'2\x00\x00\x00'
tRp1139
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1140
sS'trials.thisRepN'
p1141
I0
sg50
g30
(g32
S'h\x91\xed|?5\x10@'
tRp1142
sg27
g11
sS'trials.thisTrialN'
p1143
I50
sg54
g30
(g32
S'\xb4\xc8v\xbe\x9f\x1a*@'
tRp1144
sg17
(lp1145
S'8'
asa(dp1146
g23
g24
sg29
g33
sg49
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1147
sg19
(lp1148
F0.8683161735534668
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1149
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1150
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1151
sg16
F1454513936.1610191
sS'trials.thisN'
p1152
I51
sg43
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1153
sg45
g30
(g69
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp1154
sg46
g30
(g32
S'\x96C\x8bl\xe7{\x18@'
tRp1155
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1156
sg51
S'RYNLWB'
p1157
sg25
g26
sg53
S'jmtghl'
p1158
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1159
sS'trials.thisIndex'
p1160
g30
(g80
S'3\x00\x00\x00'
tRp1161
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1162
sS'trials.thisRepN'
p1163
I0
sg50
g30
(g32
S'\x96C\x8bl\xe7{\x10@'
tRp1164
sg27
g11
sS'trials.thisTrialN'
p1165
I51
sg54
g30
(g32
S'\xcb\xa1E\xb6\xf3= @'
tRp1166
sg17
(lp1167
S'7'
asa(dp1168
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1169
sg45
g30
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1170
sg46
g30
(g32
S'\xb6\xf3\xfd\xd4xi\x10@'
tRp1171
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1172
sg49
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1173
sg51
S'TYBDRX'
p1174
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1175
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1176
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1177
sS'trials.thisIndex'
p1178
g30
(g80
S'4\x00\x00\x00'
tRp1179
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1180
sS'trials.thisRepN'
p1181
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1182
sg16
F1454513944.281199
sg29
g33
sS'trials.thisN'
p1183
I52
sg50
g30
(g32
S'\xb6\xf3\xfd\xd4xi\x10@'
tRp1184
sS'trials.thisTrialN'
p1185
I52
sg54
g30
(g32
S'\xb6\xf3\xfd\xd4xi\x18@'
tRp1186
sg17
Nsa(dp1187
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1188
sg45
g30
(g69
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp1189
sg46
g30
(g32
S'\xaeG\xe1z\x14.\x10@'
tRp1190
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1191
sg49
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1192
sg51
S'XDYGRT'
p1193
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1194
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1195
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1196
sS'trials.thisIndex'
p1197
g30
(g80
S'5\x00\x00\x00'
tRp1198
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1199
sS'trials.thisRepN'
p1200
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1201
sg16
F1454513950.383472
sg29
g33
sS'trials.thisN'
p1202
I53
sg50
g30
(g32
S'\xaeG\xe1z\x14.\x10@'
tRp1203
sS'trials.thisTrialN'
p1204
I53
sg54
g30
(g32
S'\xaeG\xe1z\x14.\x18@'
tRp1205
sg17
Nsa(dp1206
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1207
sg45
g30
(g69
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp1208
sg46
g30
(g32
S'\n\xd7\xa3p=\n\x10@'
tRp1209
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1210
sg49
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1211
sg51
S'HYDTGR'
p1212
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1213
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1214
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1215
sS'trials.thisIndex'
p1216
g30
(g80
S'6\x00\x00\x00'
tRp1217
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1218
sS'trials.thisRepN'
p1219
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1220
sg16
F1454513956.418745
sg29
g33
sS'trials.thisN'
p1221
I54
sg50
g30
(g32
S'\n\xd7\xa3p=\n\x10@'
tRp1222
sS'trials.thisTrialN'
p1223
I54
sg54
g30
(g32
S'\n\xd7\xa3p=\n\x18@'
tRp1224
sg17
Nsa(dp1225
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1226
sg19
(lp1227
F1.0013248920440674
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1228
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1229
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1230
sg16
F1454513962.4214351
sS'trials.thisN'
p1231
I55
sg43
g30
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1232
sg45
g30
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1233
sg46
g30
(g32
S'%\x06\x81\x95C\x0b\x18@'
tRp1234
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1235
sg51
S'WNDHRY'
p1236
sg25
g26
sg53
S'txbkml'
p1237
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1238
sS'trials.thisIndex'
p1239
g30
(g80
S'7\x00\x00\x00'
tRp1240
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1241
sS'trials.thisRepN'
p1242
I0
sg50
g30
(g32
S'%\x06\x81\x95C\x0b\x10@'
tRp1243
sg27
g11
sS'trials.thisTrialN'
p1244
I55
sg54
g30
(g32
S'\x12\x83\xc0\xca\xa1\x05*@'
tRp1245
sg17
(lp1246
S'8'
asa(dp1247
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1248
sg19
(lp1249
F0.95148897171020508
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1250
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1251
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1252
sg16
F1454513975.425478
sS'trials.thisN'
p1253
I56
sg43
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1254
sg45
g30
(g69
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp1255
sg46
g30
(g32
S'/\xdd$\x06\x81\x95\x18@'
tRp1256
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1257
sg51
S'NJWFRG'
p1258
sg25
g26
sg53
S'lkqmdj'
p1259
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1260
sS'trials.thisIndex'
p1261
g30
(g80
S'8\x00\x00\x00'
tRp1262
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1263
sS'trials.thisRepN'
p1264
I0
sg50
g30
(g32
S'/\xdd$\x06\x81\x95\x10@'
tRp1265
sg27
g11
sS'trials.thisTrialN'
p1266
I56
sg54
g30
(g32
S'\x97n\x12\x83\xc0J*@'
tRp1267
sg17
(lp1268
S'7'
asa(dp1269
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1270
sg19
(lp1271
F0.93439793586730957
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1272
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1273
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1274
sg16
F1454513988.5638371
sS'trials.thisN'
p1275
I57
sg43
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1276
sg45
g30
(g69
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp1277
sg46
g30
(g32
S'=\n\xd7\xa3p\xbd\x18@'
tRp1278
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1279
sg51
S'BTXWRQ'
p1280
sg25
g26
sg53
S'mykndj'
p1281
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1282
sS'trials.thisIndex'
p1283
g30
(g80
S'9\x00\x00\x00'
tRp1284
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1285
sS'trials.thisRepN'
p1286
I0
sg50
g30
(g32
S'=\n\xd7\xa3p\xbd\x10@'
tRp1287
sg27
g11
sS'trials.thisTrialN'
p1288
I57
sg54
g30
(g32
S'\x1f\x85\xebQ\xb8^*@'
tRp1289
sg17
(lp1290
S'8'
asa(dp1291
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1292
sg45
g30
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1293
sg46
g30
(g32
S'\xaeG\xe1z\x14.\x10@'
tRp1294
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1295
sg49
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1296
sg51
S'MYXJNT'
p1297
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1298
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1299
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1300
sS'trials.thisIndex'
p1301
g30
(g80
S':\x00\x00\x00'
tRp1302
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1303
sS'trials.thisRepN'
p1304
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1305
sg16
F1454514001.7521391
sg29
g33
sS'trials.thisN'
p1306
I58
sg50
g30
(g32
S'\xaeG\xe1z\x14.\x10@'
tRp1307
sS'trials.thisTrialN'
p1308
I58
sg54
g30
(g32
S'\xd7\xa3p=\n\x17&@'
tRp1309
sg17
Nsa(dp1310
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1311
sg45
g30
(g69
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp1312
sg46
g30
(g32
S'y\xe9&1\x08,\x10@'
tRp1313
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1314
sg49
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1315
sg51
S'HBYLMQ'
p1316
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1317
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1318
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1319
sS'trials.thisIndex'
p1320
g30
(g80
S';\x00\x00\x00'
tRp1321
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1322
sS'trials.thisRepN'
p1323
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1324
sg16
F1454514012.7893989
sg29
g33
sS'trials.thisN'
p1325
I59
sg50
g30
(g32
S'y\xe9&1\x08,\x10@'
tRp1326
sS'trials.thisTrialN'
p1327
I59
sg54
g30
(g32
S'x\xe9&1\x08,\x18@'
tRp1328
sg17
Nsa(dp1329
g23
g24
sg29
g33
sg49
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1330
sg19
(lp1331
F1.4346160888671875
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1332
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1333
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1334
sg16
F1454514018.8241251
sS'trials.thisN'
p1335
I60
sg43
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1336
sg45
g30
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp1337
sg46
g30
(g32
S'i\x91\xed|?\xb5\x19@'
tRp1338
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1339
sg51
S'GLMNYH'
p1340
sg25
g26
sg53
S'knqwxb'
p1341
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1342
sS'trials.thisIndex'
p1343
g30
(g80
S'<\x00\x00\x00'
tRp1344
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1345
sS'trials.thisRepN'
p1346
I0
sg50
g30
(g32
S'h\x91\xed|?\xb5\x11@'
tRp1347
sg27
g11
sS'trials.thisTrialN'
p1348
I60
sg54
g30
(g32
S'\xb4\xc8v\xbe\x9f\xda @'
tRp1349
sg17
(lp1350
S'7'
asa(dp1351
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1352
sg19
(lp1353
F1.0175380706787109
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1354
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1355
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1356
sg16
F1454514027.244349
sS'trials.thisN'
p1357
I61
sg43
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1358
sg45
g30
(g69
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp1359
sg46
g30
(g32
S'\xe9&1\x08\xac\x1c\x19@'
tRp1360
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1361
sg51
S'WHXFRB'
p1362
sg25
g26
sg53
S'jdglqm'
p1363
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1364
sS'trials.thisIndex'
p1365
g30
(g80
S'=\x00\x00\x00'
tRp1366
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1367
sS'trials.thisRepN'
p1368
I0
sg50
g30
(g32
S'\xea&1\x08\xac\x1c\x11@'
tRp1369
sg27
g11
sS'trials.thisTrialN'
p1370
I61
sg54
g30
(g32
S't\x93\x18\x04V\x8e*@'
tRp1371
sg17
(lp1372
S'8'
asa(dp1373
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1374
sg19
(lp1375
F1.618412971496582
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1376
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1377
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1378
sg16
F1454514040.5156081
sS'trials.thisN'
p1379
I62
sg43
g30
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1380
sg45
g30
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1381
sg46
g30
(g32
S'6^\xbaI\x0c\x02\x18@'
tRp1382
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1383
sg51
S'JRWBTF'
p1384
sg25
g26
sg53
S'lgbnqh'
p1385
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1386
sS'trials.thisIndex'
p1387
g30
(g80
S'>\x00\x00\x00'
tRp1388
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1389
sS'trials.thisRepN'
p1390
I0
sg50
g30
(g32
S'5^\xbaI\x0c\x02\x10@'
tRp1391
sg27
g11
sS'trials.thisTrialN'
p1392
I62
sg54
g30
(g32
S'\x1b/\xdd$\x06\x01*@'
tRp1393
sg17
(lp1394
S'7'
asa(dp1395
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1396
sg45
g30
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1397
sg46
g30
(g32
S'\xf8S\xe3\xa5\x9bD\x10@'
tRp1398
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1399
sg49
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1400
sg51
S'BDLTMY'
p1401
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1402
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1403
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1404
sS'trials.thisIndex'
p1405
g30
(g80
S'?\x00\x00\x00'
tRp1406
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1407
sS'trials.thisRepN'
p1408
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1409
sg16
F1454514053.520447
sg29
g33
sS'trials.thisN'
p1410
I63
sg50
g30
(g32
S'\xf8S\xe3\xa5\x9bD\x10@'
tRp1411
sS'trials.thisTrialN'
p1412
I63
sg54
g30
(g32
S'\xfc\xa9\xf1\xd2M"&@'
tRp1413
sg17
Nsa(dp1414
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1415
sg19
(lp1416
F1.1011898517608643
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1417
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1418
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1419
sg16
F1454514064.5912509
sS'trials.thisN'
p1420
I64
sg43
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1421
sg45
g30
(g69
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp1422
sg46
g30
(g32
S'\xe5\xd0"\xdb\xf9~\x19@'
tRp1423
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1424
sg51
S'QMGDKH'
p1425
sg25
g26
sg53
S'tlxrjy'
p1426
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1427
sS'trials.thisIndex'
p1428
g30
(g80
S'@\x00\x00\x00'
tRp1429
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1430
sS'trials.thisRepN'
p1431
I0
sg50
g30
(g32
S'\xe5\xd0"\xdb\xf9~\x11@'
tRp1432
sg27
g11
sS'trials.thisTrialN'
p1433
I64
sg54
g30
(g32
S'sh\x91\xed|\xbf*@'
tRp1434
sg17
(lp1435
S'8'
asa(dp1436
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1437
sg19
(lp1438
F1.1671099662780762
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1439
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1440
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1441
sg16
F1454514077.9629791
sS'trials.thisN'
p1442
I65
sg43
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1443
sg45
g30
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1444
sg46
g30
(g32
S'\x1f\x85\xebQ\xb8\x9e\x18@'
tRp1445
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1446
sg51
S'YWDLHX'
p1447
sg25
g26
sg53
S'tlfbjr'
p1448
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1449
sS'trials.thisIndex'
p1450
g30
(g80
S'A\x00\x00\x00'
tRp1451
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1452
sS'trials.thisRepN'
p1453
I0
sg50
g30
(g32
S'\x1f\x85\xebQ\xb8\x9e\x10@'
tRp1454
sg27
g11
sS'trials.thisTrialN'
p1455
I65
sg54
g30
(g32
S'\x8f\xc2\xf5(\\O*@'
tRp1456
sg17
(lp1457
S'7'
asa(dp1458
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1459
sg45
g30
(g69
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp1460
sg46
g30
(g32
S'\x83\xc0\xca\xa1E6\x10@'
tRp1461
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1462
sg49
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1463
sg51
S'HGFJRD'
p1464
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1465
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1466
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1467
sS'trials.thisIndex'
p1468
g30
(g80
S'B\x00\x00\x00'
tRp1469
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1470
sS'trials.thisRepN'
p1471
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1472
sg16
F1454514091.1173561
sg29
g33
sS'trials.thisN'
p1473
I66
sg50
g30
(g32
S'\x83\xc0\xca\xa1E6\x10@'
tRp1474
sS'trials.thisTrialN'
p1475
I66
sg54
g30
(g32
S'A`\xe5\xd0"\x1b&@'
tRp1476
sg17
Nsa(dp1477
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1478
sg19
(lp1479
F0.90118980407714844
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1480
sg55
g30
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1481
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1482
sg16
F1454514102.171133
sS'trials.thisN'
p1483
I67
sg43
g30
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1484
sg45
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1485
sg46
g30
(g32
S'\xb8\x1e\x85\xebQ8\x18@'
tRp1486
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1487
sg51
S'TNJHXF'
p1488
sg25
g26
sg53
S'xgqrdk'
p1489
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1490
sS'trials.thisIndex'
p1491
g30
(g80
S'C\x00\x00\x00'
tRp1492
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1493
sS'trials.thisRepN'
p1494
I0
sg50
g30
(g32
S'\xb8\x1e\x85\xebQ8\x10@'
tRp1495
sg27
g11
sS'trials.thisTrialN'
p1496
I67
sg54
g30
(g32
S'\\\x8f\xc2\xf5(\x1c*@'
tRp1497
sg17
(lp1498
S'7'
asa(dp1499
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1500
sg45
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1501
sg46
g30
(g32
S'\x04V\x0e-\xb2\x1d\x11@'
tRp1502
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1503
sg49
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1504
sg51
S'QWNGHM'
p1505
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1506
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1507
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1508
sS'trials.thisIndex'
p1509
g30
(g80
S'D\x00\x00\x00'
tRp1510
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1511
sS'trials.thisRepN'
p1512
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1513
sg16
F1454514115.226316
sg29
g33
sS'trials.thisN'
p1514
I68
sg50
g30
(g32
S'\x04V\x0e-\xb2\x1d\x11@'
tRp1515
sS'trials.thisTrialN'
p1516
I68
sg54
g30
(g32
S'\x03+\x87\x16\xd9\x8e&@'
tRp1517
sg17
Nsa(dp1518
g23
g24
sg27
g11
sg43
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1519
sg45
g30
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1520
sg46
g30
(g32
S'R\xb8\x1e\x85\xeb\xd1\x11@'
tRp1521
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1522
sg49
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1523
sg51
S'XLNJFR'
p1524
sg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1525
sg25
g26
sg53
S' '
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1526
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1527
sS'trials.thisIndex'
p1528
g30
(g80
S'E\x00\x00\x00'
tRp1529
sg18
I0
sg28
S'1'
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1530
sS'trials.thisRepN'
p1531
I0
sg47
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1532
sg16
F1454514126.496006
sg29
g33
sS'trials.thisN'
p1533
I69
sg50
g30
(g32
S'R\xb8\x1e\x85\xeb\xd1\x11@'
tRp1534
sS'trials.thisTrialN'
p1535
I69
sg54
g30
(g32
S')\\\x8f\xc2\xf5\xe8&@'
tRp1536
sg17
Nsa(dp1537
g23
g24
sg29
g33
sg49
g30
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1538
sg19
(lp1539
F0.98471212387084961
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1540
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1541
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1542
sg16
F1454514137.9504981
sS'trials.thisN'
p1543
I70
sg43
g30
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1544
sg45
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1545
sg46
g30
(g32
S'i\x91\xed|?5\x18@'
tRp1546
sg48
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1547
sg51
S'DYKFTL'
p1548
sg25
g26
sg53
S'nhqjmr'
p1549
sg42
g30
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1550
sS'trials.thisIndex'
p1551
g30
(g80
S'F\x00\x00\x00'
tRp1552
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1553
sS'trials.thisRepN'
p1554
I0
sg50
g30
(g32
S'h\x91\xed|?5\x10@'
tRp1555
sg27
g11
sS'trials.thisTrialN'
p1556
I70
sg54
g30
(g32
S'\xb4\xc8v\xbe\x9f\x1a*@'
tRp1557
sg17
(lp1558
S'8'
asa(dp1559
g23
g24
sg29
g33
sg49
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1560
sg19
(lp1561
F0.9677281379699707
asg52
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1562
sg55
g30
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1563
sg18
I0
sg28
S'1'
sg47
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1564
sg16
F1454514151.005585
sS'trials.thisN'
p1565
I71
sg43
g30
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1566
sg45
g30
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1567
sg46
g30
(g32
S'\\\x8f\xc2\xf5(\xdc\x19@'
tRp1568
sg48
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1569
sg51
S'BYFQKT'
p1570
sg25
g26
sg53
S'hrxljn'
p1571
sg42
g30
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1572
sS'trials.thisIndex'
p1573
g30
(g80
S'G\x00\x00\x00'
tRp1574
sg44
g30
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1575
sS'trials.thisRepN'
p1576
I0
sg50
g30
(g32
S'\\\x8f\xc2\xf5(\xdc\x11@'
tRp1577
sg27
g11
sS'trials.thisTrialN'
p1578
I71
sg54
g30
(g32
S'\xaeG\xe1z\x14\xee @'
tRp1579
sg17
(lp1580
S'8'
asa(dp1581
g23
g24
sg27
g11
sg28
S'1'
sg25
g26
sg29
g33
sg16
F1454514159.4747369
sa(dp1582
g23
g24
sg27
g11
sg28
S'1'
sg25
g26
sg29
g33
sg16
F1454514169.477819
sa(dp1583
g23
g24
sg27
g11
sg28
S'1'
sg25
g26
sg29
g33
sg16
F1454514169.477875
sasS'loops'
p1584
(lp1585
g1
(cpsychopy.data
TrialHandler
p1586
g3
NtRp1587
(dp1588
S'origin'
p1589
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.01), Thu 24 Sep 2015 11:35:23 AM EDT\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a# from psychopy.hardware.emulator import launchScan\u000aimport time\u000aimport sys\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000aglobal expName\u000aglobal AllowedInputKeys\u000aAllowedInputKeys = ['1', '2','3','4','5','6','7','8','9','down','right']\u000aglobal FullScreenFlag \u000a\u000aFullScreenFlag = True\u000aScreenToUse = 'MacBookPro'\u000aexpName='PartialTrial'\u000a\u000adef TestSomething(subid=9999,visitid=0001):\u000a    expInfo = {u'Visit ID': u'9999', u'Participant ID': u'1'}\u000a    print 'subid is %s'%(subid)\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a    else:\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a    return expInfo\u000a\u000adef PartialTrial(INPUTFILE,subid=9999,visitid=9999):\u000a    #INPUTFILE = 'Optimized60trialsLoads12467_1.xlsx'\u000a    # INPUTFILE = 'TrialListLoads123466_6Repeats_121415_2.csv'\u000a    # INPUTFILE = 'TwoTrials.xlsx'\u000a    IntroTime = 10\u000a    End = 10 # This should be set so that it is at least ten seconds and so the experiment \u000a    # total duration is a multiple of two seconds.\u000a\u000a    MaxLetters = 6\u000a    if MaxLetters == 6:\u000a        SETwrapWidth = 1.5 # The wrap width of text needs to be adjusted based on how manty letters there are\u000a        SETletCycle = 13 # # Spaces are added between letters and this controls the loop which does it\u000a    elif MaxLetters == 7:\u000a        SETwrapWidth = 1.7\u000a        SETletCycle = 15\u000a    expInfo = {u'Visit ID': u'001', u'Participant ID': u''}\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a        if dlg.OK == False: win.close()  # user pressed cancel\u000a    else:\u000a        print "Subid entered is: %s"%(subid)\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a        \u000a    # Store info about the experiment session\u000a\u000a    \u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=True,\u000a        dataFileName=filename)\u000a    #save a log file for detail verbose info\u000a    logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[1366, 768], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor = ScreenToUse, color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'norm')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial"\u000a    trialClock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    \u000a    # THE AIM IS TO \u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=SETwrapWidth, ## Changed from 1.5 because of 7 letters\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=SETwrapWidth,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=SETwrapWidth,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    WaitForScanner = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Waiting for Scanner, press r to advance',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(INPUTFILE),\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a\u000a\u000a    # PRESENT THE SCREEN TO WAIT FOR THE MRI TRIGGER\u000a    #vol = launchScan(win, MR_settings,  mode='Scan')\u000a\u000a    # ########################################################\u000a    # There should be WAITING FOR SCANNER trial here\u000a    # The test2 routine has these parts in it\u000a    #------Prepare to start Routine "ScanWait"-------\u000a    t = 0\u000a    ScanWaitClock = core.Clock()\u000a    ScanWaitClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    ScannerTrigger = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    ScannerTrigger.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    ScanWaitComponents = []\u000a    ScanWaitComponents.append(WaitForScanner)\u000a    ScanWaitComponents.append(ScannerTrigger)\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "ScanWait"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = ScanWaitClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_4* updates\u000a        if t >= 0.0 and WaitForScanner.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            WaitForScanner.tStart = t  # underestimates by a little under one frame\u000a            WaitForScanner.frameNStart = frameN  # exact frame index\u000a            WaitForScanner.setAutoDraw(True)\u000a        \u000a        # *key_resp_3* updates\u000a        if t >= 0.0 and ScannerTrigger.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ScannerTrigger.tStart = t  # underestimates by a little under one frame\u000a            ScannerTrigger.frameNStart = frameN  # exact frame index\u000a            ScannerTrigger.status = STARTED\u000a            # keyboard checking is just starting\u000a            ScannerTrigger.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if ScannerTrigger.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['r','equal'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                ScannerTrigger.keys = theseKeys[-1]  # just the last key pressed\u000a                ScannerTrigger.rt = ScannerTrigger.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ScanWaitComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            \u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "ScanWait"-------\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if ScannerTrigger.keys in ['', [], None]:  # No response was made\u000a       ScannerTrigger.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('ScannerTrigger.keys',ScannerTrigger.keys)\u000a    if ScannerTrigger.keys != None:  # we had a response\u000a        thisExp.addData('ScannerTrigger.rt', ScannerTrigger.rt)\u000a    thisExp.nextEntry()\u000a    # ########################################################\u000a\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a\u000a    # Write out when the experiment begins\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    #------Prepare to start Routine "intro"-------\u000a    t = 0\u000a    introClock = core.Clock()\u000a    introClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(IntroTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    introComponents = []\u000a    introComponents.append(RestCrossHair)\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "intro"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = introClock.getTime()\u000a        \u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_3* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (0.0 + (IntroTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in introComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "intro"-------\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    # ########################################################\u000a\u000a    for thisTrial in trials:\u000a        # Write to the file the time this trial starts\u000a        trials.addData('TrialStartTime',time.time())\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        # ENCODING SET\u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempStimSet = StimSet\u000a        # Letters for space - letter - space - letter ... - space\u000a        StimSet=' '\u000a        for i in tempStimSet:\u000a            StimSet=StimSet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        UpBrackText = ''\u000a        if UpBrack > 0:\u000a            BracketList = list(str(UpBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,SETletCycle,1):   ## Changed from 13 when using 7 letters\u000a                UpBrackText = UpBrackText+' '\u000a            s = list(UpBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            UpBrackText = ''.join(s)\u000a        \u000a        # PROBE \u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempProbeLet = ProbeLet\u000a        # Letters for space - letter - space - letter ... - space\u000a        ProbeLet=' '\u000a        for i in tempProbeLet:\u000a            ProbeLet = ProbeLet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        BotBrackText = ''\u000a        if BotBrack > 0:\u000a            BracketList = list(str(BotBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,SETletCycle,1):   ## Changed from 13 when using 7 letters\u000a                BotBrackText = BotBrackText+' '\u000a            s = list(BotBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            BotBrackText = ''.join(s)\u000a            \u000a        # update component parameters for each repeat\u000a        UpperText.setText(StimSet)\u000a        UpperBrackets.setText(UpBrackText)\u000a        LowerText.setText(ProbeLet)\u000a        LowerBrackets.setText(BotBrackText)\u000a        \u000a        KeyboardResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        KeyboardResp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(TopUpperLine)\u000a        trialComponents.append(UpperText)\u000a        trialComponents.append(UpperBrackets)\u000a        trialComponents.append(BotUpperLine)\u000a        trialComponents.append(TopLowerLine)\u000a        trialComponents.append(LowerText)\u000a        trialComponents.append(LowerBrackets)\u000a        trialComponents.append(BotLowerLine)\u000a        trialComponents.append(TrialCrossHair)\u000a        trialComponents.append(RestCrossHair)\u000a        trialComponents.append(KeyboardResp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            \u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *TopUpperLine* updates\u000a            if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine.frameNStart = frameN  # exact frame index\u000a                TopUpperLine.setAutoDraw(True)\u000a            elif TopUpperLine.status == STARTED and t >= (0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine.setAutoDraw(False)\u000a            \u000a            # *UpperText* updates\u000a            if t >= 0 and UpperText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText.tStart = t  # underestimates by a little under one frame\u000a                UpperText.frameNStart = frameN  # exact frame index\u000a                UpperText.setAutoDraw(True)\u000a            elif UpperText.status == STARTED and t >= (0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets* updates\u000a            if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets.frameNStart = frameN  # exact frame index\u000a                UpperBrackets.setAutoDraw(True)\u000a            elif UpperBrackets.status == STARTED and t >= (0.0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine* updates\u000a            if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine.frameNStart = frameN  # exact frame index\u000a                BotUpperLine.setAutoDraw(True)\u000a            elif BotUpperLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine* updates\u000a            if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine.frameNStart = frameN  # exact frame index\u000a                TopLowerLine.setAutoDraw(True)\u000a            elif TopLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine.setAutoDraw(False)\u000a            \u000a            # *LowerText* updates\u000a            if t >= ProbeStart and LowerText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText.tStart = t  # underestimates by a little under one frame\u000a                LowerText.frameNStart = frameN  # exact frame index\u000a                LowerText.setAutoDraw(True)\u000a            elif LowerText.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets* updates\u000a            if t >= ProbeStart and LowerBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets.frameNStart = frameN  # exact frame index\u000a                LowerBrackets.setAutoDraw(True)\u000a            elif LowerBrackets.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine* updates\u000a            if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine.frameNStart = frameN  # exact frame index\u000a                BotLowerLine.setAutoDraw(True)\u000a            elif BotLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair* updates\u000a            if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair.setAutoDraw(True)\u000a            elif TrialCrossHair.status == STARTED and t >= (0 + (TrialDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= TrialDur and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            elif RestCrossHair.status == STARTED and t >= (TrialDur + (ITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # *KeyboardResp* updates\u000a            if t >= ProbeStart and KeyboardResp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                KeyboardResp.tStart = t  # underestimates by a little under one frame\u000a                KeyboardResp.frameNStart = frameN  # exact frame index\u000a                KeyboardResp.status = STARTED\u000a                # keyboard checking is just starting\u000a                KeyboardResp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif KeyboardResp.status == STARTED and t >= (ProbeStart + (ProbeDurITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                KeyboardResp.status = STOPPED\u000a            if KeyboardResp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    KeyboardResp.keys.extend(theseKeys)  # storing all keys\u000a                    KeyboardResp.rt.append(KeyboardResp.clock.getTime())\u000a                    # was this 'correct'?\u000a                    if (KeyboardResp.keys == str(Correct)) or (KeyboardResp.keys == Correct):\u000a                        KeyboardResp.corr = 1\u000a                    else:\u000a                        KeyboardResp.corr = 0\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(1)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if KeyboardResp.keys in ['', [], None]:  # No response was made\u000a           KeyboardResp.keys=None\u000a           # was no response the correct answer?!\u000a           if str(Correct).lower() == 'none': KeyboardResp.corr = 1  # correct non-response\u000a           else: KeyboardResp.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('KeyboardResp.keys',KeyboardResp.keys)\u000a        trials.addData('KeyboardResp.corr', KeyboardResp.corr)\u000a        if KeyboardResp.keys != None:  # we had a response\u000a            trials.addData('KeyboardResp.rt', KeyboardResp.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    EndTimeClock = core.Clock()\u000a    EndTimeClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(End)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    EndTimeComponents = []\u000a    EndTimeComponents.append(RestCrossHair)\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = EndTimeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        if RestCrossHair.status == STARTED and t >= (0.0 + (End-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in EndTimeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            #win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # ########################################################\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()    \u000a    # completed 1 repeats of 'trials'\u000a    # the Routine "trial" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    win.close()\u000a    #sys.exit()\u000a    return filename\u000a\u000adef PartialTrialFeedback(INPUTFILE,filename,subid=9999,visitid=9999):\u000a    expInfo = {u'Visit ID': u'001', u'Participant ID': u''}\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a        if dlg.OK == False: win.close()  # user pressed cancel\u000a    else:\u000a        print "Subid entered is: %s"%(subid)\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a        \u000a    # Store info about the experiment session\u000a\u000a    \u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    #filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=True,\u000a        dataFileName=filename)\u000a    #save a log file for detail verbose info\u000a    logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=u'testMonitor', color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'use preferences')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial"\u000a    trialClock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=1.7,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=1.7,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=1.5,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    WaitForScanner = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Waiting for Scanner\u005cn Or press r to advance',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    ThankYou = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Merci\u005cnThank you',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    # Initialize components for Routine "Feedback"\u000a    FeedbackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    FeedbackMsg = visual.TextStim(win=win, ori=0, name='FeedbackMsg',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(INPUTFILE),#TrialListShort1#TrialList5Loads6Repeats\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a\u000a\u000a    # PRESENT THE SCREEN TO WAIT FOR THE MRI TRIGGER\u000a    #vol = launchScan(win, MR_settings,  mode='Scan')\u000a\u000a    # ########################################################\u000a    # There should be WAITING FOR SCANNER trial here\u000a    # The test2 routine has these parts in it\u000a    #------Prepare to start Routine "ScanWait"-------\u000a    t = 0\u000a    ScanWaitClock = core.Clock()\u000a    ScanWaitClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    ScannerTrigger = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    ScannerTrigger.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    ScanWaitComponents = []\u000a    ScanWaitComponents.append(WaitForScanner)\u000a    ScanWaitComponents.append(ScannerTrigger)\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "ScanWait"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = ScanWaitClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_4* updates\u000a        if t >= 0.0 and WaitForScanner.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            WaitForScanner.tStart = t  # underestimates by a little under one frame\u000a            WaitForScanner.frameNStart = frameN  # exact frame index\u000a            WaitForScanner.setAutoDraw(True)\u000a        \u000a        # *key_resp_3* updates\u000a        if t >= 0.0 and ScannerTrigger.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ScannerTrigger.tStart = t  # underestimates by a little under one frame\u000a            ScannerTrigger.frameNStart = frameN  # exact frame index\u000a            ScannerTrigger.status = STARTED\u000a            # keyboard checking is just starting\u000a            ScannerTrigger.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if ScannerTrigger.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['5', 'r'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                ScannerTrigger.keys = theseKeys[-1]  # just the last key pressed\u000a                ScannerTrigger.rt = ScannerTrigger.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ScanWaitComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            #core.quit()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "ScanWait"-------\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if ScannerTrigger.keys in ['', [], None]:  # No response was made\u000a       ScannerTrigger.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('ScannerTrigger.keys',ScannerTrigger.keys)\u000a    if ScannerTrigger.keys != None:  # we had a response\u000a        thisExp.addData('ScannerTrigger.rt', ScannerTrigger.rt)\u000a    thisExp.nextEntry()\u000a    # ########################################################\u000a\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a    IntroTime = 5\u000a    # Write out when the experiment begins\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    #------Prepare to start Routine "intro"-------\u000a    t = 0\u000a    introClock = core.Clock()\u000a    introClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(IntroTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    introComponents = []\u000a    introComponents.append(RestCrossHair)\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "intro"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = introClock.getTime()\u000a        \u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_3* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (0.0 + (IntroTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in introComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "intro"-------\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    # ########################################################\u000a\u000a    for thisTrial in trials:\u000a        # Write to the file the time this trial starts\u000a        trials.addData('TrialStartTime',time.time())\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        # ENCODING SET\u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempStimSet = StimSet\u000a        # Letters for space - letter - space - letter ... - space\u000a        StimSet=' '\u000a        for i in tempStimSet:\u000a            StimSet=StimSet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        UpBrackText = ''\u000a        if UpBrack > 0:\u000a            BracketList = list(str(UpBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,13,1):   ## Changed from 13 when using 7 letters\u000a                UpBrackText = UpBrackText+' '\u000a            s = list(UpBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            UpBrackText = ''.join(s)\u000a        \u000a        # PROBE \u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempProbeLet = ProbeLet\u000a        print '%s'%(tempProbeLet)\u000a        # Letters for space - letter - space - letter ... - space\u000a        ProbeLet=' '\u000a        for i in tempProbeLet:\u000a            ProbeLet = ProbeLet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        BotBrackText = ''\u000a        if BotBrack > 0:\u000a            BracketList = list(str(BotBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,13,1):   ## Changed from 13 when using 7 letters\u000a                BotBrackText = BotBrackText+' '\u000a            s = list(BotBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            BotBrackText = ''.join(s)\u000a            \u000a        # update component parameters for each repeat\u000a        UpperText.setText(StimSet)\u000a        UpperBrackets.setText(UpBrackText)\u000a        LowerText.setText(ProbeLet)\u000a        LowerBrackets.setText(BotBrackText)\u000a        \u000a        KeyboardResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        KeyboardResp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(TopUpperLine)\u000a        trialComponents.append(UpperText)\u000a        trialComponents.append(UpperBrackets)\u000a        trialComponents.append(BotUpperLine)\u000a        trialComponents.append(TopLowerLine)\u000a        trialComponents.append(LowerText)\u000a        trialComponents.append(LowerBrackets)\u000a        trialComponents.append(BotLowerLine)\u000a        trialComponents.append(TrialCrossHair)\u000a        trialComponents.append(RestCrossHair)\u000a        trialComponents.append(KeyboardResp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            \u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *TopUpperLine* updates\u000a            if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine.frameNStart = frameN  # exact frame index\u000a                TopUpperLine.setAutoDraw(True)\u000a            elif TopUpperLine.status == STARTED and t >= (0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine.setAutoDraw(False)\u000a            \u000a            # *UpperText* updates\u000a            if t >= 0 and UpperText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText.tStart = t  # underestimates by a little under one frame\u000a                UpperText.frameNStart = frameN  # exact frame index\u000a                UpperText.setAutoDraw(True)\u000a            elif UpperText.status == STARTED and t >= (0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets* updates\u000a            if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets.frameNStart = frameN  # exact frame index\u000a                UpperBrackets.setAutoDraw(True)\u000a            elif UpperBrackets.status == STARTED and t >= (0.0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine* updates\u000a            if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine.frameNStart = frameN  # exact frame index\u000a                BotUpperLine.setAutoDraw(True)\u000a            elif BotUpperLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine* updates\u000a            if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine.frameNStart = frameN  # exact frame index\u000a                TopLowerLine.setAutoDraw(True)\u000a            elif TopLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine.setAutoDraw(False)\u000a            \u000a            # *LowerText* updates\u000a            if t >= ProbeStart and LowerText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText.tStart = t  # underestimates by a little under one frame\u000a                LowerText.frameNStart = frameN  # exact frame index\u000a                LowerText.setAutoDraw(True)\u000a            elif LowerText.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets* updates\u000a            if t >= ProbeStart and LowerBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets.frameNStart = frameN  # exact frame index\u000a                LowerBrackets.setAutoDraw(True)\u000a            elif LowerBrackets.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine* updates\u000a            if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine.frameNStart = frameN  # exact frame index\u000a                BotLowerLine.setAutoDraw(True)\u000a            elif BotLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair* updates\u000a            if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair.setAutoDraw(True)\u000a            elif TrialCrossHair.status == STARTED and t >= (0 + (TrialDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= TrialDur and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            elif RestCrossHair.status == STARTED and t >= (TrialDur + (ITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # *KeyboardResp* updates\u000a            if t >= ProbeStart and KeyboardResp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                KeyboardResp.tStart = t  # underestimates by a little under one frame\u000a                KeyboardResp.frameNStart = frameN  # exact frame index\u000a                KeyboardResp.status = STARTED\u000a                # keyboard checking is just starting\u000a                KeyboardResp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif KeyboardResp.status == STARTED and t >= (ProbeStart + (ProbeDurITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                KeyboardResp.status = STOPPED\u000a            if KeyboardResp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    #KeyboardResp.keys.extend(theseKeys)  # storing all keys\u000a                    KeyboardResp.keys = theseKeys[-1]  # just the last key pressed\u000a                    #KeyboardResp.rt.append(KeyboardResp.clock.getTime())\u000a                    KeyboardResp.rt = KeyboardResp.clock.getTime()\u000a                    # was this 'correct'?\u000a                    # What if the participant responded whenthey were not supposed to?\u000a                    if str(Correct).lower() == 'none':\u000a                        KeyboardResp.corr = -10 # RESPONSE WHEN NONE WAS EXPECTED\u000a                    else:\u000a                        if (KeyboardResp.keys == str(Correct)) or (KeyboardResp.keys == Correct):\u000a                            KeyboardResp.corr = 1 # CORRECT\u000a                        else:\u000a                            KeyboardResp.corr = 0 # INCORRECT\u000a                    # was this 'correct'?\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(1)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if KeyboardResp.keys in ['', [], None]:  # No response was made\u000a           KeyboardResp.keys=None\u000a           # was no response the correct answer?!\u000a           if str(Correct).lower() == 'none': KeyboardResp.corr = 10  # correct non-response\u000a           else: KeyboardResp.corr = -1  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('KeyboardResp.keys',KeyboardResp.keys)\u000a        trials.addData('KeyboardResp.corr', KeyboardResp.corr)\u000a        if KeyboardResp.keys != None:  # we had a response\u000a            trials.addData('KeyboardResp.rt', KeyboardResp.rt)\u000a        thisExp.nextEntry()\u000a        \u000a        \u000a    # ########################################################    \u000a        #------Prepare to start Routine "Feedback"-------\u000a        FeedbackDur = 1.5\u000a        t = 0\u000a        FeedbackClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(FeedbackDur)\u000a        # update component parameters for each repeat\u000a        if KeyboardResp.corr == 1:#stored on last run routine\u000a          msg="Correct! RT=%.3f" %(KeyboardResp.rt)\u000a        elif KeyboardResp.corr == 0:\u000a          msg="Oops! That was wrong"\u000a        elif KeyboardResp.corr == -1:\u000a          msg="No response...miss"\u000a        elif KeyboardResp.corr == 10:\u000a          msg="No response, good!"\u000a        FeedbackMsg.setText(msg)\u000a        # keep track of which components have finished\u000a        FeedbackComponents = []\u000a        FeedbackComponents.append(FeedbackMsg)\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = FeedbackClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *FeedbackMsg* updates\u000a            if t >= 0.0 and FeedbackMsg.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                FeedbackMsg.tStart = t  # underestimates by a little under one frame\u000a                FeedbackMsg.frameNStart = frameN  # exact frame index\u000a                FeedbackMsg.setAutoDraw(True)\u000a            if FeedbackMsg.status == STARTED and t >= (0.0 + (FeedbackDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                FeedbackMsg.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in FeedbackComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback"-------\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a        #------Prepare to start Routine "REST"-------\u000a        t = 0\u000a        RESTClock = core.Clock()\u000a        RESTClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(1.000000)\u000a        # update component parameters for each repeat\u000a        # keep track of which components have finished\u000a        RESTComponents = []\u000a        RESTComponents.append(RestCrossHair)\u000a        for thisComponent in RESTComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "REST"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = RESTClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            if RestCrossHair.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in RESTComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "REST"-------\u000a        for thisComponent in RESTComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        thisExp.nextEntry()\u000a\u000a\u000a    win.flip()\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a    EndTime = 10\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    EndTimeClock = core.Clock()\u000a    EndTimeClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(EndTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    EndTimeComponents = []\u000a    EndTimeComponents.append(RestCrossHair)\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = EndTimeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        if RestCrossHair.status == STARTED and t >= (0.0 + (EndTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in EndTimeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "EndTime"-------\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a            \u000a    # ########################################################        \u000a    # There should be an intro off trial here also\u000a    ThankYouTime = 3\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    ThankYouClock = core.Clock()\u000a    ThankYouClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(ThankYouTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    ThankYouComponents = []\u000a    ThankYouComponents.append(ThankYou)\u000a    for thisComponent in ThankYouComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = ThankYouClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and ThankYou.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ThankYou.tStart = t  # underestimates by a little under one frame\u000a            ThankYou.frameNStart = frameN  # exact frame index\u000a            ThankYou.setAutoDraw(True)\u000a        if ThankYou.status == STARTED and t >= (0.0 + (ThankYouTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            ThankYou.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ThankYouComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "Thank you"-------\u000a    for thisComponent in ThankYouComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)       \u000a    # ########################################################\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()    \u000a    # completed 1 repeats of 'trials'\u000a    win.close()\u000a#    win.close()\u000a\u000adef Instructions():\u000a    # Store info about the experiment session\u000a    expName = u'Instructions'  # from the Builder filename that created this script\u000a    expInfo = {u'session': u'001', u'participant': u''}\u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=False,\u000a        dataFileName=filename)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=u'UbuntuMon', color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'norm')\u000a\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "ButtonPractice"\u000a    ButtonPracticeClock = core.Clock()\u000a    text_28 = visual.TextStim(win=win, ori=0, name='text_28',\u000a        text="First ...\u005cnLet's make sure the buttons work.\u005cnPress the RIGHT INDEX Finger button.",    font='Courier',\u000a        pos=[0,0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    ISI_14 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_14')\u000a    TopUpperLine_14 = visual.Line(win=win, name='TopUpperLine_14',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_14 = visual.TextStim(win=win, ori=0, name='UpperText_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    UpperBrackets_14 = visual.TextStim(win=win, ori=0, name='UpperBrackets_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    BotUpperLine_14 = visual.Line(win=win, name='BotUpperLine_14',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_14 = visual.Line(win=win, name='TopLowerLine_14',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_14 = visual.TextStim(win=win, ori=0, name='LowerText_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    LowerBrackets_14 = visual.TextStim(win=win, ori=0, name='LowerBrackets_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    BotLowerLine_14 = visual.Line(win=win, name='BotLowerLine_14',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_14 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_14',\u000a        text='\u005cn',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    RestCrossHair_14 = visual.TextStim(win=win, ori=0, name='RestCrossHair_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a\u000a    # Initialize components for Routine "Feedback"\u000a    FeedbackClock = core.Clock()\u000a    msg='?????'\u000a    text_25 = visual.TextStim(win=win, ori=0, name='text_25',\u000a        text='default text',    font='Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Initialize components for Routine "ButtonPractice_MIDDLE"\u000a    ButtonPractice_MIDDLEClock = core.Clock()\u000a    text_29 = visual.TextStim(win=win, ori=0, name='text_29',\u000a        text='Press the RIGHT MIDDLE Finger button.',    font='Courier',\u000a        pos=[0,0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    ISI_15 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_15')\u000a    TopUpperLine_15 = visual.Line(win=win, name='TopUpperLine_15',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_15 = visual.TextStim(win=win, ori=0, name='UpperText_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    UpperBrackets_15 = visual.TextStim(win=win, ori=0, name='UpperBrackets_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    BotUpperLine_15 = visual.Line(win=win, name='BotUpperLine_15',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_15 = visual.Line(win=win, name='TopLowerLine_15',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_15 = visual.TextStim(win=win, ori=0, name='LowerText_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    LowerBrackets_15 = visual.TextStim(win=win, ori=0, name='LowerBrackets_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    BotLowerLine_15 = visual.Line(win=win, name='BotLowerLine_15',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_15 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_15',\u000a        text='\u005cn',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    RestCrossHair_15 = visual.TextStim(win=win, ori=0, name='RestCrossHair_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a\u000a    # Initialize components for Routine "Feedback_MIDDLE"\u000a    Feedback_MIDDLEClock = core.Clock()\u000a    msg='?????'\u000a    text_26 = visual.TextStim(win=win, ori=0, name='text_26',\u000a        text='default text',    font=u'Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_2"\u000a    var_6Letters_2Clock = core.Clock()\u000a    text_13 = visual.TextStim(win=win, ori=0, name='text_13',\u000a        text='This is the screen you will see for each trial',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text_16 = visual.TextStim(win=win, ori=0, name='text_16',\u000a        text='With an UPPER Part',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_18 = visual.TextStim(win=win, ori=0, name='text_18',\u000a        text='And a LOWER part',    font='Courier',\u000a        pos=[0,-0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_21 = visual.TextStim(win=win, ori=0, name='text_21',\u000a        text=None,    font='Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_13 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_13')\u000a    TopUpperLine_13 = visual.Line(win=win, name='TopUpperLine_13',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_13 = visual.TextStim(win=win, ori=0, name='UpperText_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_13 = visual.TextStim(win=win, ori=0, name='UpperBrackets_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_13 = visual.Line(win=win, name='BotUpperLine_13',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_13 = visual.Line(win=win, name='TopLowerLine_13',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_13 = visual.TextStim(win=win, ori=0, name='LowerText_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_13 = visual.TextStim(win=win, ori=0, name='LowerBrackets_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_13 = visual.Line(win=win, name='BotLowerLine_13',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_13 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_13',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_13 = visual.TextStim(win=win, ori=0, name='RestCrossHair_13',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_22 = visual.TextStim(win=win, ori=0, name='text_22',\u000a        text='You will also see a cross hair on the screen',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_23 = visual.TextStim(win=win, ori=0, name='text_23',\u000a        text='Either Green',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_24 = visual.TextStim(win=win, ori=0, name='text_24',\u000a        text='Or RED',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_0"\u000a    var_6Letters_0Clock = core.Clock()\u000a    text_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a        text='For this experiment you will see letters at the top of the screen.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.1,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text = visual.TextStim(win=win, ori=0, name='text',\u000a        text='Some of the letters will be enclosed by brackets.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_6 = visual.TextStim(win=win, ori=0, name='text_6',\u000a        text=u'These are the letters to remember.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a        text='The letters will be removed, focus on the green cross hair.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_11 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_11')\u000a    TopUpperLine_11 = visual.Line(win=win, name='TopUpperLine_11',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_11 = visual.TextStim(win=win, ori=0, name='UpperText_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_11 = visual.TextStim(win=win, ori=0, name='UpperBrackets_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_11 = visual.Line(win=win, name='BotUpperLine_11',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_11 = visual.Line(win=win, name='TopLowerLine_11',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_11 = visual.TextStim(win=win, ori=0, name='LowerText_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_11 = visual.TextStim(win=win, ori=0, name='LowerBrackets_11',\u000a        text='  { }        ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_11 = visual.Line(win=win, name='BotLowerLine_11',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_11 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_11',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_11 = visual.TextStim(win=win, ori=0, name='RestCrossHair_11',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_5 = visual.TextStim(win=win, ori=0, name='text_5',\u000a        text='You will then see letters at the bottom.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.1,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a        text='Only one letter will be in brackets.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a    text_8 = visual.TextStim(win=win, ori=0, name='text_8',\u000a        text='You need to decide whether this letter was one that you had to remember.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-18.0)\u000a    text_9 = visual.TextStim(win=win, ori=0, name='text_9',\u000a        text='YES = INDEX finger button\u005cnNO  = MIDDLE finger button',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-19.0)\u000a    text_10 = visual.TextStim(win=win, ori=0, name='text_10',\u000a        text='The trial is then over and the cross hair turns RED.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-20.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_1"\u000a    var_6Letters_1Clock = core.Clock()\u000a    text_11 = visual.TextStim(win=win, ori=0, name='text_11',\u000a        text=u"Let's Repeat",    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_12 = visual.TextStim(win=win, ori=0, name='text_12',\u000a        text='Remember the letters B and C',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_14 = visual.TextStim(win=win, ori=0, name='text_14',\u000a        text=u'Letters are removed',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    ISI_12 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_12')\u000a    TopUpperLine_12 = visual.Line(win=win, name='TopUpperLine_12',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_12 = visual.TextStim(win=win, ori=0, name='UpperText_12',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-5.0)\u000a    UpperBrackets_12 = visual.TextStim(win=win, ori=0, name='UpperBrackets_12',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    BotUpperLine_12 = visual.Line(win=win, name='BotUpperLine_12',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_12 = visual.Line(win=win, name='TopLowerLine_12',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_12 = visual.TextStim(win=win, ori=0, name='LowerText_12',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    LowerBrackets_12 = visual.TextStim(win=win, ori=0, name='LowerBrackets_12',\u000a        text='  { }        ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    BotLowerLine_12 = visual.Line(win=win, name='BotLowerLine_12',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_12 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_12',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-12.0)\u000a    RestCrossHair_12 = visual.TextStim(win=win, ori=0, name='RestCrossHair_12',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    text_17 = visual.TextStim(win=win, ori=0, name='text_17',\u000a        text=u'Are you trying to remember the letter b?',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_19 = visual.TextStim(win=win, ori=0, name='text_19',\u000a        text=u'Yes you are. You would press the INDEX finger button as quickly as possible.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_20 = visual.TextStim(win=win, ori=0, name='text_20',\u000a        text=u'The trial is over and the cross hair turns RED.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "DemoTrialRealTimes"\u000a    DemoTrialRealTimesClock = core.Clock()\u000a    text_44 = visual.TextStim(win=win, ori=0, name='text_44',\u000a        text=u"Let's repeat at the true pace",    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_45 = visual.TextStim(win=win, ori=0, name='text_45',\u000a        text=u'Remember the letters B and C',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_46 = visual.TextStim(win=win, ori=0, name='text_46',\u000a        text=u'Letters are removed',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    ISI_18 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_18')\u000a    TopUpperLine_18 = visual.Line(win=win, name='TopUpperLine_18',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_18 = visual.TextStim(win=win, ori=0, name='UpperText_18',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-5.0)\u000a    UpperBrackets_18 = visual.TextStim(win=win, ori=0, name='UpperBrackets_18',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    BotUpperLine_18 = visual.Line(win=win, name='BotUpperLine_18',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_18 = visual.Line(win=win, name='TopLowerLine_18',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_17 = visual.TextStim(win=win, ori=0, name='LowerText_17',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    LowerBrackets_17 = visual.TextStim(win=win, ori=0, name='LowerBrackets_17',\u000a        text=u'  { }        ',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    BotLowerLine_18 = visual.Line(win=win, name='BotLowerLine_18',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_18 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_18',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-12.0)\u000a    RestCrossHair_18 = visual.TextStim(win=win, ori=0, name='RestCrossHair_18',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-13.0)\u000a    text_48 = visual.TextStim(win=win, ori=0, name='text_48',\u000a        text=u'Respond as quickly as possible',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_49 = visual.TextStim(win=win, ori=0, name='text_49',\u000a        text=u'The trial is over and the cross hair turns RED.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-16.0)\u000a\u000a    # Initialize components for Routine "NumLettersToRem"\u000a    NumLettersToRemClock = core.Clock()\u000a    text_15 = visual.TextStim(win=win, ori=0, name='text_15',\u000a        text='The number of letters to remember',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text_33 = visual.TextStim(win=win, ori=0, name='text_33',\u000a        text='Varies between 1 and 6',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_34 = visual.TextStim(win=win, ori=0, name='text_34',\u000a        text='There will always be six letters presented',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a        text='It is the brackets that indicate which letters to remember.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    text_35 = visual.TextStim(win=win, ori=0, name='text_35',\u000a        text='Here are some examples',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    UpBrack1 = visual.TextStim(win=win, ori=0, name='UpBrack1',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-5.0)\u000a    ISI_17 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_17')\u000a    TopUpperLine_17 = visual.Line(win=win, name='TopUpperLine_17',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_17 = visual.TextStim(win=win, ori=0, name='UpperText_17',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    UpperBrackets_17 = visual.TextStim(win=win, ori=0, name='UpperBrackets_17',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    BotUpperLine_17 = visual.Line(win=win, name='BotUpperLine_17',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_17 = visual.Line(win=win, name='TopLowerLine_17',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    BotLowerLine_17 = visual.Line(win=win, name='BotLowerLine_17',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_17 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_17',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_17 = visual.TextStim(win=win, ori=0, name='RestCrossHair_17',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    UpBrack2 = visual.TextStim(win=win, ori=0, name='UpBrack2',\u000a        text='{   }        ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    UpBrack3 = visual.TextStim(win=win, ori=0, name='UpBrack3',\u000a        text='      {     }',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='Yellow', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    UpBrack4 = visual.TextStim(win=win, ori=0, name='UpBrack4',\u000a        text='  {       }  ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a    UpBrack5 = visual.TextStim(win=win, ori=0, name='UpBrack5',\u000a        text='{         }  ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-18.0)\u000a    UpBrack6 = visual.TextStim(win=win, ori=0, name='UpBrack6',\u000a        text=u'{           }',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-19.0)\u000a    text_38 = visual.TextStim(win=win, ori=0, name='text_38',\u000a        text=u'One letter',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-20.0)\u000a    text_39 = visual.TextStim(win=win, ori=0, name='text_39',\u000a        text=u'Two letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-21.0)\u000a    text_40 = visual.TextStim(win=win, ori=0, name='text_40',\u000a        text=u'Three letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-22.0)\u000a    text_41 = visual.TextStim(win=win, ori=0, name='text_41',\u000a        text=u'Four letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-23.0)\u000a    text_42 = visual.TextStim(win=win, ori=0, name='text_42',\u000a        text=u'Five letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-24.0)\u000a    text_43 = visual.TextStim(win=win, ori=0, name='text_43',\u000a        text=u'Six letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-25.0)\u000a\u000a    # Initialize components for Routine "TrialParts_1"\u000a    TrialParts_1Clock = core.Clock()\u000a    text_27 = visual.TextStim(win=win, ori=0, name='text_27',\u000a        text=u'To help with the analysis of the brain data.\u005cnSome trials are PARTIAL.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_30 = visual.TextStim(win=win, ori=0, name='text_30',\u000a        text='All trials will have a set of letters to study.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_31 = visual.TextStim(win=win, ori=0, name='text_31',\u000a        text='Some will not require a response',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_32 = visual.TextStim(win=win, ori=0, name='text_32',\u000a        text='Some will have no delay between the letters to study and the response.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_16 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_16')\u000a    TopUpperLine_16 = visual.Line(win=win, name='TopUpperLine_16',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_16 = visual.TextStim(win=win, ori=0, name='UpperText_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_16 = visual.TextStim(win=win, ori=0, name='UpperBrackets_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_16 = visual.Line(win=win, name='BotUpperLine_16',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_16 = visual.Line(win=win, name='TopLowerLine_16',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_16 = visual.TextStim(win=win, ori=0, name='LowerText_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_16 = visual.TextStim(win=win, ori=0, name='LowerBrackets_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_16 = visual.Line(win=win, name='BotLowerLine_16',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_16 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_16 = visual.TextStim(win=win, ori=0, name='RestCrossHair_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_36 = visual.TextStim(win=win, ori=0, name='text_36',\u000a        text='What is important is that when the crosshair turns RED. The trial is over.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_37 = visual.TextStim(win=win, ori=0, name='text_37',\u000a        text='Try to forget any of the studied letters and wait for the next trial',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_50 = visual.TextStim(win=win, ori=0, name='text_50',\u000a        text=u'Here is an example trial with feedback.\u005cnRemember respond as quickly as possible.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "trial5_2"\u000a    trial5_2Clock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'      { }    ',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Initialize components for Routine "TrialFeedBack"\u000a    TrialFeedBackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    text_47 = visual.TextStim(win=win, ori=0, name='text_47',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=10, method='sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a    for thisTrial in trials:\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "ButtonPractice"-------\u000a        t = 0\u000a        ButtonPracticeClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(120.000000)\u000a        # update component parameters for each repeat\u000a        UpperText_14.setText('')\u000a        UpperBrackets_14.setText('')\u000a        LowerText_14.setText('')\u000a        key_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        ButtonPracticeComponents = []\u000a        ButtonPracticeComponents.append(text_28)\u000a        ButtonPracticeComponents.append(ISI_14)\u000a        ButtonPracticeComponents.append(TopUpperLine_14)\u000a        ButtonPracticeComponents.append(UpperText_14)\u000a        ButtonPracticeComponents.append(UpperBrackets_14)\u000a        ButtonPracticeComponents.append(BotUpperLine_14)\u000a        ButtonPracticeComponents.append(TopLowerLine_14)\u000a        ButtonPracticeComponents.append(LowerText_14)\u000a        ButtonPracticeComponents.append(LowerBrackets_14)\u000a        ButtonPracticeComponents.append(BotLowerLine_14)\u000a        ButtonPracticeComponents.append(TrialCrossHair_14)\u000a        ButtonPracticeComponents.append(RestCrossHair_14)\u000a        ButtonPracticeComponents.append(key_resp_2)\u000a        for thisComponent in ButtonPracticeComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "ButtonPractice"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = ButtonPracticeClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_28* updates\u000a            if t >= 0 and text_28.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_28.tStart = t  # underestimates by a little under one frame\u000a                text_28.frameNStart = frameN  # exact frame index\u000a                text_28.setAutoDraw(True)\u000a            elif text_28.status == STARTED and t >= (0 + (60-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_28.setAutoDraw(False)\u000a            \u000a            # *TopUpperLine_14* updates\u000a            if t >= 0 and TopUpperLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine_14.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine_14.frameNStart = frameN  # exact frame index\u000a                TopUpperLine_14.setAutoDraw(True)\u000a            elif TopUpperLine_14.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine_14.setAutoDraw(False)\u000a            \u000a            # *UpperText_14* updates\u000a            if t >= 0 and UpperText_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText_14.tStart = t  # underestimates by a little under one frame\u000a                UpperText_14.frameNStart = frameN  # exact frame index\u000a                UpperText_14.setAutoDraw(True)\u000a            elif UpperText_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText_14.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets_14* updates\u000a            if t >= 0 and UpperBrackets_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets_14.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets_14.frameNStart = frameN  # exact frame index\u000a                UpperBrackets_14.setAutoDraw(True)\u000a            elif UpperBrackets_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets_14.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine_14* updates\u000a            if t >= 0.0 and BotUpperLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine_14.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine_14.frameNStart = frameN  # exact frame index\u000a                BotUpperLine_14.setAutoDraw(True)\u000a            elif BotUpperLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine_14.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine_14* updates\u000a            if t >= 0.0 and TopLowerLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine_14.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine_14.frameNStart = frameN  # exact frame index\u000a                TopLowerLine_14.setAutoDraw(True)\u000a            elif TopLowerLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine_14.setAutoDraw(False)\u000a            \u000a            # *LowerText_14* updates\u000a            if t >= 0 and LowerText_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText_14.tStart = t  # underestimates by a little under one frame\u000a                LowerText_14.frameNStart = frameN  # exact frame index\u000a                LowerText_14.setAutoDraw(True)\u000a            elif LowerText_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText_14.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets_14* updates\u000a            if t >= 0 and LowerBrackets_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets_14.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets_14.frameNStart = frameN  # exact frame index\u000a                LowerBrackets_14.setAutoDraw(True)\u000a            elif LowerBrackets_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets_14.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine_14* updates\u000a            if t >= 0.0 and BotLowerLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine_14.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine_14.frameNStart = frameN  # exact frame index\u000a                BotLowerLine_14.setAutoDraw(True)\u000a            elif BotLowerLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine_14.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair_14* updates\u000a            if t >= 0 and TrialCrossHair_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair_14.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair_14.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair_14.setAutoDraw(True)\u000a            elif TrialCrossHair_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair_14.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair_14* updates\u000a            if t >= 0 and RestCrossHair_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair_14.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair_14.frameNStart = frameN  # exact frame index\u000a                RestCrossHair_14.setAutoDraw(True)\u000a            elif RestCrossHair_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair_14.setAutoDraw(False)\u000a            \u000a            # *key_resp_2* updates\u000a            if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_2.tStart = t  # underestimates by a little under one frame\u000a                key_resp_2.frameNStart = frameN  # exact frame index\u000a                key_resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif key_resp_2.status == STARTED and t >= (0.0 + (60-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_2.status = STOPPED\u000a            if key_resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8', '9','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_2.rt = key_resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_2.keys == str('6')) or (key_resp_2.keys == 'down'):\u000a                        key_resp_2.corr = 1\u000a                    else:\u000a                        key_resp_2.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            # *ISI_14* period\u000a            if t >= 0.0 and ISI_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI_14.tStart = t  # underestimates by a little under one frame\u000a                ISI_14.frameNStart = frameN  # exact frame index\u000a                ISI_14.start(1)\u000a            elif ISI_14.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI_14.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in ButtonPracticeComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                #win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "ButtonPractice"-------\u000a        for thisComponent in ButtonPracticeComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_2.keys in ['', [], None]:  # No response was made\u000a           key_resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str('6').lower() == 'none': key_resp_2.corr = 1  # correct non-response\u000a           else: key_resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('key_resp_2.keys',key_resp_2.keys)\u000a        trials.addData('key_resp_2.corr', key_resp_2.corr)\u000a        if key_resp_2.keys != None:  # we had a response\u000a            trials.addData('key_resp_2.rt', key_resp_2.rt)\u000a        \u000a        #------Prepare to start Routine "Feedback"-------\u000a        t = 0\u000a        FeedbackClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        if len(key_resp_2.keys)<1:\u000a            msg="Please press the RIGHT INDEX Finger button"\u000a            trials.finished = Falses\u000a        elif key_resp_2.corr:#stored on last run routine\u000a            msg="Correct! That button indicates a YES response." \u000a            trials.finished = True\u000a        else:\u000a            msg="Oops! Wrong button, please try again."\u000a            trials.finished = False\u000a        text_25.setText(msg)\u000a        # keep track of which components have finished\u000a        FeedbackComponents = []\u000a        FeedbackComponents.append(text_25)\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = FeedbackClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_25* updates\u000a            if t >= 0.0 and text_25.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_25.tStart = t  # underestimates by a little under one frame\u000a                text_25.frameNStart = frameN  # exact frame index\u000a                text_25.setAutoDraw(True)\u000a            elif text_25.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_25.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in FeedbackComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                \u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback"-------\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 10 repeats of 'trials'\u000a\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials_2 = data.TrialHandler(nReps=10, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='trials_2')\u000a    thisExp.addLoop(trials_2)  # add the loop to the experiment\u000a    thisTrial_2 = trials_2.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_2.rgb)\u000a    if thisTrial_2 != None:\u000a        for paramName in thisTrial_2.keys():\u000a            exec(paramName + '= thisTrial_2.' + paramName)\u000a\u000a    for thisTrial_2 in trials_2:\u000a        currentLoop = trials_2\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_2.rgb)\u000a        if thisTrial_2 != None:\u000a            for paramName in thisTrial_2.keys():\u000a                exec(paramName + '= thisTrial_2.' + paramName)\u000a        \u000a        #------Prepare to start Routine "ButtonPractice_MIDDLE"-------\u000a        t = 0\u000a        ButtonPractice_MIDDLEClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(20.000000)\u000a        # update component parameters for each repeat\u000a        UpperText_15.setText('')\u000a        UpperBrackets_15.setText('')\u000a        LowerText_15.setText('')\u000a        key_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_3.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        ButtonPractice_MIDDLEComponents = []\u000a        ButtonPractice_MIDDLEComponents.append(text_29)\u000a        ButtonPractice_MIDDLEComponents.append(ISI_15)\u000a        ButtonPractice_MIDDLEComponents.append(TopUpperLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(UpperText_15)\u000a        ButtonPractice_MIDDLEComponents.append(UpperBrackets_15)\u000a        ButtonPractice_MIDDLEComponents.append(BotUpperLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(TopLowerLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(LowerText_15)\u000a        ButtonPractice_MIDDLEComponents.append(LowerBrackets_15)\u000a        ButtonPractice_MIDDLEComponents.append(BotLowerLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(TrialCrossHair_15)\u000a        ButtonPractice_MIDDLEComponents.append(RestCrossHair_15)\u000a        ButtonPractice_MIDDLEComponents.append(key_resp_3)\u000a        for thisComponent in ButtonPractice_MIDDLEComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "ButtonPractice_MIDDLE"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = ButtonPractice_MIDDLEClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_29* updates\u000a            if t >= 0 and text_29.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_29.tStart = t  # underestimates by a little under one frame\u000a                text_29.frameNStart = frameN  # exact frame index\u000a                text_29.setAutoDraw(True)\u000a            elif text_29.status == STARTED and t >= (0 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_29.setAutoDraw(False)\u000a            \u000a            # *TopUpperLine_15* updates\u000a            if t >= 0 and TopUpperLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine_15.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine_15.frameNStart = frameN  # exact frame index\u000a                TopUpperLine_15.setAutoDraw(True)\u000a            elif TopUpperLine_15.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine_15.setAutoDraw(False)\u000a            \u000a            # *UpperText_15* updates\u000a            if t >= 0 and UpperText_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText_15.tStart = t  # underestimates by a little under one frame\u000a                UpperText_15.frameNStart = frameN  # exact frame index\u000a                UpperText_15.setAutoDraw(True)\u000a            elif UpperText_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText_15.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets_15* updates\u000a            if t >= 0 and UpperBrackets_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets_15.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets_15.frameNStart = frameN  # exact frame index\u000a                UpperBrackets_15.setAutoDraw(True)\u000a            elif UpperBrackets_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets_15.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine_15* updates\u000a            if t >= 0.0 and BotUpperLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine_15.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine_15.frameNStart = frameN  # exact frame index\u000a                BotUpperLine_15.setAutoDraw(True)\u000a            elif BotUpperLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine_15.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine_15* updates\u000a            if t >= 0.0 and TopLowerLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine_15.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine_15.frameNStart = frameN  # exact frame index\u000a                TopLowerLine_15.setAutoDraw(True)\u000a            elif TopLowerLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine_15.setAutoDraw(False)\u000a            \u000a            # *LowerText_15* updates\u000a            if t >= 0 and LowerText_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText_15.tStart = t  # underestimates by a little under one frame\u000a                LowerText_15.frameNStart = frameN  # exact frame index\u000a                LowerText_15.setAutoDraw(True)\u000a            elif LowerText_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText_15.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets_15* updates\u000a            if t >= 0 and LowerBrackets_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets_15.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets_15.frameNStart = frameN  # exact frame index\u000a                LowerBrackets_15.setAutoDraw(True)\u000a            elif LowerBrackets_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets_15.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine_15* updates\u000a            if t >= 0.0 and BotLowerLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine_15.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine_15.frameNStart = frameN  # exact frame index\u000a                BotLowerLine_15.setAutoDraw(True)\u000a            elif BotLowerLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine_15.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair_15* updates\u000a            if t >= 0 and TrialCrossHair_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair_15.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair_15.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair_15.setAutoDraw(True)\u000a            elif TrialCrossHair_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair_15.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair_15* updates\u000a            if t >= 0 and RestCrossHair_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair_15.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair_15.frameNStart = frameN  # exact frame index\u000a                RestCrossHair_15.setAutoDraw(True)\u000a            elif RestCrossHair_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair_15.setAutoDraw(False)\u000a            \u000a            # *key_resp_3* updates\u000a            if t >= 0.0 and key_resp_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_3.tStart = t  # underestimates by a little under one frame\u000a                key_resp_3.frameNStart = frameN  # exact frame index\u000a                key_resp_3.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_3.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif key_resp_3.status == STARTED and t >= (0.0 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_3.status = STOPPED\u000a            if key_resp_3.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8', '9','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_3.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_3.rt = key_resp_3.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_3.keys == str('7')) or (key_resp_3.keys == 'right'):\u000a                        key_resp_3.corr = 1\u000a                    else:\u000a                        key_resp_3.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            # *ISI_15* period\u000a            if t >= 0.0 and ISI_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI_15.tStart = t  # underestimates by a little under one frame\u000a                ISI_15.frameNStart = frameN  # exact frame index\u000a                ISI_15.start(1)\u000a            elif ISI_15.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI_15.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in ButtonPractice_MIDDLEComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "ButtonPractice_MIDDLE"-------\u000a        for thisComponent in ButtonPractice_MIDDLEComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_3.keys in ['', [], None]:  # No response was made\u000a           key_resp_3.keys=None\u000a           # was no response the correct answer?!\u000a           if str('7').lower() == 'none': key_resp_3.corr = 1  # correct non-response\u000a           else: key_resp_3.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials_2 (TrialHandler)\u000a        trials_2.addData('key_resp_3.keys',key_resp_3.keys)\u000a        trials_2.addData('key_resp_3.corr', key_resp_3.corr)\u000a        if key_resp_3.keys != None:  # we had a response\u000a            trials_2.addData('key_resp_3.rt', key_resp_3.rt)\u000a        \u000a        #------Prepare to start Routine "Feedback_MIDDLE"-------\u000a        t = 0\u000a        Feedback_MIDDLEClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        if len(key_resp_3.keys)<1:\u000a            msg="Please press the RIGHT MIDDLE Finger button"\u000a            trials_2.finished = Falses\u000a        elif key_resp_3.corr:#stored on last run routine\u000a            msg="Good! That button indicates a NO response." \u000a            trials_2.finished = True\u000a        else:\u000a            msg="Oops! Wrong button, please try again."\u000a            trials_2.finished = False\u000a        text_26.setText(msg)\u000a        # keep track of which components have finished\u000a        Feedback_MIDDLEComponents = []\u000a        Feedback_MIDDLEComponents.append(text_26)\u000a        for thisComponent in Feedback_MIDDLEComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback_MIDDLE"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = Feedback_MIDDLEClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_26* updates\u000a            if t >= 0.0 and text_26.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_26.tStart = t  # underestimates by a little under one frame\u000a                text_26.frameNStart = frameN  # exact frame index\u000a                text_26.setAutoDraw(True)\u000a            elif text_26.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_26.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Feedback_MIDDLEComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback_MIDDLE"-------\u000a        for thisComponent in Feedback_MIDDLEComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 10 repeats of 'trials_2'\u000a\u000a\u000a    #------Prepare to start Routine "var_6Letters_2"-------\u000a    t = 0\u000a    var_6Letters_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(20.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_13.setText('')\u000a    UpperBrackets_13.setText('')\u000a    LowerText_13.setText('')\u000a    # keep track of which components have finished\u000a    var_6Letters_2Components = []\u000a    var_6Letters_2Components.append(text_13)\u000a    var_6Letters_2Components.append(text_16)\u000a    var_6Letters_2Components.append(text_18)\u000a    var_6Letters_2Components.append(text_21)\u000a    var_6Letters_2Components.append(ISI_13)\u000a    var_6Letters_2Components.append(TopUpperLine_13)\u000a    var_6Letters_2Components.append(UpperText_13)\u000a    var_6Letters_2Components.append(UpperBrackets_13)\u000a    var_6Letters_2Components.append(BotUpperLine_13)\u000a    var_6Letters_2Components.append(TopLowerLine_13)\u000a    var_6Letters_2Components.append(LowerText_13)\u000a    var_6Letters_2Components.append(LowerBrackets_13)\u000a    var_6Letters_2Components.append(BotLowerLine_13)\u000a    var_6Letters_2Components.append(TrialCrossHair_13)\u000a    var_6Letters_2Components.append(RestCrossHair_13)\u000a    var_6Letters_2Components.append(text_22)\u000a    var_6Letters_2Components.append(text_23)\u000a    var_6Letters_2Components.append(text_24)\u000a    for thisComponent in var_6Letters_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_13* updates\u000a        if t >= 0.0 and text_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_13.tStart = t  # underestimates by a little under one frame\u000a            text_13.frameNStart = frameN  # exact frame index\u000a            text_13.setAutoDraw(True)\u000a        elif text_13.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_13.setAutoDraw(False)\u000a        \u000a        # *text_16* updates\u000a        if t >= 3 and text_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_16.tStart = t  # underestimates by a little under one frame\u000a            text_16.frameNStart = frameN  # exact frame index\u000a            text_16.setAutoDraw(True)\u000a        elif text_16.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_16.setAutoDraw(False)\u000a        \u000a        # *text_18* updates\u000a        if t >= 6 and text_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_18.tStart = t  # underestimates by a little under one frame\u000a            text_18.frameNStart = frameN  # exact frame index\u000a            text_18.setAutoDraw(True)\u000a        elif text_18.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_18.setAutoDraw(False)\u000a        \u000a        # *text_21* updates\u000a        if t >= 0 and text_21.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_21.tStart = t  # underestimates by a little under one frame\u000a            text_21.frameNStart = frameN  # exact frame index\u000a            text_21.setAutoDraw(True)\u000a        elif text_21.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_21.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_13* updates\u000a        if t >= 0 and TopUpperLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_13.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_13.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_13.setAutoDraw(True)\u000a        elif TopUpperLine_13.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_13.setAutoDraw(False)\u000a        \u000a        # *UpperText_13* updates\u000a        if t >= 0 and UpperText_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_13.tStart = t  # underestimates by a little under one frame\u000a            UpperText_13.frameNStart = frameN  # exact frame index\u000a            UpperText_13.setAutoDraw(True)\u000a        elif UpperText_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_13.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_13* updates\u000a        if t >= 0 and UpperBrackets_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_13.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_13.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_13.setAutoDraw(True)\u000a        elif UpperBrackets_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_13.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_13* updates\u000a        if t >= 0.0 and BotUpperLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_13.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_13.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_13.setAutoDraw(True)\u000a        elif BotUpperLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_13.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_13* updates\u000a        if t >= 0.0 and TopLowerLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_13.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_13.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_13.setAutoDraw(True)\u000a        elif TopLowerLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_13.setAutoDraw(False)\u000a        \u000a        # *LowerText_13* updates\u000a        if t >= 0 and LowerText_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_13.tStart = t  # underestimates by a little under one frame\u000a            LowerText_13.frameNStart = frameN  # exact frame index\u000a            LowerText_13.setAutoDraw(True)\u000a        elif LowerText_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_13.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_13* updates\u000a        if t >= 0 and LowerBrackets_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_13.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_13.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_13.setAutoDraw(True)\u000a        elif LowerBrackets_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_13.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_13* updates\u000a        if t >= 0.0 and BotLowerLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_13.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_13.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_13.setAutoDraw(True)\u000a        elif BotLowerLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_13.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_13* updates\u000a        if t >= 12 and TrialCrossHair_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_13.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_13.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_13.setAutoDraw(True)\u000a        elif TrialCrossHair_13.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_13.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_13* updates\u000a        if t >= 15 and RestCrossHair_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_13.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_13.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_13.setAutoDraw(True)\u000a        elif RestCrossHair_13.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_13.setAutoDraw(False)\u000a        \u000a        # *text_22* updates\u000a        if t >= 9 and text_22.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_22.tStart = t  # underestimates by a little under one frame\u000a            text_22.frameNStart = frameN  # exact frame index\u000a            text_22.setAutoDraw(True)\u000a        elif text_22.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_22.setAutoDraw(False)\u000a        \u000a        # *text_23* updates\u000a        if t >= 12 and text_23.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_23.tStart = t  # underestimates by a little under one frame\u000a            text_23.frameNStart = frameN  # exact frame index\u000a            text_23.setAutoDraw(True)\u000a        elif text_23.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_23.setAutoDraw(False)\u000a        \u000a        # *text_24* updates\u000a        if t >= 15 and text_24.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_24.tStart = t  # underestimates by a little under one frame\u000a            text_24.frameNStart = frameN  # exact frame index\u000a            text_24.setAutoDraw(True)\u000a        elif text_24.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_24.setAutoDraw(False)\u000a        # *ISI_13* period\u000a        if t >= 0.0 and ISI_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_13.tStart = t  # underestimates by a little under one frame\u000a            ISI_13.frameNStart = frameN  # exact frame index\u000a            ISI_13.start(1)\u000a        elif ISI_13.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_13.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_2"-------\u000a    for thisComponent in var_6Letters_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "var_6Letters_0"-------\u000a    t = 0\u000a    var_6Letters_0Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(30.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_11.setText(' A B C D E F ')\u000a    UpperBrackets_11.setText('  {   }      ')\u000a    LowerText_11.setText(' a b c d e f ')\u000a    KeyboardResp_11 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_11.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    var_6Letters_0Components = []\u000a    var_6Letters_0Components.append(text_2)\u000a    var_6Letters_0Components.append(text)\u000a    var_6Letters_0Components.append(text_6)\u000a    var_6Letters_0Components.append(text_4)\u000a    var_6Letters_0Components.append(ISI_11)\u000a    var_6Letters_0Components.append(TopUpperLine_11)\u000a    var_6Letters_0Components.append(UpperText_11)\u000a    var_6Letters_0Components.append(UpperBrackets_11)\u000a    var_6Letters_0Components.append(BotUpperLine_11)\u000a    var_6Letters_0Components.append(TopLowerLine_11)\u000a    var_6Letters_0Components.append(LowerText_11)\u000a    var_6Letters_0Components.append(LowerBrackets_11)\u000a    var_6Letters_0Components.append(BotLowerLine_11)\u000a    var_6Letters_0Components.append(TrialCrossHair_11)\u000a    var_6Letters_0Components.append(RestCrossHair_11)\u000a    var_6Letters_0Components.append(KeyboardResp_11)\u000a    var_6Letters_0Components.append(text_5)\u000a    var_6Letters_0Components.append(text_7)\u000a    var_6Letters_0Components.append(text_8)\u000a    var_6Letters_0Components.append(text_9)\u000a    var_6Letters_0Components.append(text_10)\u000a    for thisComponent in var_6Letters_0Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_0"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_0Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_2* updates\u000a        if t >= 0.0 and text_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_2.tStart = t  # underestimates by a little under one frame\u000a            text_2.frameNStart = frameN  # exact frame index\u000a            text_2.setAutoDraw(True)\u000a        elif text_2.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_2.setAutoDraw(False)\u000a        \u000a        # *text* updates\u000a        if t >= 3 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        elif text.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # *text_6* updates\u000a        if t >= 6 and text_6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_6.tStart = t  # underestimates by a little under one frame\u000a            text_6.frameNStart = frameN  # exact frame index\u000a            text_6.setAutoDraw(True)\u000a        elif text_6.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_6.setAutoDraw(False)\u000a        \u000a        # *text_4* updates\u000a        if t >= 9 and text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_4.tStart = t  # underestimates by a little under one frame\u000a            text_4.frameNStart = frameN  # exact frame index\u000a            text_4.setAutoDraw(True)\u000a        elif text_4.status == STARTED and t >= (9 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_4.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_11* updates\u000a        if t >= 0 and TopUpperLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_11.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_11.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_11.setAutoDraw(True)\u000a        elif TopUpperLine_11.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_11.setAutoDraw(False)\u000a        \u000a        # *UpperText_11* updates\u000a        if t >= 0 and UpperText_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_11.tStart = t  # underestimates by a little under one frame\u000a            UpperText_11.frameNStart = frameN  # exact frame index\u000a            UpperText_11.setAutoDraw(True)\u000a        elif UpperText_11.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_11.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_11* updates\u000a        if t >= 3 and UpperBrackets_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_11.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_11.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_11.setAutoDraw(True)\u000a        elif UpperBrackets_11.status == STARTED and t >= (3 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_11.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_11* updates\u000a        if t >= 0.0 and BotUpperLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_11.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_11.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_11.setAutoDraw(True)\u000a        elif BotUpperLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_11.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_11* updates\u000a        if t >= 0.0 and TopLowerLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_11.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_11.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_11.setAutoDraw(True)\u000a        elif TopLowerLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_11.setAutoDraw(False)\u000a        \u000a        # *LowerText_11* updates\u000a        if t >= 14 and LowerText_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_11.tStart = t  # underestimates by a little under one frame\u000a            LowerText_11.frameNStart = frameN  # exact frame index\u000a            LowerText_11.setAutoDraw(True)\u000a        elif LowerText_11.status == STARTED and t >= (14 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_11.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_11* updates\u000a        if t >= 17 and LowerBrackets_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_11.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_11.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_11.setAutoDraw(True)\u000a        elif LowerBrackets_11.status == STARTED and t >= (17 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_11.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_11* updates\u000a        if t >= 0.0 and BotLowerLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_11.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_11.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_11.setAutoDraw(True)\u000a        elif BotLowerLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_11.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_11* updates\u000a        if t >= 0 and TrialCrossHair_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_11.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_11.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_11.setAutoDraw(True)\u000a        elif TrialCrossHair_11.status == STARTED and t >= (0 + (26-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_11.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_11* updates\u000a        if t >= 26 and RestCrossHair_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_11.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_11.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_11.setAutoDraw(True)\u000a        elif RestCrossHair_11.status == STARTED and t >= (26 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_11.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_11* updates\u000a        if t >= 0 and KeyboardResp_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_11.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_11.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_11.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_11.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_11.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_11.status = STOPPED\u000a        if KeyboardResp_11.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_11.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_11.rt.append(KeyboardResp_11.clock.getTime())\u000a        \u000a        # *text_5* updates\u000a        if t >= 14 and text_5.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_5.tStart = t  # underestimates by a little under one frame\u000a            text_5.frameNStart = frameN  # exact frame index\u000a            text_5.setAutoDraw(True)\u000a        elif text_5.status == STARTED and t >= (14 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_5.setAutoDraw(False)\u000a        \u000a        # *text_7* updates\u000a        if t >= 17 and text_7.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_7.tStart = t  # underestimates by a little under one frame\u000a            text_7.frameNStart = frameN  # exact frame index\u000a            text_7.setAutoDraw(True)\u000a        elif text_7.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_7.setAutoDraw(False)\u000a        \u000a        # *text_8* updates\u000a        if t >= 20 and text_8.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_8.tStart = t  # underestimates by a little under one frame\u000a            text_8.frameNStart = frameN  # exact frame index\u000a            text_8.setAutoDraw(True)\u000a        elif text_8.status == STARTED and t >= (20 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_8.setAutoDraw(False)\u000a        \u000a        # *text_9* updates\u000a        if t >= 23 and text_9.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_9.tStart = t  # underestimates by a little under one frame\u000a            text_9.frameNStart = frameN  # exact frame index\u000a            text_9.setAutoDraw(True)\u000a        elif text_9.status == STARTED and t >= (23 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_9.setAutoDraw(False)\u000a        \u000a        # *text_10* updates\u000a        if t >= 26 and text_10.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_10.tStart = t  # underestimates by a little under one frame\u000a            text_10.frameNStart = frameN  # exact frame index\u000a            text_10.setAutoDraw(True)\u000a        elif text_10.status == STARTED and t >= (26 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_10.setAutoDraw(False)\u000a        # *ISI_11* period\u000a        if t >= 0.0 and ISI_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_11.tStart = t  # underestimates by a little under one frame\u000a            ISI_11.frameNStart = frameN  # exact frame index\u000a            ISI_11.start(1)\u000a        elif ISI_11.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_11.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_0Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_0"-------\u000a    for thisComponent in var_6Letters_0Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_11.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_11.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_11.keys',KeyboardResp_11.keys)\u000a    if KeyboardResp_11.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_11.rt', KeyboardResp_11.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "var_6Letters_1"-------\u000a    t = 0\u000a    var_6Letters_1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(22.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_12.setText(' A B C D E F ')\u000a    UpperBrackets_12.setText('  {   }      ')\u000a    LowerText_12.setText(u' a b c d e f ')\u000a    KeyboardResp_12 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_12.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    var_6Letters_1Components = []\u000a    var_6Letters_1Components.append(text_11)\u000a    var_6Letters_1Components.append(text_12)\u000a    var_6Letters_1Components.append(text_14)\u000a    var_6Letters_1Components.append(ISI_12)\u000a    var_6Letters_1Components.append(TopUpperLine_12)\u000a    var_6Letters_1Components.append(UpperText_12)\u000a    var_6Letters_1Components.append(UpperBrackets_12)\u000a    var_6Letters_1Components.append(BotUpperLine_12)\u000a    var_6Letters_1Components.append(TopLowerLine_12)\u000a    var_6Letters_1Components.append(LowerText_12)\u000a    var_6Letters_1Components.append(LowerBrackets_12)\u000a    var_6Letters_1Components.append(BotLowerLine_12)\u000a    var_6Letters_1Components.append(TrialCrossHair_12)\u000a    var_6Letters_1Components.append(RestCrossHair_12)\u000a    var_6Letters_1Components.append(KeyboardResp_12)\u000a    var_6Letters_1Components.append(text_17)\u000a    var_6Letters_1Components.append(text_19)\u000a    var_6Letters_1Components.append(text_20)\u000a    for thisComponent in var_6Letters_1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_11* updates\u000a        if t >= 0.0 and text_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_11.tStart = t  # underestimates by a little under one frame\u000a            text_11.frameNStart = frameN  # exact frame index\u000a            text_11.setAutoDraw(True)\u000a        elif text_11.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_11.setAutoDraw(False)\u000a        \u000a        # *text_12* updates\u000a        if t >= 3 and text_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_12.tStart = t  # underestimates by a little under one frame\u000a            text_12.frameNStart = frameN  # exact frame index\u000a            text_12.setAutoDraw(True)\u000a        elif text_12.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_12.setAutoDraw(False)\u000a        \u000a        # *text_14* updates\u000a        if t >= 6 and text_14.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_14.tStart = t  # underestimates by a little under one frame\u000a            text_14.frameNStart = frameN  # exact frame index\u000a            text_14.setAutoDraw(True)\u000a        elif text_14.status == STARTED and t >= (6 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_14.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_12* updates\u000a        if t >= 0 and TopUpperLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_12.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_12.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_12.setAutoDraw(True)\u000a        elif TopUpperLine_12.status == STARTED and t >= (0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_12.setAutoDraw(False)\u000a        \u000a        # *UpperText_12* updates\u000a        if t >= 0 and UpperText_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_12.tStart = t  # underestimates by a little under one frame\u000a            UpperText_12.frameNStart = frameN  # exact frame index\u000a            UpperText_12.setAutoDraw(True)\u000a        elif UpperText_12.status == STARTED and t >= (0 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_12.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_12* updates\u000a        if t >= 3 and UpperBrackets_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_12.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_12.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_12.setAutoDraw(True)\u000a        elif UpperBrackets_12.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_12.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_12* updates\u000a        if t >= 0.0 and BotUpperLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_12.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_12.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_12.setAutoDraw(True)\u000a        elif BotUpperLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_12.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_12* updates\u000a        if t >= 0.0 and TopLowerLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_12.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_12.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_12.setAutoDraw(True)\u000a        elif TopLowerLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_12.setAutoDraw(False)\u000a        \u000a        # *LowerText_12* updates\u000a        if t >= 11 and LowerText_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_12.tStart = t  # underestimates by a little under one frame\u000a            LowerText_12.frameNStart = frameN  # exact frame index\u000a            LowerText_12.setAutoDraw(True)\u000a        elif LowerText_12.status == STARTED and t >= (11 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_12.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_12* updates\u000a        if t >= 11 and LowerBrackets_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_12.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_12.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_12.setAutoDraw(True)\u000a        elif LowerBrackets_12.status == STARTED and t >= (11 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_12.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_12* updates\u000a        if t >= 0.0 and BotLowerLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_12.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_12.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_12.setAutoDraw(True)\u000a        elif BotLowerLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_12.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_12* updates\u000a        if t >= 0 and TrialCrossHair_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_12.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_12.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_12.setAutoDraw(True)\u000a        elif TrialCrossHair_12.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_12.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_12* updates\u000a        if t >= 17 and RestCrossHair_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_12.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_12.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_12.setAutoDraw(True)\u000a        elif RestCrossHair_12.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_12.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_12* updates\u000a        if t >= 0 and KeyboardResp_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_12.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_12.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_12.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_12.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_12.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_12.status = STOPPED\u000a        if KeyboardResp_12.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_12.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_12.rt.append(KeyboardResp_12.clock.getTime())\u000a        \u000a        # *text_17* updates\u000a        if t >= 11 and text_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_17.tStart = t  # underestimates by a little under one frame\u000a            text_17.frameNStart = frameN  # exact frame index\u000a            text_17.setAutoDraw(True)\u000a        elif text_17.status == STARTED and t >= (11 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_17.setAutoDraw(False)\u000a        \u000a        # *text_19* updates\u000a        if t >= 14 and text_19.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_19.tStart = t  # underestimates by a little under one frame\u000a            text_19.frameNStart = frameN  # exact frame index\u000a            text_19.setAutoDraw(True)\u000a        elif text_19.status == STARTED and t >= (14 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_19.setAutoDraw(False)\u000a        \u000a        # *text_20* updates\u000a        if t >= 17 and text_20.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_20.tStart = t  # underestimates by a little under one frame\u000a            text_20.frameNStart = frameN  # exact frame index\u000a            text_20.setAutoDraw(True)\u000a        elif text_20.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_20.setAutoDraw(False)\u000a        # *ISI_12* period\u000a        if t >= 0.0 and ISI_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_12.tStart = t  # underestimates by a little under one frame\u000a            ISI_12.frameNStart = frameN  # exact frame index\u000a            ISI_12.start(1)\u000a        elif ISI_12.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_12.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_1"-------\u000a    for thisComponent in var_6Letters_1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_12.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_12.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_12.keys',KeyboardResp_12.keys)\u000a    if KeyboardResp_12.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_12.rt', KeyboardResp_12.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "DemoTrialRealTimes"-------\u000a    t = 0\u000a    DemoTrialRealTimesClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(17.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_18.setText(u' A B C D E F ')\u000a    UpperBrackets_18.setText(u'  {   }      ')\u000a    LowerText_17.setText(u' a b c d e f ')\u000a    KeyboardResp_13 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_13.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    DemoTrialRealTimesComponents = []\u000a    DemoTrialRealTimesComponents.append(text_44)\u000a    DemoTrialRealTimesComponents.append(text_45)\u000a    DemoTrialRealTimesComponents.append(text_46)\u000a    DemoTrialRealTimesComponents.append(ISI_18)\u000a    DemoTrialRealTimesComponents.append(TopUpperLine_18)\u000a    DemoTrialRealTimesComponents.append(UpperText_18)\u000a    DemoTrialRealTimesComponents.append(UpperBrackets_18)\u000a    DemoTrialRealTimesComponents.append(BotUpperLine_18)\u000a    DemoTrialRealTimesComponents.append(TopLowerLine_18)\u000a    DemoTrialRealTimesComponents.append(LowerText_17)\u000a    DemoTrialRealTimesComponents.append(LowerBrackets_17)\u000a    DemoTrialRealTimesComponents.append(BotLowerLine_18)\u000a    DemoTrialRealTimesComponents.append(TrialCrossHair_18)\u000a    DemoTrialRealTimesComponents.append(RestCrossHair_18)\u000a    DemoTrialRealTimesComponents.append(KeyboardResp_13)\u000a    DemoTrialRealTimesComponents.append(text_48)\u000a    DemoTrialRealTimesComponents.append(text_49)\u000a    for thisComponent in DemoTrialRealTimesComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "DemoTrialRealTimes"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = DemoTrialRealTimesClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_44* updates\u000a        if t >= 0.0 and text_44.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_44.tStart = t  # underestimates by a little under one frame\u000a            text_44.frameNStart = frameN  # exact frame index\u000a            text_44.setAutoDraw(True)\u000a        elif text_44.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_44.setAutoDraw(False)\u000a        \u000a        # *text_45* updates\u000a        if t >= 3 and text_45.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_45.tStart = t  # underestimates by a little under one frame\u000a            text_45.frameNStart = frameN  # exact frame index\u000a            text_45.setAutoDraw(True)\u000a        elif text_45.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_45.setAutoDraw(False)\u000a        \u000a        # *text_46* updates\u000a        if t >= 5 and text_46.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_46.tStart = t  # underestimates by a little under one frame\u000a            text_46.frameNStart = frameN  # exact frame index\u000a            text_46.setAutoDraw(True)\u000a        elif text_46.status == STARTED and t >= (5 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_46.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_18* updates\u000a        if t >= 0 and TopUpperLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_18.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_18.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_18.setAutoDraw(True)\u000a        elif TopUpperLine_18.status == STARTED and t >= (0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_18.setAutoDraw(False)\u000a        \u000a        # *UpperText_18* updates\u000a        if t >= 3 and UpperText_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_18.tStart = t  # underestimates by a little under one frame\u000a            UpperText_18.frameNStart = frameN  # exact frame index\u000a            UpperText_18.setAutoDraw(True)\u000a        elif UpperText_18.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_18.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_18* updates\u000a        if t >= 3 and UpperBrackets_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_18.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_18.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_18.setAutoDraw(True)\u000a        elif UpperBrackets_18.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_18.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_18* updates\u000a        if t >= 0.0 and BotUpperLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_18.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_18.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_18.setAutoDraw(True)\u000a        elif BotUpperLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_18.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_18* updates\u000a        if t >= 0.0 and TopLowerLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_18.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_18.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_18.setAutoDraw(True)\u000a        elif TopLowerLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_18.setAutoDraw(False)\u000a        \u000a        # *LowerText_17* updates\u000a        if t >= 10 and LowerText_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_17.tStart = t  # underestimates by a little under one frame\u000a            LowerText_17.frameNStart = frameN  # exact frame index\u000a            LowerText_17.setAutoDraw(True)\u000a        elif LowerText_17.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_17.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_17* updates\u000a        if t >= 10 and LowerBrackets_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_17.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_17.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_17.setAutoDraw(True)\u000a        elif LowerBrackets_17.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_17.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_18* updates\u000a        if t >= 0.0 and BotLowerLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_18.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_18.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_18.setAutoDraw(True)\u000a        elif BotLowerLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_18.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_18* updates\u000a        if t >= 0 and TrialCrossHair_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_18.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_18.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_18.setAutoDraw(True)\u000a        elif TrialCrossHair_18.status == STARTED and t >= (0 + (12-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_18.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_18* updates\u000a        if t >= 12 and RestCrossHair_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_18.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_18.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_18.setAutoDraw(True)\u000a        elif RestCrossHair_18.status == STARTED and t >= (12 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_18.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_13* updates\u000a        if t >= 0 and KeyboardResp_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_13.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_13.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_13.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_13.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_13.status = STOPPED\u000a        if KeyboardResp_13.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_13.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_13.rt.append(KeyboardResp_13.clock.getTime())\u000a        \u000a        # *text_48* updates\u000a        if t >= 10 and text_48.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_48.tStart = t  # underestimates by a little under one frame\u000a            text_48.frameNStart = frameN  # exact frame index\u000a            text_48.setAutoDraw(True)\u000a        elif text_48.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_48.setAutoDraw(False)\u000a        \u000a        # *text_49* updates\u000a        if t >= 12 and text_49.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_49.tStart = t  # underestimates by a little under one frame\u000a            text_49.frameNStart = frameN  # exact frame index\u000a            text_49.setAutoDraw(True)\u000a        elif text_49.status == STARTED and t >= (12 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_49.setAutoDraw(False)\u000a        # *ISI_18* period\u000a        if t >= 0.0 and ISI_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_18.tStart = t  # underestimates by a little under one frame\u000a            ISI_18.frameNStart = frameN  # exact frame index\u000a            ISI_18.start(1)\u000a        elif ISI_18.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_18.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in DemoTrialRealTimesComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "DemoTrialRealTimes"-------\u000a    for thisComponent in DemoTrialRealTimesComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_13.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_13.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_13.keys',KeyboardResp_13.keys)\u000a    if KeyboardResp_13.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_13.rt', KeyboardResp_13.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "NumLettersToRem"-------\u000a    t = 0\u000a    NumLettersToRemClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(30.000000)\u000a    # update component parameters for each repeat\u000a    UpBrack1.setText('        { }  ')\u000a    UpperText_17.setText(' A B C D E F ')\u000a    UpperBrackets_17.setText('')\u000a    # keep track of which components have finished\u000a    NumLettersToRemComponents = []\u000a    NumLettersToRemComponents.append(text_15)\u000a    NumLettersToRemComponents.append(text_33)\u000a    NumLettersToRemComponents.append(text_34)\u000a    NumLettersToRemComponents.append(text_3)\u000a    NumLettersToRemComponents.append(text_35)\u000a    NumLettersToRemComponents.append(UpBrack1)\u000a    NumLettersToRemComponents.append(ISI_17)\u000a    NumLettersToRemComponents.append(TopUpperLine_17)\u000a    NumLettersToRemComponents.append(UpperText_17)\u000a    NumLettersToRemComponents.append(UpperBrackets_17)\u000a    NumLettersToRemComponents.append(BotUpperLine_17)\u000a    NumLettersToRemComponents.append(TopLowerLine_17)\u000a    NumLettersToRemComponents.append(BotLowerLine_17)\u000a    NumLettersToRemComponents.append(TrialCrossHair_17)\u000a    NumLettersToRemComponents.append(RestCrossHair_17)\u000a    NumLettersToRemComponents.append(UpBrack2)\u000a    NumLettersToRemComponents.append(UpBrack3)\u000a    NumLettersToRemComponents.append(UpBrack4)\u000a    NumLettersToRemComponents.append(UpBrack5)\u000a    NumLettersToRemComponents.append(UpBrack6)\u000a    NumLettersToRemComponents.append(text_38)\u000a    NumLettersToRemComponents.append(text_39)\u000a    NumLettersToRemComponents.append(text_40)\u000a    NumLettersToRemComponents.append(text_41)\u000a    NumLettersToRemComponents.append(text_42)\u000a    NumLettersToRemComponents.append(text_43)\u000a    for thisComponent in NumLettersToRemComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "NumLettersToRem"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = NumLettersToRemClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_15* updates\u000a        if t >= 0.0 and text_15.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_15.tStart = t  # underestimates by a little under one frame\u000a            text_15.frameNStart = frameN  # exact frame index\u000a            text_15.setAutoDraw(True)\u000a        elif text_15.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_15.setAutoDraw(False)\u000a        \u000a        # *text_33* updates\u000a        if t >= 3 and text_33.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_33.tStart = t  # underestimates by a little under one frame\u000a            text_33.frameNStart = frameN  # exact frame index\u000a            text_33.setAutoDraw(True)\u000a        elif text_33.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_33.setAutoDraw(False)\u000a        \u000a        # *text_34* updates\u000a        if t >= 6 and text_34.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_34.tStart = t  # underestimates by a little under one frame\u000a            text_34.frameNStart = frameN  # exact frame index\u000a            text_34.setAutoDraw(True)\u000a        elif text_34.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_34.setAutoDraw(False)\u000a        \u000a        # *text_3* updates\u000a        if t >= 9 and text_3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_3.tStart = t  # underestimates by a little under one frame\u000a            text_3.frameNStart = frameN  # exact frame index\u000a            text_3.setAutoDraw(True)\u000a        elif text_3.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_3.setAutoDraw(False)\u000a        \u000a        # *text_35* updates\u000a        if t >= 12 and text_35.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_35.tStart = t  # underestimates by a little under one frame\u000a            text_35.frameNStart = frameN  # exact frame index\u000a            text_35.setAutoDraw(True)\u000a        elif text_35.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_35.setAutoDraw(False)\u000a        \u000a        # *UpBrack1* updates\u000a        if t >= 15 and UpBrack1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack1.tStart = t  # underestimates by a little under one frame\u000a            UpBrack1.frameNStart = frameN  # exact frame index\u000a            UpBrack1.setAutoDraw(True)\u000a        elif UpBrack1.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack1.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_17* updates\u000a        if t >= 0 and TopUpperLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_17.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_17.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_17.setAutoDraw(True)\u000a        elif TopUpperLine_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_17.setAutoDraw(False)\u000a        \u000a        # *UpperText_17* updates\u000a        if t >= 0 and UpperText_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_17.tStart = t  # underestimates by a little under one frame\u000a            UpperText_17.frameNStart = frameN  # exact frame index\u000a            UpperText_17.setAutoDraw(True)\u000a        elif UpperText_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_17.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_17* updates\u000a        if t >= 0.0 and UpperBrackets_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_17.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_17.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_17.setAutoDraw(True)\u000a        elif UpperBrackets_17.status == STARTED and t >= (0.0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_17.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_17* updates\u000a        if t >= 0.0 and BotUpperLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_17.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_17.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_17.setAutoDraw(True)\u000a        elif BotUpperLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_17.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_17* updates\u000a        if t >= 0.0 and TopLowerLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_17.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_17.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_17.setAutoDraw(True)\u000a        elif TopLowerLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_17.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_17* updates\u000a        if t >= 0.0 and BotLowerLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_17.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_17.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_17.setAutoDraw(True)\u000a        elif BotLowerLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_17.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_17* updates\u000a        if t >= 0 and TrialCrossHair_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_17.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_17.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_17.setAutoDraw(True)\u000a        elif TrialCrossHair_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_17.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_17* updates\u000a        if t >= 0.0 and RestCrossHair_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_17.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_17.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_17.setAutoDraw(True)\u000a        elif RestCrossHair_17.status == STARTED and t >= (0.0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_17.setAutoDraw(False)\u000a        \u000a        # *UpBrack2* updates\u000a        if t >= 18 and UpBrack2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack2.tStart = t  # underestimates by a little under one frame\u000a            UpBrack2.frameNStart = frameN  # exact frame index\u000a            UpBrack2.setAutoDraw(True)\u000a        elif UpBrack2.status == STARTED and t >= (18 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack2.setAutoDraw(False)\u000a        \u000a        # *UpBrack3* updates\u000a        if t >= 20 and UpBrack3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack3.tStart = t  # underestimates by a little under one frame\u000a            UpBrack3.frameNStart = frameN  # exact frame index\u000a            UpBrack3.setAutoDraw(True)\u000a        elif UpBrack3.status == STARTED and t >= (20 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack3.setAutoDraw(False)\u000a        \u000a        # *UpBrack4* updates\u000a        if t >= 22 and UpBrack4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack4.tStart = t  # underestimates by a little under one frame\u000a            UpBrack4.frameNStart = frameN  # exact frame index\u000a            UpBrack4.setAutoDraw(True)\u000a        elif UpBrack4.status == STARTED and t >= (22 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack4.setAutoDraw(False)\u000a        \u000a        # *UpBrack5* updates\u000a        if t >= 24 and UpBrack5.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack5.tStart = t  # underestimates by a little under one frame\u000a            UpBrack5.frameNStart = frameN  # exact frame index\u000a            UpBrack5.setAutoDraw(True)\u000a        elif UpBrack5.status == STARTED and t >= (24 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack5.setAutoDraw(False)\u000a        \u000a        # *UpBrack6* updates\u000a        if t >= 26 and UpBrack6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack6.tStart = t  # underestimates by a little under one frame\u000a            UpBrack6.frameNStart = frameN  # exact frame index\u000a            UpBrack6.setAutoDraw(True)\u000a        elif UpBrack6.status == STARTED and t >= (26 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack6.setAutoDraw(False)\u000a        \u000a        # *text_38* updates\u000a        if t >= 15 and text_38.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_38.tStart = t  # underestimates by a little under one frame\u000a            text_38.frameNStart = frameN  # exact frame index\u000a            text_38.setAutoDraw(True)\u000a        elif text_38.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_38.setAutoDraw(False)\u000a        \u000a        # *text_39* updates\u000a        if t >= 18 and text_39.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_39.tStart = t  # underestimates by a little under one frame\u000a            text_39.frameNStart = frameN  # exact frame index\u000a            text_39.setAutoDraw(True)\u000a        elif text_39.status == STARTED and t >= (18 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_39.setAutoDraw(False)\u000a        \u000a        # *text_40* updates\u000a        if t >= 20 and text_40.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_40.tStart = t  # underestimates by a little under one frame\u000a            text_40.frameNStart = frameN  # exact frame index\u000a            text_40.setAutoDraw(True)\u000a        elif text_40.status == STARTED and t >= (20 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_40.setAutoDraw(False)\u000a        \u000a        # *text_41* updates\u000a        if t >= 22 and text_41.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_41.tStart = t  # underestimates by a little under one frame\u000a            text_41.frameNStart = frameN  # exact frame index\u000a            text_41.setAutoDraw(True)\u000a        elif text_41.status == STARTED and t >= (22 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_41.setAutoDraw(False)\u000a        \u000a        # *text_42* updates\u000a        if t >= 24 and text_42.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_42.tStart = t  # underestimates by a little under one frame\u000a            text_42.frameNStart = frameN  # exact frame index\u000a            text_42.setAutoDraw(True)\u000a        elif text_42.status == STARTED and t >= (24 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_42.setAutoDraw(False)\u000a        \u000a        # *text_43* updates\u000a        if t >= 26 and text_43.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_43.tStart = t  # underestimates by a little under one frame\u000a            text_43.frameNStart = frameN  # exact frame index\u000a            text_43.setAutoDraw(True)\u000a        elif text_43.status == STARTED and t >= (26 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_43.setAutoDraw(False)\u000a        # *ISI_17* period\u000a        if t >= 0.0 and ISI_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_17.tStart = t  # underestimates by a little under one frame\u000a            ISI_17.frameNStart = frameN  # exact frame index\u000a            ISI_17.start(1)\u000a        elif ISI_17.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_17.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in NumLettersToRemComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "NumLettersToRem"-------\u000a    for thisComponent in NumLettersToRemComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "TrialParts_1"-------\u000a    t = 0\u000a    TrialParts_1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(25.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_16.setText('')\u000a    UpperBrackets_16.setText('')\u000a    LowerText_16.setText('')\u000a    # keep track of which components have finished\u000a    TrialParts_1Components = []\u000a    TrialParts_1Components.append(text_27)\u000a    TrialParts_1Components.append(text_30)\u000a    TrialParts_1Components.append(text_31)\u000a    TrialParts_1Components.append(text_32)\u000a    TrialParts_1Components.append(ISI_16)\u000a    TrialParts_1Components.append(TopUpperLine_16)\u000a    TrialParts_1Components.append(UpperText_16)\u000a    TrialParts_1Components.append(UpperBrackets_16)\u000a    TrialParts_1Components.append(BotUpperLine_16)\u000a    TrialParts_1Components.append(TopLowerLine_16)\u000a    TrialParts_1Components.append(LowerText_16)\u000a    TrialParts_1Components.append(LowerBrackets_16)\u000a    TrialParts_1Components.append(BotLowerLine_16)\u000a    TrialParts_1Components.append(TrialCrossHair_16)\u000a    TrialParts_1Components.append(RestCrossHair_16)\u000a    TrialParts_1Components.append(text_36)\u000a    TrialParts_1Components.append(text_37)\u000a    TrialParts_1Components.append(text_50)\u000a    for thisComponent in TrialParts_1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialParts_1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialParts_1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_27* updates\u000a        if t >= 0.0 and text_27.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_27.tStart = t  # underestimates by a little under one frame\u000a            text_27.frameNStart = frameN  # exact frame index\u000a            text_27.setAutoDraw(True)\u000a        elif text_27.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_27.setAutoDraw(False)\u000a        \u000a        # *text_30* updates\u000a        if t >= 3 and text_30.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_30.tStart = t  # underestimates by a little under one frame\u000a            text_30.frameNStart = frameN  # exact frame index\u000a            text_30.setAutoDraw(True)\u000a        elif text_30.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_30.setAutoDraw(False)\u000a        \u000a        # *text_31* updates\u000a        if t >= 6 and text_31.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_31.tStart = t  # underestimates by a little under one frame\u000a            text_31.frameNStart = frameN  # exact frame index\u000a            text_31.setAutoDraw(True)\u000a        elif text_31.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_31.setAutoDraw(False)\u000a        \u000a        # *text_32* updates\u000a        if t >= 9 and text_32.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_32.tStart = t  # underestimates by a little under one frame\u000a            text_32.frameNStart = frameN  # exact frame index\u000a            text_32.setAutoDraw(True)\u000a        elif text_32.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_32.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_16* updates\u000a        if t >= 0 and TopUpperLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_16.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_16.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_16.setAutoDraw(True)\u000a        elif TopUpperLine_16.status == STARTED and t >= (0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_16.setAutoDraw(False)\u000a        \u000a        # *UpperText_16* updates\u000a        if t >= 0 and UpperText_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_16.tStart = t  # underestimates by a little under one frame\u000a            UpperText_16.frameNStart = frameN  # exact frame index\u000a            UpperText_16.setAutoDraw(True)\u000a        elif UpperText_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_16.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_16* updates\u000a        if t >= 0 and UpperBrackets_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_16.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_16.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_16.setAutoDraw(True)\u000a        elif UpperBrackets_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_16.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_16* updates\u000a        if t >= 0.0 and BotUpperLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_16.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_16.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_16.setAutoDraw(True)\u000a        elif BotUpperLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_16.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_16* updates\u000a        if t >= 0.0 and TopLowerLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_16.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_16.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_16.setAutoDraw(True)\u000a        elif TopLowerLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_16.setAutoDraw(False)\u000a        \u000a        # *LowerText_16* updates\u000a        if t >= 0 and LowerText_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_16.tStart = t  # underestimates by a little under one frame\u000a            LowerText_16.frameNStart = frameN  # exact frame index\u000a            LowerText_16.setAutoDraw(True)\u000a        elif LowerText_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_16.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_16* updates\u000a        if t >= 0 and LowerBrackets_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_16.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_16.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_16.setAutoDraw(True)\u000a        elif LowerBrackets_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_16.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_16* updates\u000a        if t >= 0.0 and BotLowerLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_16.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_16.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_16.setAutoDraw(True)\u000a        elif BotLowerLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_16.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_16* updates\u000a        if t >= 0 and TrialCrossHair_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_16.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_16.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_16.setAutoDraw(True)\u000a        elif TrialCrossHair_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_16.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_16* updates\u000a        if t >= 0 and RestCrossHair_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_16.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_16.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_16.setAutoDraw(True)\u000a        elif RestCrossHair_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_16.setAutoDraw(False)\u000a        \u000a        # *text_36* updates\u000a        if t >= 12 and text_36.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_36.tStart = t  # underestimates by a little under one frame\u000a            text_36.frameNStart = frameN  # exact frame index\u000a            text_36.setAutoDraw(True)\u000a        elif text_36.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_36.setAutoDraw(False)\u000a        \u000a        # *text_37* updates\u000a        if t >= 15 and text_37.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_37.tStart = t  # underestimates by a little under one frame\u000a            text_37.frameNStart = frameN  # exact frame index\u000a            text_37.setAutoDraw(True)\u000a        elif text_37.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_37.setAutoDraw(False)\u000a        \u000a        # *text_50* updates\u000a        if t >= 20 and text_50.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_50.tStart = t  # underestimates by a little under one frame\u000a            text_50.frameNStart = frameN  # exact frame index\u000a            text_50.setAutoDraw(True)\u000a        elif text_50.status == STARTED and t >= (20 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_50.setAutoDraw(False)\u000a        # *ISI_16* period\u000a        if t >= 0.0 and ISI_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_16.tStart = t  # underestimates by a little under one frame\u000a            ISI_16.frameNStart = frameN  # exact frame index\u000a            ISI_16.start(1)\u000a        elif ISI_16.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_16.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialParts_1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialParts_1"-------\u000a    for thisComponent in TrialParts_1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "trial5_2"-------\u000a    t = 0\u000a    trial5_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    UpperText.setText(u' L K R G M X ')\u000a    UpperBrackets.setText(u'  {         }')\u000a    LowerText.setText(u' b t y g q j ')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trial5_2Components = []\u000a    trial5_2Components.append(ISI)\u000a    trial5_2Components.append(TopUpperLine)\u000a    trial5_2Components.append(UpperText)\u000a    trial5_2Components.append(UpperBrackets)\u000a    trial5_2Components.append(BotUpperLine)\u000a    trial5_2Components.append(TopLowerLine)\u000a    trial5_2Components.append(LowerText)\u000a    trial5_2Components.append(LowerBrackets)\u000a    trial5_2Components.append(BotLowerLine)\u000a    trial5_2Components.append(TrialCrossHair)\u000a    trial5_2Components.append(RestCrossHair)\u000a    trial5_2Components.append(resp)\u000a    for thisComponent in trial5_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "trial5_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial5_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *TopUpperLine* updates\u000a        if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine.frameNStart = frameN  # exact frame index\u000a            TopUpperLine.setAutoDraw(True)\u000a        elif TopUpperLine.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine.setAutoDraw(False)\u000a        \u000a        # *UpperText* updates\u000a        if t >= 0 and UpperText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText.tStart = t  # underestimates by a little under one frame\u000a            UpperText.frameNStart = frameN  # exact frame index\u000a            UpperText.setAutoDraw(True)\u000a        elif UpperText.status == STARTED and t >= (0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets* updates\u000a        if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets.frameNStart = frameN  # exact frame index\u000a            UpperBrackets.setAutoDraw(True)\u000a        elif UpperBrackets.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine* updates\u000a        if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine.frameNStart = frameN  # exact frame index\u000a            BotUpperLine.setAutoDraw(True)\u000a        elif BotUpperLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine* updates\u000a        if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine.frameNStart = frameN  # exact frame index\u000a            TopLowerLine.setAutoDraw(True)\u000a        elif TopLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine.setAutoDraw(False)\u000a        \u000a        # *LowerText* updates\u000a        if t >= 7 and LowerText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText.tStart = t  # underestimates by a little under one frame\u000a            LowerText.frameNStart = frameN  # exact frame index\u000a            LowerText.setAutoDraw(True)\u000a        elif LowerText.status == STARTED and t >= (7 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets* updates\u000a        if t >= 7 and LowerBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets.frameNStart = frameN  # exact frame index\u000a            LowerBrackets.setAutoDraw(True)\u000a        elif LowerBrackets.status == STARTED and t >= (7 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine* updates\u000a        if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine.frameNStart = frameN  # exact frame index\u000a            BotLowerLine.setAutoDraw(True)\u000a        elif BotLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair* updates\u000a        if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair.setAutoDraw(True)\u000a        elif TrialCrossHair.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair* updates\u000a        if t >= 9 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (9 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # *resp* updates\u000a        if t >= 7 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif resp.status == STARTED and t >= (7 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(u'6')) or (resp.keys == u'6'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(1)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial5_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "trial5_2"-------\u000a    for thisComponent in trial5_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(u'6').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('resp.keys',resp.keys)\u000a    thisExp.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        thisExp.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "TrialFeedBack"-------\u000a    t = 0\u000a    TrialFeedBackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.000000)\u000a    # update component parameters for each repeat\u000a    if ((resp.corr) & (resp.rt < 2.0)):#stored on last run routine\u000a      msg="Correct and on time! RT=%.3f" %(resp.rt)\u000a    elif ((resp.corr) & (resp.rt > 2.0)):#stored on last run routine\u000a      msg="Correct, but too slow!\u005cn RT=%.3f\u005cnResponse time should be less than two seconds." %(resp.rt)\u000a    else:\u000a      if resp.rt < 2.0:\u000a        msg="Oops! That was incorrect, but on time!"\u000a      else: \u000a        msg="Oops! That was incorrect and too slow!"\u000a    text_47.setText(msg)\u000a    # keep track of which components have finished\u000a    TrialFeedBackComponents = []\u000a    TrialFeedBackComponents.append(text_47)\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialFeedBack"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialFeedBackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text_47* updates\u000a        if t >= 0.0 and text_47.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_47.tStart = t  # underestimates by a little under one frame\u000a            text_47.frameNStart = frameN  # exact frame index\u000a            text_47.setAutoDraw(True)\u000a        elif text_47.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_47.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialFeedBackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialFeedBack"-------\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    msg='Ended'\u000a    win.close()\u000a#    win.close()\u000a\u000adef Test(subid,visitid):\u000a    expInfo = {u'Visit ID': u'9999', u'Participant ID': u'1'}\u000a    print 'subid is %s'%(subid)\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a    else:\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid    \u000a    # Store info about the experiment session\u000a\u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'],expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=False,\u000a        dataFileName=filename)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=ScreenToUse, color=[-1,-1,-1], colorSpace='rgb',\u000a        blendMode='average', useFBO=True,\u000a        units='cm')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial_2"\u000a    trial_2Clock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text='      { }    ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Initialize components for Routine "TrialFeedBack"\u000a    TrialFeedBackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    text = visual.TextStim(win=win, ori=0, name='text',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    #------Prepare to start Routine "trial_2"-------\u000a    t = 0\u000a    trial_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    UpperText.setText(' A B C D E F ')\u000a    UpperBrackets.setText('  {         }')\u000a    LowerText.setText(' a b c d e f ')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trial_2Components = []\u000a    trial_2Components.append(ISI)\u000a    trial_2Components.append(TopUpperLine)\u000a    trial_2Components.append(UpperText)\u000a    trial_2Components.append(UpperBrackets)\u000a    trial_2Components.append(BotUpperLine)\u000a    trial_2Components.append(TopLowerLine)\u000a    trial_2Components.append(LowerText)\u000a    trial_2Components.append(LowerBrackets)\u000a    trial_2Components.append(BotLowerLine)\u000a    trial_2Components.append(TrialCrossHair)\u000a    trial_2Components.append(RestCrossHair)\u000a    trial_2Components.append(resp)\u000a    for thisComponent in trial_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "trial_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *TopUpperLine* updates\u000a        if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine.frameNStart = frameN  # exact frame index\u000a            TopUpperLine.setAutoDraw(True)\u000a        elif TopUpperLine.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine.setAutoDraw(False)\u000a        \u000a        # *UpperText* updates\u000a        if t >= 0 and UpperText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText.tStart = t  # underestimates by a little under one frame\u000a            UpperText.frameNStart = frameN  # exact frame index\u000a            UpperText.setAutoDraw(True)\u000a        elif UpperText.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets* updates\u000a        if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets.frameNStart = frameN  # exact frame index\u000a            UpperBrackets.setAutoDraw(True)\u000a        elif UpperBrackets.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine* updates\u000a        if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine.frameNStart = frameN  # exact frame index\u000a            BotUpperLine.setAutoDraw(True)\u000a        elif BotUpperLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine* updates\u000a        if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine.frameNStart = frameN  # exact frame index\u000a            TopLowerLine.setAutoDraw(True)\u000a        elif TopLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine.setAutoDraw(False)\u000a        \u000a        # *LowerText* updates\u000a        if t >= 7 and LowerText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText.tStart = t  # underestimates by a little under one frame\u000a            LowerText.frameNStart = frameN  # exact frame index\u000a            LowerText.setAutoDraw(True)\u000a        elif LowerText.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets* updates\u000a        if t >= 7 and LowerBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets.frameNStart = frameN  # exact frame index\u000a            LowerBrackets.setAutoDraw(True)\u000a        elif LowerBrackets.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine* updates\u000a        if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine.frameNStart = frameN  # exact frame index\u000a            BotLowerLine.setAutoDraw(True)\u000a        elif BotLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair* updates\u000a        if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair.setAutoDraw(True)\u000a        elif TrialCrossHair.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair* updates\u000a        if t >= 9 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (9 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # *resp* updates\u000a        if t >= 7 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif resp.status == STARTED and t >= (7 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(u'6')) or (resp.keys == u'6'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(1)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "trial_2"-------\u000a    for thisComponent in trial_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(u'6').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('resp.keys',resp.keys)\u000a    thisExp.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        thisExp.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "TrialFeedBack"-------\u000a    t = 0\u000a    TrialFeedBackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.000000)\u000a    # update component parameters for each repeat\u000a    if ((resp.corr) & (resp.rt < 2.0)):#stored on last run routine\u000a      msg="Correct and on time! RT=%.3f" %(resp.rt)\u000a    elif ((resp.corr) & (resp.rt > 2.0)):#stored on last run routine\u000a      msg="Correct, but too slow!\u005cn RT=%.3f\u005cnResponse time should be less than two seconds." %(resp.rt)\u000a    else:\u000a      if resp.rt < 2.0:\u000a        msg="Oops! That was incorrect, but on time!"\u000a      else: \u000a        msg="Oops! That was incorrect and too slow!"\u000a    text.setText(msg)\u000a    # keep track of which components have finished\u000a    TrialFeedBackComponents = []\u000a    TrialFeedBackComponents.append(text)\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialFeedBack"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialFeedBackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        elif text.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialFeedBackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialFeedBack"-------\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    msg='Ended'\u000a\u000a    win.close()\u000a\u000a
p1590
sS'thisTrial'
p1591
(lp1592
sS'_exp'
p1593
I444347088
sg10
S'trials'
p1594
sg6
S'/Users/jason/Dropbox/SteffenerColumbia/Scripts/ExperimentalStimuli/PartialTrialDIR/Scripts/PsychoPyTask/PartialTrialFunction.py'
p1595
sS'thisRepN'
p1596
I1
sg20
I01
sg21
g22
sS'data'
p1597
g1
(cpsychopy.data
DataHandler
p1598
c__builtin__
dict
p1599
(dp1600
g18
cnumpy.ma.core
_mareconstruct
p1601
(cnumpy.ma.core
MaskedArray
p1602
cnumpy
ndarray
p1603
(I0
tp1604
S'b'
tRp1605
(I1
(I72
I1
tg31
(S'f4'
I0
I1
tRp1606
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
cnumpy.core.multiarray
_reconstruct
p1607
(g1603
(I0
tS'b'
tRp1608
(I1
(I72
I1
tg31
(S'O4'
I0
I1
tRp1609
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp1610
S'--'
p1611
aS'--'
p1612
ag110
ag132
ag154
ag176
ag198
ag220
ag242
aS'--'
p1613
ag283
ag305
aS'--'
p1614
ag346
aS'--'
p1615
ag387
ag409
ag431
ag453
ag475
ag497
ag519
ag541
ag563
aS'--'
p1616
aS'--'
p1617
ag623
aS'--'
p1618
aS'--'
p1619
ag683
ag705
aS'--'
p1620
ag746
aS'--'
p1621
ag787
ag809
ag831
aS'--'
p1622
ag872
ag894
ag916
ag938
aS'--'
p1623
ag979
ag1000
ag1022
ag1044
ag1066
aS'--'
p1624
aS'--'
p1625
ag1126
ag1148
aS'--'
p1626
aS'--'
p1627
aS'--'
p1628
ag1227
ag1249
ag1271
aS'--'
p1629
aS'--'
p1630
ag1331
ag1353
ag1375
aS'--'
p1631
ag1416
ag1438
aS'--'
p1632
ag1479
aS'--'
p1633
aS'--'
p1634
ag1539
ag1561
atbsS'ran'
p1635
g1601
(g1602
g1603
g1604
S'b'
tRp1636
(I1
(I72
I1
tg1606
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
g1607
(g1603
(I0
tS'b'
tRp1637
(I1
(I72
I1
tg1609
I00
(lp1638
NaNag129
ag151
ag173
ag195
ag217
ag239
ag261
aNag302
ag324
aNag365
aNag406
ag428
ag450
ag472
ag494
ag516
ag538
ag560
ag582
aNaNag642
aNaNag702
ag724
aNag765
aNag806
ag828
ag850
aNag891
ag913
ag935
ag957
aNag997
ag1019
ag1041
ag1063
ag1085
aNaNag1145
ag1167
aNaNaNag1246
ag1268
ag1290
aNaNag1350
ag1372
ag1394
aNag1435
ag1457
aNag1498
aNaNag1558
ag1580
atbsg16
g1601
(g1602
g1603
g1604
S'b'
tRp1639
(I1
(I72
I1
tg1606
I00
S':d\xadN:d\xadN:d\xadN:d\xadN:d\xadN:d\xadN:d\xadN:d\xadN:d\xadN;d\xadN;d\xadN;d\xadN;d\xadN;d\xadN;d\xadN;d\xadN;d\xadN;d\xadN;d\xadN;d\xadN<d\xadN<d\xadN<d\xadN<d\xadN<d\xadN<d\xadN<d\xadN<d\xadN<d\xadN<d\xadN<d\xadN<d\xadN=d\xadN=d\xadN=d\xadN=d\xadN=d\xadN=d\xadN=d\xadN=d\xadN=d\xadN=d\xadN=d\xadN=d\xadN>d\xadN>d\xadN>d\xadN>d\xadN>d\xadN>d\xadN>d\xadN>d\xadN>d\xadN>d\xadN>d\xadN>d\xadN>d\xadN?d\xadN?d\xadN?d\xadN?d\xadN?d\xadN?d\xadN?d\xadN?d\xadN?d\xadN?d\xadN?d\xadN@d\xadN@d\xadN@d\xadN@d\xadN'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p1640
g1601
(g1602
g1603
g1604
S'b'
tRp1641
(I1
(I72
I1
tg1606
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB\x00\x00 B\x00\x00$B\x00\x00(B\x00\x00,B\x00\x000B\x00\x004B\x00\x008B\x00\x00<B\x00\x00@B\x00\x00DB\x00\x00HB\x00\x00LB\x00\x00PB\x00\x00TB\x00\x00XB\x00\x00\\B\x00\x00`B\x00\x00dB\x00\x00hB\x00\x00lB\x00\x00pB\x00\x00tB\x00\x00xB\x00\x00|B\x00\x00\x80B\x00\x00\x82B\x00\x00\x84B\x00\x00\x86B\x00\x00\x88B\x00\x00\x8aB\x00\x00\x8cB\x00\x00\x8eB'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1642
(dp1643
S'isNumeric'
p1644
(dp1645
g18
I01
sg1635
I01
sg16
I01
sg19
I00
sg17
I00
sg1640
I01
ssg1594
g1587
sS'dataTypes'
p1646
(lp1647
g1635
ag1640
ag16
ag17
ag18
ag19
asS'dataShape'
p1648
(lp1649
I72
aI1
asbsS'method'
p1650
Vsequential
p1651
sS'sequenceIndices'
p1652
g1607
(g1603
(I0
tS'b'
tRp1653
(I1
(I72
I1
tg80
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00(\x00\x00\x00)\x00\x00\x00*\x00\x00\x00+\x00\x00\x00,\x00\x00\x00-\x00\x00\x00.\x00\x00\x00/\x00\x00\x000\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x004\x00\x00\x005\x00\x00\x006\x00\x00\x007\x00\x00\x008\x00\x00\x009\x00\x00\x00:\x00\x00\x00;\x00\x00\x00<\x00\x00\x00=\x00\x00\x00>\x00\x00\x00?\x00\x00\x00@\x00\x00\x00A\x00\x00\x00B\x00\x00\x00C\x00\x00\x00D\x00\x00\x00E\x00\x00\x00F\x00\x00\x00G\x00\x00\x00'
tbsS'finished'
p1654
I01
sS'nReps'
p1655
I1
sS'nRemaining'
p1656
I-1
sS'trialList'
p1657
(lp1658
g1
(cpsychopy.data
TrialType
p1659
g1599
(dp1660
g42
g78
sg43
g70
sg44
g82
sg45
g71
sg46
g72
sg47
g84
sg48
g73
sg49
g74
sg50
g86
sg51
g75
sg52
g76
sg53
S' '
sg54
g88
sg55
g77
stRp1661
ag1
(g1659
g1599
(dp1662
g42
g98
sg43
g90
sg44
g101
sg45
g91
sg46
g92
sg47
g103
sg48
g93
sg49
g94
sg50
g105
sg51
g95
sg52
g96
sg53
S' '
sg54
g107
sg55
g97
stRp1663
ag1
(g1659
g1599
(dp1664
g42
g121
sg43
g115
sg44
g124
sg45
g116
sg46
g117
sg47
g113
sg48
g118
sg49
g109
sg50
g126
sg51
g119
sg52
g111
sg53
g120
sg54
g128
sg55
g112
stRp1665
ag1
(g1659
g1599
(dp1666
g42
g143
sg43
g137
sg44
g146
sg45
g138
sg46
g139
sg47
g135
sg48
g140
sg49
g131
sg50
g148
sg51
g141
sg52
g133
sg53
g142
sg54
g150
sg55
g134
stRp1667
ag1
(g1659
g1599
(dp1668
g42
g165
sg43
g159
sg44
g168
sg45
g160
sg46
g161
sg47
g157
sg48
g162
sg49
g153
sg50
g170
sg51
g163
sg52
g155
sg53
g164
sg54
g172
sg55
g156
stRp1669
ag1
(g1659
g1599
(dp1670
g42
g187
sg43
g181
sg44
g190
sg45
g182
sg46
g183
sg47
g179
sg48
g184
sg49
g175
sg50
g192
sg51
g185
sg52
g177
sg53
g186
sg54
g194
sg55
g178
stRp1671
ag1
(g1659
g1599
(dp1672
g42
g209
sg43
g203
sg44
g212
sg45
g204
sg46
g205
sg47
g201
sg48
g206
sg49
g197
sg50
g214
sg51
g207
sg52
g199
sg53
g208
sg54
g216
sg55
g200
stRp1673
ag1
(g1659
g1599
(dp1674
g42
g231
sg43
g225
sg44
g234
sg45
g226
sg46
g227
sg47
g223
sg48
g228
sg49
g219
sg50
g236
sg51
g229
sg52
g221
sg53
g230
sg54
g238
sg55
g222
stRp1675
ag1
(g1659
g1599
(dp1676
g42
g253
sg43
g247
sg44
g256
sg45
g248
sg46
g249
sg47
g245
sg48
g250
sg49
g241
sg50
g258
sg51
g251
sg52
g243
sg53
g252
sg54
g260
sg55
g244
stRp1677
ag1
(g1659
g1599
(dp1678
g42
g271
sg43
g263
sg44
g274
sg45
g264
sg46
g265
sg47
g276
sg48
g266
sg49
g267
sg50
g278
sg51
g268
sg52
g269
sg53
S' '
sg54
g280
sg55
g270
stRp1679
ag1
(g1659
g1599
(dp1680
g42
g294
sg43
g288
sg44
g297
sg45
g289
sg46
g290
sg47
g286
sg48
g291
sg49
g282
sg50
g299
sg51
g292
sg52
g284
sg53
g293
sg54
g301
sg55
g285
stRp1681
ag1
(g1659
g1599
(dp1682
g42
g316
sg43
g310
sg44
g319
sg45
g311
sg46
g312
sg47
g308
sg48
g313
sg49
g304
sg50
g321
sg51
g314
sg52
g306
sg53
g315
sg54
g323
sg55
g307
stRp1683
ag1
(g1659
g1599
(dp1684
g42
g334
sg43
g326
sg44
g337
sg45
g327
sg46
g328
sg47
g339
sg48
g329
sg49
g330
sg50
g341
sg51
g331
sg52
g332
sg53
S' '
sg54
g343
sg55
g333
stRp1685
ag1
(g1659
g1599
(dp1686
g42
g357
sg43
g351
sg44
g360
sg45
g352
sg46
g353
sg47
g349
sg48
g354
sg49
g345
sg50
g362
sg51
g355
sg52
g347
sg53
g356
sg54
g364
sg55
g348
stRp1687
ag1
(g1659
g1599
(dp1688
g42
g375
sg43
g367
sg44
g378
sg45
g368
sg46
g369
sg47
g380
sg48
g370
sg49
g371
sg50
g382
sg51
g372
sg52
g373
sg53
S' '
sg54
g384
sg55
g374
stRp1689
ag1
(g1659
g1599
(dp1690
g42
g398
sg43
g392
sg44
g401
sg45
g393
sg46
g394
sg47
g390
sg48
g395
sg49
g386
sg50
g403
sg51
g396
sg52
g388
sg53
g397
sg54
g405
sg55
g389
stRp1691
ag1
(g1659
g1599
(dp1692
g42
g420
sg43
g414
sg44
g423
sg45
g415
sg46
g416
sg47
g412
sg48
g417
sg49
g408
sg50
g425
sg51
g418
sg52
g410
sg53
g419
sg54
g427
sg55
g411
stRp1693
ag1
(g1659
g1599
(dp1694
g42
g442
sg43
g436
sg44
g445
sg45
g437
sg46
g438
sg47
g434
sg48
g439
sg49
g430
sg50
g447
sg51
g440
sg52
g432
sg53
g441
sg54
g449
sg55
g433
stRp1695
ag1
(g1659
g1599
(dp1696
g42
g464
sg43
g458
sg44
g467
sg45
g459
sg46
g460
sg47
g456
sg48
g461
sg49
g452
sg50
g469
sg51
g462
sg52
g454
sg53
g463
sg54
g471
sg55
g455
stRp1697
ag1
(g1659
g1599
(dp1698
g42
g486
sg43
g480
sg44
g489
sg45
g481
sg46
g482
sg47
g478
sg48
g483
sg49
g474
sg50
g491
sg51
g484
sg52
g476
sg53
g485
sg54
g493
sg55
g477
stRp1699
ag1
(g1659
g1599
(dp1700
g42
g508
sg43
g502
sg44
g511
sg45
g503
sg46
g504
sg47
g500
sg48
g505
sg49
g496
sg50
g513
sg51
g506
sg52
g498
sg53
g507
sg54
g515
sg55
g499
stRp1701
ag1
(g1659
g1599
(dp1702
g42
g530
sg43
g524
sg44
g533
sg45
g525
sg46
g526
sg47
g522
sg48
g527
sg49
g518
sg50
g535
sg51
g528
sg52
g520
sg53
g529
sg54
g537
sg55
g521
stRp1703
ag1
(g1659
g1599
(dp1704
g42
g552
sg43
g546
sg44
g555
sg45
g547
sg46
g548
sg47
g544
sg48
g549
sg49
g540
sg50
g557
sg51
g550
sg52
g542
sg53
g551
sg54
g559
sg55
g543
stRp1705
ag1
(g1659
g1599
(dp1706
g42
g574
sg43
g568
sg44
g577
sg45
g569
sg46
g570
sg47
g566
sg48
g571
sg49
g562
sg50
g579
sg51
g572
sg52
g564
sg53
g573
sg54
g581
sg55
g565
stRp1707
ag1
(g1659
g1599
(dp1708
g42
g592
sg43
g584
sg44
g595
sg45
g585
sg46
g586
sg47
g597
sg48
g587
sg49
g588
sg50
g599
sg51
g589
sg52
g590
sg53
S' '
sg54
g601
sg55
g591
stRp1709
ag1
(g1659
g1599
(dp1710
g42
g611
sg43
g603
sg44
g614
sg45
g604
sg46
g605
sg47
g616
sg48
g606
sg49
g607
sg50
g618
sg51
g608
sg52
g609
sg53
S' '
sg54
g620
sg55
g610
stRp1711
ag1
(g1659
g1599
(dp1712
g42
g634
sg43
g628
sg44
g637
sg45
g629
sg46
g630
sg47
g626
sg48
g631
sg49
g622
sg50
g639
sg51
g632
sg52
g624
sg53
g633
sg54
g641
sg55
g625
stRp1713
ag1
(g1659
g1599
(dp1714
g42
g652
sg43
g644
sg44
g655
sg45
g645
sg46
g646
sg47
g657
sg48
g647
sg49
g648
sg50
g659
sg51
g649
sg52
g650
sg53
S' '
sg54
g661
sg55
g651
stRp1715
ag1
(g1659
g1599
(dp1716
g42
g671
sg43
g663
sg44
g674
sg45
g664
sg46
g665
sg47
g676
sg48
g666
sg49
g667
sg50
g678
sg51
g668
sg52
g669
sg53
S' '
sg54
g680
sg55
g670
stRp1717
ag1
(g1659
g1599
(dp1718
g42
g694
sg43
g688
sg44
g697
sg45
g689
sg46
g690
sg47
g686
sg48
g691
sg49
g682
sg50
g699
sg51
g692
sg52
g684
sg53
g693
sg54
g701
sg55
g685
stRp1719
ag1
(g1659
g1599
(dp1720
g42
g716
sg43
g710
sg44
g719
sg45
g711
sg46
g712
sg47
g708
sg48
g713
sg49
g704
sg50
g721
sg51
g714
sg52
g706
sg53
g715
sg54
g723
sg55
g707
stRp1721
ag1
(g1659
g1599
(dp1722
g42
g734
sg43
g726
sg44
g737
sg45
g727
sg46
g728
sg47
g739
sg48
g729
sg49
g730
sg50
g741
sg51
g731
sg52
g732
sg53
S' '
sg54
g743
sg55
g733
stRp1723
ag1
(g1659
g1599
(dp1724
g42
g757
sg43
g751
sg44
g760
sg45
g752
sg46
g753
sg47
g749
sg48
g754
sg49
g745
sg50
g762
sg51
g755
sg52
g747
sg53
g756
sg54
g764
sg55
g748
stRp1725
ag1
(g1659
g1599
(dp1726
g42
g775
sg43
g767
sg44
g778
sg45
g768
sg46
g769
sg47
g780
sg48
g770
sg49
g771
sg50
g782
sg51
g772
sg52
g773
sg53
S' '
sg54
g784
sg55
g774
stRp1727
ag1
(g1659
g1599
(dp1728
g42
g798
sg43
g792
sg44
g801
sg45
g793
sg46
g794
sg47
g790
sg48
g795
sg49
g786
sg50
g803
sg51
g796
sg52
g788
sg53
g797
sg54
g805
sg55
g789
stRp1729
ag1
(g1659
g1599
(dp1730
g42
g820
sg43
g814
sg44
g823
sg45
g815
sg46
g816
sg47
g812
sg48
g817
sg49
g808
sg50
g825
sg51
g818
sg52
g810
sg53
g819
sg54
g827
sg55
g811
stRp1731
ag1
(g1659
g1599
(dp1732
g42
g842
sg43
g836
sg44
g845
sg45
g837
sg46
g838
sg47
g834
sg48
g839
sg49
g830
sg50
g847
sg51
g840
sg52
g832
sg53
g841
sg54
g849
sg55
g833
stRp1733
ag1
(g1659
g1599
(dp1734
g42
g860
sg43
g852
sg44
g863
sg45
g853
sg46
g854
sg47
g865
sg48
g855
sg49
g856
sg50
g867
sg51
g857
sg52
g858
sg53
S' '
sg54
g869
sg55
g859
stRp1735
ag1
(g1659
g1599
(dp1736
g42
g883
sg43
g877
sg44
g886
sg45
g878
sg46
g879
sg47
g875
sg48
g880
sg49
g871
sg50
g888
sg51
g881
sg52
g873
sg53
g882
sg54
g890
sg55
g874
stRp1737
ag1
(g1659
g1599
(dp1738
g42
g905
sg43
g899
sg44
g908
sg45
g900
sg46
g901
sg47
g897
sg48
g902
sg49
g893
sg50
g910
sg51
g903
sg52
g895
sg53
g904
sg54
g912
sg55
g896
stRp1739
ag1
(g1659
g1599
(dp1740
g42
g927
sg43
g921
sg44
g930
sg45
g922
sg46
g923
sg47
g919
sg48
g924
sg49
g915
sg50
g932
sg51
g925
sg52
g917
sg53
g926
sg54
g934
sg55
g918
stRp1741
ag1
(g1659
g1599
(dp1742
g42
g949
sg43
g943
sg44
g952
sg45
g944
sg46
g945
sg47
g941
sg48
g946
sg49
g937
sg50
g954
sg51
g947
sg52
g939
sg53
g948
sg54
g956
sg55
g940
stRp1743
ag1
(g1659
g1599
(dp1744
g42
g967
sg43
g959
sg44
g970
sg45
g960
sg46
g961
sg47
g972
sg48
g962
sg49
g963
sg50
g974
sg51
g964
sg52
g965
sg53
S' '
sg54
g976
sg55
g966
stRp1745
ag1
(g1659
g1599
(dp1746
g42
g989
sg43
g984
sg44
g992
sg45
g985
sg46
g986
sg47
g982
sg48
g987
sg49
g978
sg50
g994
sg51
g418
sg52
g980
sg53
g988
sg54
g996
sg55
g981
stRp1747
ag1
(g1659
g1599
(dp1748
g42
g1011
sg43
g1005
sg44
g1014
sg45
g1006
sg46
g1007
sg47
g1003
sg48
g1008
sg49
g999
sg50
g1016
sg51
g1009
sg52
g1001
sg53
g1010
sg54
g1018
sg55
g1002
stRp1749
ag1
(g1659
g1599
(dp1750
g42
g1033
sg43
g1027
sg44
g1036
sg45
g1028
sg46
g1029
sg47
g1025
sg48
g1030
sg49
g1021
sg50
g1038
sg51
g1031
sg52
g1023
sg53
g1032
sg54
g1040
sg55
g1024
stRp1751
ag1
(g1659
g1599
(dp1752
g42
g1055
sg43
g1049
sg44
g1058
sg45
g1050
sg46
g1051
sg47
g1047
sg48
g1052
sg49
g1043
sg50
g1060
sg51
g1053
sg52
g1045
sg53
g1054
sg54
g1062
sg55
g1046
stRp1753
ag1
(g1659
g1599
(dp1754
g42
g1077
sg43
g1071
sg44
g1080
sg45
g1072
sg46
g1073
sg47
g1069
sg48
g1074
sg49
g1065
sg50
g1082
sg51
g1075
sg52
g1067
sg53
g1076
sg54
g1084
sg55
g1068
stRp1755
ag1
(g1659
g1599
(dp1756
g42
g1095
sg43
g1087
sg44
g1098
sg45
g1088
sg46
g1089
sg47
g1100
sg48
g1090
sg49
g1091
sg50
g1102
sg51
g1092
sg52
g1093
sg53
S' '
sg54
g1104
sg55
g1094
stRp1757
ag1
(g1659
g1599
(dp1758
g42
g1114
sg43
g1106
sg44
g1117
sg45
g1107
sg46
g1108
sg47
g1119
sg48
g1109
sg49
g1110
sg50
g1121
sg51
g1111
sg52
g1112
sg53
S' '
sg54
g1123
sg55
g1113
stRp1759
ag1
(g1659
g1599
(dp1760
g42
g1137
sg43
g1131
sg44
g1140
sg45
g1132
sg46
g1133
sg47
g1129
sg48
g1134
sg49
g1125
sg50
g1142
sg51
g1135
sg52
g1127
sg53
g1136
sg54
g1144
sg55
g1128
stRp1761
ag1
(g1659
g1599
(dp1762
g42
g1159
sg43
g1153
sg44
g1162
sg45
g1154
sg46
g1155
sg47
g1151
sg48
g1156
sg49
g1147
sg50
g1164
sg51
g1157
sg52
g1149
sg53
g1158
sg54
g1166
sg55
g1150
stRp1763
ag1
(g1659
g1599
(dp1764
g42
g1177
sg43
g1169
sg44
g1180
sg45
g1170
sg46
g1171
sg47
g1182
sg48
g1172
sg49
g1173
sg50
g1184
sg51
g1174
sg52
g1175
sg53
S' '
sg54
g1186
sg55
g1176
stRp1765
ag1
(g1659
g1599
(dp1766
g42
g1196
sg43
g1188
sg44
g1199
sg45
g1189
sg46
g1190
sg47
g1201
sg48
g1191
sg49
g1192
sg50
g1203
sg51
g1193
sg52
g1194
sg53
S' '
sg54
g1205
sg55
g1195
stRp1767
ag1
(g1659
g1599
(dp1768
g42
g1215
sg43
g1207
sg44
g1218
sg45
g1208
sg46
g1209
sg47
g1220
sg48
g1210
sg49
g1211
sg50
g1222
sg51
g1212
sg52
g1213
sg53
S' '
sg54
g1224
sg55
g1214
stRp1769
ag1
(g1659
g1599
(dp1770
g42
g1238
sg43
g1232
sg44
g1241
sg45
g1233
sg46
g1234
sg47
g1230
sg48
g1235
sg49
g1226
sg50
g1243
sg51
g1236
sg52
g1228
sg53
g1237
sg54
g1245
sg55
g1229
stRp1771
ag1
(g1659
g1599
(dp1772
g42
g1260
sg43
g1254
sg44
g1263
sg45
g1255
sg46
g1256
sg47
g1252
sg48
g1257
sg49
g1248
sg50
g1265
sg51
g1258
sg52
g1250
sg53
g1259
sg54
g1267
sg55
g1251
stRp1773
ag1
(g1659
g1599
(dp1774
g42
g1282
sg43
g1276
sg44
g1285
sg45
g1277
sg46
g1278
sg47
g1274
sg48
g1279
sg49
g1270
sg50
g1287
sg51
g1280
sg52
g1272
sg53
g1281
sg54
g1289
sg55
g1273
stRp1775
ag1
(g1659
g1599
(dp1776
g42
g1300
sg43
g1292
sg44
g1303
sg45
g1293
sg46
g1294
sg47
g1305
sg48
g1295
sg49
g1296
sg50
g1307
sg51
g1297
sg52
g1298
sg53
S' '
sg54
g1309
sg55
g1299
stRp1777
ag1
(g1659
g1599
(dp1778
g42
g1319
sg43
g1311
sg44
g1322
sg45
g1312
sg46
g1313
sg47
g1324
sg48
g1314
sg49
g1315
sg50
g1326
sg51
g1316
sg52
g1317
sg53
S' '
sg54
g1328
sg55
g1318
stRp1779
ag1
(g1659
g1599
(dp1780
g42
g1342
sg43
g1336
sg44
g1345
sg45
g1337
sg46
g1338
sg47
g1334
sg48
g1339
sg49
g1330
sg50
g1347
sg51
g1340
sg52
g1332
sg53
g1341
sg54
g1349
sg55
g1333
stRp1781
ag1
(g1659
g1599
(dp1782
g42
g1364
sg43
g1358
sg44
g1367
sg45
g1359
sg46
g1360
sg47
g1356
sg48
g1361
sg49
g1352
sg50
g1369
sg51
g1362
sg52
g1354
sg53
g1363
sg54
g1371
sg55
g1355
stRp1783
ag1
(g1659
g1599
(dp1784
g42
g1386
sg43
g1380
sg44
g1389
sg45
g1381
sg46
g1382
sg47
g1378
sg48
g1383
sg49
g1374
sg50
g1391
sg51
g1384
sg52
g1376
sg53
g1385
sg54
g1393
sg55
g1377
stRp1785
ag1
(g1659
g1599
(dp1786
g42
g1404
sg43
g1396
sg44
g1407
sg45
g1397
sg46
g1398
sg47
g1409
sg48
g1399
sg49
g1400
sg50
g1411
sg51
g1401
sg52
g1402
sg53
S' '
sg54
g1413
sg55
g1403
stRp1787
ag1
(g1659
g1599
(dp1788
g42
g1427
sg43
g1421
sg44
g1430
sg45
g1422
sg46
g1423
sg47
g1419
sg48
g1424
sg49
g1415
sg50
g1432
sg51
g1425
sg52
g1417
sg53
g1426
sg54
g1434
sg55
g1418
stRp1789
ag1
(g1659
g1599
(dp1790
g42
g1449
sg43
g1443
sg44
g1452
sg45
g1444
sg46
g1445
sg47
g1441
sg48
g1446
sg49
g1437
sg50
g1454
sg51
g1447
sg52
g1439
sg53
g1448
sg54
g1456
sg55
g1440
stRp1791
ag1
(g1659
g1599
(dp1792
g42
g1467
sg43
g1459
sg44
g1470
sg45
g1460
sg46
g1461
sg47
g1472
sg48
g1462
sg49
g1463
sg50
g1474
sg51
g1464
sg52
g1465
sg53
S' '
sg54
g1476
sg55
g1466
stRp1793
ag1
(g1659
g1599
(dp1794
g42
g1490
sg43
g1484
sg44
g1493
sg45
g1485
sg46
g1486
sg47
g1482
sg48
g1487
sg49
g1478
sg50
g1495
sg51
g1488
sg52
g1480
sg53
g1489
sg54
g1497
sg55
g1481
stRp1795
ag1
(g1659
g1599
(dp1796
g42
g1508
sg43
g1500
sg44
g1511
sg45
g1501
sg46
g1502
sg47
g1513
sg48
g1503
sg49
g1504
sg50
g1515
sg51
g1505
sg52
g1506
sg53
S' '
sg54
g1517
sg55
g1507
stRp1797
ag1
(g1659
g1599
(dp1798
g42
g1527
sg43
g1519
sg44
g1530
sg45
g1520
sg46
g1521
sg47
g1532
sg48
g1522
sg49
g1523
sg50
g1534
sg51
g1524
sg52
g1525
sg53
S' '
sg54
g1536
sg55
g1526
stRp1799
ag1
(g1659
g1599
(dp1800
g42
g1550
sg43
g1544
sg44
g1553
sg45
g1545
sg46
g1546
sg47
g1542
sg48
g1547
sg49
g1538
sg50
g1555
sg51
g1548
sg52
g1540
sg53
g1549
sg54
g1557
sg55
g1541
stRp1801
ag1
(g1659
g1599
(dp1802
g42
g1572
sg43
g1566
sg44
g1575
sg45
g1567
sg46
g1568
sg47
g1564
sg48
g1569
sg49
g1560
sg50
g1577
sg51
g1570
sg52
g1562
sg53
g1571
sg54
g1579
sg55
g1563
stRp1803
asS'seed'
p1804
NsS'thisIndex'
p1805
g1574
sS'thisN'
p1806
I72
sS'thisTrialN'
p1807
I0
sS'nTotal'
p1808
I72
sS'_warnUseOfNext'
p1809
I01
sbasS'savePickle'
p1810
I00
sb.