ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Users/jason/Dropbox/SteffenerColumbia/Scripts/ExperimentalStimuli/PartialTrialDIR/Scripts/PsychoPyTask/data/2002_1_PartialTrial_2016_Jan_25_1442
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'PartialTrial'
p11
sS'dataNames'
p12
(lp13
S'ScannerTrigger.keys'
p14
aS'ScannerTrigger.rt'
p15
aS'TrialStartTime'
p16
aS'KeyboardResp.keys'
p17
aS'KeyboardResp.corr'
p18
aS'KeyboardResp.rt'
p19
asS'autoLog'
p20
I01
sS'extraInfo'
p21
(dp22
VParticipant ID
p23
S'2002'
p24
sS'date'
p25
V2016_Jan_25_1442
p26
sS'expName'
p27
g11
sVVisit ID
p28
S'1'
sS'frameRate'
p29
cnumpy.core.multiarray
scalar
p30
(cnumpy
dtype
p31
(S'f8'
I0
I1
tRp32
(I3
S'<'
NNNI-1
I-1
I0
tbS'&\xc6\xeas\xad\x00N@'
tRp33
ssS'loopsUnfinished'
p34
(lp35
sS'saveWideText'
p36
I01
sS'thisEntry'
p37
(dp38
sS'version'
p39
S''
sS'_paramNamesSoFar'
p40
(lp41
S'RetDur'
p42
aS'BotBrack'
p43
aS'StimDur'
p44
aS'UpBrack'
p45
aS'ProbeDurITI'
p46
aS'ProbeDur'
p47
aS'ProbeStart'
p48
aS'TrialDur'
p49
aS'ITI'
p50
aS'StimSet'
p51
aS'RetStart'
p52
aS'ProbeLet'
p53
aS'TrialITIDur'
p54
aS'Correct'
p55
asS'entries'
p56
(lp57
(dp58
g23
g24
sS'trials.thisIndex'
p59
I0
sg27
g11
sg28
S'1'
sS'trials.thisRepN'
p60
I0
sg29
g33
sS'trials.thisN'
p61
I-1
sg15
F9.8925728797912598
sS'trials.thisTrialN'
p62
I-1
sg25
g26
sg14
S'equal'
p63
sa(dp64
g23
g24
sS'trials.thisIndex'
p65
I0
sg28
S'1'
sS'trials.thisRepN'
p66
I0
sg29
g33
sg16
F1453750936.0925031
sS'trials.thisN'
p67
I-1
sg27
g11
sS'trials.thisTrialN'
p68
I-1
sg25
g26
sa(dp69
g23
g24
sg27
g11
sg43
g30
(g31
(S'i8'
I0
I1
tRp70
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp71
sg45
g30
(g70
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp72
sg46
g30
(g32
S'\x7fj\xbct\x93\x18\x10@'
tRp73
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp74
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp75
sg51
S'QGHFKR'
p76
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp77
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp78
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp79
sS'trials.thisIndex'
p80
g30
(g31
(S'i4'
I0
I1
tRp81
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00'
tRp82
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp83
sS'trials.thisRepN'
p84
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp85
sg16
F1453750946.0954609
sg29
g33
sS'trials.thisN'
p86
I0
sg50
g30
(g32
S'\x7fj\xbct\x93\x18\x10@'
tRp87
sS'trials.thisTrialN'
p88
I0
sg54
g30
(g32
S'@5^\xbaI\x0c&@'
tRp89
sg17
Nsa(dp90
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp91
sg45
g30
(g70
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp92
sg46
g30
(g32
S'\x85\xebQ\xb8\x1e\x85\x10@'
tRp93
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp94
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp95
sg51
S'XDJLTM'
p96
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp97
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp98
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp99
sS'trials.thisIndex'
p100
g30
(g81
S'\x01\x00\x00\x00'
tRp101
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp102
sS'trials.thisRepN'
p103
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp104
sg16
F1453750957.1160159
sg29
g33
sS'trials.thisN'
p105
I1
sg50
g30
(g32
S'\x85\xebQ\xb8\x1e\x85\x10@'
tRp106
sS'trials.thisTrialN'
p107
I1
sg54
g30
(g32
S'\xc3\xf5(\\\x8fB&@'
tRp108
sg17
Nsa(dp109
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp110
sg19
(lp111
F1.1176290512084961
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp112
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp113
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp114
sg16
F1453750968.236593
sS'trials.thisN'
p115
I2
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp116
sg45
g30
(g70
S')\t\x00\x00\x00\x00\x00\x00'
tRp117
sg46
g30
(g32
S'\xda\xce\xf7S\xe3%\x19@'
tRp118
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp119
sg51
S'XYNBRF'
p120
sg25
g26
sg53
S'gkqdtj'
p121
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp122
sS'trials.thisIndex'
p123
g30
(g81
S'\x02\x00\x00\x00'
tRp124
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp125
sS'trials.thisRepN'
p126
I0
sg50
g30
(g32
S'\xd9\xce\xf7S\xe3%\x11@'
tRp127
sg27
g11
sS'trials.thisTrialN'
p128
I2
sg54
g30
(g32
S'm\xe7\xfb\xa9\xf1\x92*@'
tRp129
sg17
(lp130
S'8'
asa(dp131
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp132
sg19
(lp133
F1.0010161399841309
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp134
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp135
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp136
sg16
F1453750981.525332
sS'trials.thisN'
p137
I3
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp138
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp139
sg46
g30
(g32
S'\xbct\x93\x18\x04\xd6\x18@'
tRp140
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp141
sg51
S'FKMTQG'
p142
sg25
g26
sg53
S'yhdlwb'
p143
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp144
sS'trials.thisIndex'
p145
g30
(g81
S'\x03\x00\x00\x00'
tRp146
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp147
sS'trials.thisRepN'
p148
I0
sg50
g30
(g32
S'\xbct\x93\x18\x04\xd6\x10@'
tRp149
sg27
g11
sS'trials.thisTrialN'
p150
I3
sg54
g30
(g32
S'_\xbaI\x0c\x02k*@'
tRp151
sg17
(lp152
S'8'
asa(dp153
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp154
sg19
(lp155
F0.9175560474395752
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp156
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp157
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp158
sg16
F1453750994.729531
sS'trials.thisN'
p159
I4
sg43
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp160
sg45
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp161
sg46
g30
(g32
S'-\xb2\x9d\xef\xa7F\x1a@'
tRp162
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp163
sg51
S'TNJDWB'
p164
sg25
g26
sg53
S'qxhyfl'
p165
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp166
sS'trials.thisIndex'
p167
g30
(g81
S'\x04\x00\x00\x00'
tRp168
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp169
sS'trials.thisRepN'
p170
I0
sg50
g30
(g32
S'-\xb2\x9d\xef\xa7F\x12@'
tRp171
sg27
g11
sS'trials.thisTrialN'
p172
I4
sg54
g30
(g32
S'\x17\xd9\xce\xf7S#+@'
tRp173
sg17
(lp174
S'8'
asa(dp175
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp176
sg19
(lp177
F0.867156982421875
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp178
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp179
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp180
sg16
F1453751008.3011839
sS'trials.thisN'
p181
I5
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp182
sg45
g30
(g70
S')\t\x00\x00\x00\x00\x00\x00'
tRp183
sg46
g30
(g32
S'\xaeG\xe1z\x14\xae\x1a@'
tRp184
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp185
sg51
S'LRHKMY'
p186
sg25
g26
sg53
S'qgrnfw'
p187
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp188
sS'trials.thisIndex'
p189
g30
(g81
S'\x05\x00\x00\x00'
tRp190
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp191
sS'trials.thisRepN'
p192
I0
sg50
g30
(g32
S'\xaeG\xe1z\x14\xae\x12@'
tRp193
sg27
g11
sS'trials.thisTrialN'
p194
I5
sg54
g30
(g32
S'\xd7\xa3p=\nW!@'
tRp195
sg17
(lp196
S'7'
asa(dp197
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp198
sg19
(lp199
F0.85140204429626465
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp200
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp201
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp202
sg16
F1453751016.970823
sS'trials.thisN'
p203
I6
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp204
sg45
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp205
sg46
g30
(g32
S'\xc3\xf5(\\\x8fB\x1a@'
tRp206
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp207
sg51
S'WRBDHN'
p208
sg25
g26
sg53
S'myqxgl'
p209
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp210
sS'trials.thisIndex'
p211
g30
(g81
S'\x06\x00\x00\x00'
tRp212
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp213
sS'trials.thisRepN'
p214
I0
sg50
g30
(g32
S'\xc3\xf5(\\\x8fB\x12@'
tRp215
sg27
g11
sS'trials.thisTrialN'
p216
I6
sg54
g30
(g32
S'\xe1z\x14\xaeG!+@'
tRp217
sg17
(lp218
S'8'
asa(dp219
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp220
sg19
(lp221
F1.2849628925323486
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp222
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp223
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp224
sg16
F1453751030.5258541
sS'trials.thisN'
p225
I7
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp226
sg45
g30
(g70
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp227
sg46
g30
(g32
S'\xa6\x9b\xc4 \xb0r\x18@'
tRp228
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp229
sg51
S'XLTFHQ'
p230
sg25
g26
sg53
S'rgjdbh'
p231
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp232
sS'trials.thisIndex'
p233
g30
(g81
S'\x07\x00\x00\x00'
tRp234
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp235
sS'trials.thisRepN'
p236
I0
sg50
g30
(g32
S'\xa6\x9b\xc4 \xb0r\x10@'
tRp237
sg27
g11
sS'trials.thisTrialN'
p238
I7
sg54
g30
(g32
S'\xd3Mb\x10X9*@'
tRp239
sg17
(lp240
S'7'
asa(dp241
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp242
sg19
(lp243
F0.98440909385681152
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp244
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp245
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp246
sg16
F1453751043.630563
sS'trials.thisN'
p247
I8
sg43
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp248
sg45
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp249
sg46
g30
(g32
S'333333\x18@'
tRp250
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp251
sg51
S'WBFJTY'
p252
sg25
g26
sg53
S'rmhqyd'
p253
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp254
sS'trials.thisIndex'
p255
g30
(g81
S'\x08\x00\x00\x00'
tRp256
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp257
sS'trials.thisRepN'
p258
I0
sg50
g30
(g32
S'333333\x10@'
tRp259
sg27
g11
sS'trials.thisTrialN'
p260
I8
sg54
g30
(g32
S'\x9a\x99\x99\x99\x99\x19*@'
tRp261
sg17
(lp262
S'7'
asa(dp263
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp264
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp265
sg46
g30
(g32
S'\xd1"\xdb\xf9~j\x10@'
tRp266
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp267
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp268
sg51
S'JGMQFB'
p269
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp270
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp271
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp272
sS'trials.thisIndex'
p273
g30
(g81
S'\t\x00\x00\x00'
tRp274
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp275
sS'trials.thisRepN'
p276
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp277
sg16
F1453751056.685847
sg29
g33
sS'trials.thisN'
p278
I9
sg50
g30
(g32
S'\xd1"\xdb\xf9~j\x10@'
tRp279
sS'trials.thisTrialN'
p280
I9
sg54
g30
(g32
S'\xd1"\xdb\xf9~j\x18@'
tRp281
sg17
Nsa(dp282
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp283
sg19
(lp284
F0.86757802963256836
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp285
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp286
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp287
sg16
F1453751062.787528
sS'trials.thisN'
p288
I10
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp289
sg45
g30
(g70
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp290
sg46
g30
(g32
S'\x00\x00\x00\x00\x00\x80\x18@'
tRp291
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp292
sg51
S'KTMWNL'
p293
sg25
g26
sg53
S'drbgfq'
p294
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp295
sS'trials.thisIndex'
p296
g30
(g81
S'\n\x00\x00\x00'
tRp297
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp298
sS'trials.thisRepN'
p299
I0
sg50
g30
(g32
S'\x00\x00\x00\x00\x00\x80\x10@'
tRp300
sg27
g11
sS'trials.thisTrialN'
p301
I10
sg54
g30
(g32
S'\x00\x00\x00\x00\x00@ @'
tRp302
sg17
(lp303
S'8'
asa(dp304
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp305
sg19
(lp306
F1.2346820831298828
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp307
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp308
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp309
sg16
F1453751070.906755
sS'trials.thisN'
p310
I11
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp311
sg45
g30
(g70
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp312
sg46
g30
(g32
S'\x9a\x99\x99\x99\x99\x19\x18@'
tRp313
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp314
sg51
S'KLQMGW'
p315
sg25
g26
sg53
S'ydjrtb'
p316
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp317
sS'trials.thisIndex'
p318
g30
(g81
S'\x0b\x00\x00\x00'
tRp319
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp320
sS'trials.thisRepN'
p321
I0
sg50
g30
(g32
S'\x9a\x99\x99\x99\x99\x19\x10@'
tRp322
sg27
g11
sS'trials.thisTrialN'
p323
I11
sg54
g30
(g32
S'\xcd\xcc\xcc\xcc\xcc\x0c*@'
tRp324
sg17
(lp325
S'8'
asa(dp326
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp327
sg45
g30
(g70
S'"\x00\x00\x00\x00\x00\x00\x00'
tRp328
sg46
g30
(g32
S'\x9a\x99\x99\x99\x99\x99\x11@'
tRp329
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp330
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp331
sg51
S'KMNFBQ'
p332
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp333
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp334
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp335
sS'trials.thisIndex'
p336
g30
(g81
S'\x0c\x00\x00\x00'
tRp337
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp338
sS'trials.thisRepN'
p339
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp340
sg16
F1453751083.9283459
sg29
g33
sS'trials.thisN'
p341
I12
sg50
g30
(g32
S'\x9a\x99\x99\x99\x99\x99\x11@'
tRp342
sS'trials.thisTrialN'
p343
I12
sg54
g30
(g32
S'\x9a\x99\x99\x99\x99\x99\x19@'
tRp344
sg17
Nsa(dp345
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp346
sg19
(lp347
F0.71780490875244141
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp348
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp349
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp350
sg16
F1453751090.330585
sS'trials.thisN'
p351
I13
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp352
sg45
g30
(g70
S')\t\x00\x00\x00\x00\x00\x00'
tRp353
sg46
g30
(g32
S'\xf3\xfd\xd4x\xe9&\x18@'
tRp354
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp355
sg51
S'GJBMRN'
p356
sg25
g26
sg53
S'hjxlqk'
p357
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp358
sS'trials.thisIndex'
p359
g30
(g81
S'\r\x00\x00\x00'
tRp360
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp361
sS'trials.thisRepN'
p362
I0
sg50
g30
(g32
S'\xf4\xfd\xd4x\xe9&\x10@'
tRp363
sg27
g11
sS'trials.thisTrialN'
p364
I13
sg54
g30
(g32
S'\xfa~j\xbct\x13*@'
tRp365
sg17
(lp366
S'7'
asa(dp367
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp368
sg45
g30
(g70
S'90\x00\x00\x00\x00\x00\x00'
tRp369
sg46
g30
(g32
S'\x14\xaeG\xe1z\x14\x10@'
tRp370
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp371
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp372
sg51
S'YRMBKD'
p373
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp374
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp375
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp376
sS'trials.thisIndex'
p377
g30
(g81
S'\x0e\x00\x00\x00'
tRp378
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp379
sS'trials.thisRepN'
p380
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp381
sg16
F1453751103.368402
sg29
g33
sS'trials.thisN'
p382
I14
sg50
g30
(g32
S'\x14\xaeG\xe1z\x14\x10@'
tRp383
sS'trials.thisTrialN'
p384
I14
sg54
g30
(g32
S'\n\xd7\xa3p=\n&@'
tRp385
sg17
Nsa(dp386
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp387
sg19
(lp388
F1.5515308380126953
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp389
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp390
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp391
sg16
F1453751114.388967
sS'trials.thisN'
p392
I15
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp393
sg45
g30
(g70
S'90\x00\x00\x00\x00\x00\x00'
tRp394
sg46
g30
(g32
S'@5^\xbaI\x8c\x1c@'
tRp395
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp396
sg51
S'WHQBYD'
p397
sg25
g26
sg53
S'gntfrx'
p398
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp399
sS'trials.thisIndex'
p400
g30
(g81
S'\x0f\x00\x00\x00'
tRp401
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp402
sS'trials.thisRepN'
p403
I0
sg50
g30
(g32
S'@5^\xbaI\x8c\x14@'
tRp404
sg27
g11
sS'trials.thisTrialN'
p405
I15
sg54
g30
(g32
S'\xa0\x1a/\xdd$F"@'
tRp406
sg17
(lp407
S'8'
asa(dp408
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp409
sg19
(lp410
F1.1348099708557129
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp411
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp412
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp413
sg16
F1453751123.525697
sS'trials.thisN'
p414
I16
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp415
sg45
g30
(g70
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp416
sg46
g30
(g32
S'\x11X9\xb4\xc8v\x18@'
tRp417
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp418
sg51
S'XYDNTF'
p419
sg25
g26
sg53
S'kgmjwn'
p420
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp421
sS'trials.thisIndex'
p422
g30
(g81
S'\x10\x00\x00\x00'
tRp423
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp424
sS'trials.thisRepN'
p425
I0
sg50
g30
(g32
S'\x11X9\xb4\xc8v\x10@'
tRp426
sg27
g11
sS'trials.thisTrialN'
p427
I16
sg54
g30
(g32
S'\x08\xac\x1cZd;*@'
tRp428
sg17
(lp429
S'7'
asa(dp430
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp431
sg19
(lp432
F0.8179018497467041
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp433
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp434
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp435
sg16
F1453751136.6476841
sS'trials.thisN'
p436
I17
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp437
sg45
g30
(g70
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp438
sg46
g30
(g32
S't\x93\x18\x04V\x8e\x1c@'
tRp439
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp440
sg51
S'LMBRKW'
p441
sg25
g26
sg53
S'fnxgtj'
p442
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp443
sS'trials.thisIndex'
p444
g30
(g81
S'\x11\x00\x00\x00'
tRp445
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp446
sS'trials.thisRepN'
p447
I0
sg50
g30
(g32
S't\x93\x18\x04V\x8e\x14@'
tRp448
sg27
g11
sS'trials.thisTrialN'
p449
I17
sg54
g30
(g32
S'\xbbI\x0c\x02+G,@'
tRp450
sg17
(lp451
S'8'
asa(dp452
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp453
sg19
(lp454
F1.2179849147796631
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp455
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp456
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp457
sg16
F1453751150.7859681
sS'trials.thisN'
p458
I18
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp459
sg45
g30
(g70
S'90\x00\x00\x00\x00\x00\x00'
tRp460
sg46
g30
(g32
S'E\xb6\xf3\xfd\xd4x\x1a@'
tRp461
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp462
sg51
S'MFXWDL'
p463
sg25
g26
sg53
S'jhrbkd'
p464
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp465
sS'trials.thisIndex'
p466
g30
(g81
S'\x12\x00\x00\x00'
tRp467
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp468
sS'trials.thisRepN'
p469
I0
sg50
g30
(g32
S'F\xb6\xf3\xfd\xd4x\x12@'
tRp470
sg27
g11
sS'trials.thisTrialN'
p471
I18
sg54
g30
(g32
S'#\xdb\xf9~j<+@'
tRp472
sg17
(lp473
S'7'
asa(dp474
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp475
sg19
(lp476
F1.3517751693725586
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp477
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp478
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp479
sg16
F1453751164.4071109
sS'trials.thisN'
p480
I19
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp481
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp482
sg46
g30
(g32
S'\x1b/\xdd$\x06\x01\x18@'
tRp483
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp484
sg51
S'JRHKTN'
p485
sg25
g26
sg53
S'mlyxbd'
p486
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp487
sS'trials.thisIndex'
p488
g30
(g81
S'\x13\x00\x00\x00'
tRp489
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp490
sS'trials.thisRepN'
p491
I0
sg50
g30
(g32
S'\x1b/\xdd$\x06\x01\x10@'
tRp492
sg27
g11
sS'trials.thisTrialN'
p493
I19
sg54
g30
(g32
S'\x8d\x97n\x12\x83\x00*@'
tRp494
sg17
(lp495
S'8'
asa(dp496
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp497
sg19
(lp498
F1.0006120204925537
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp499
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp500
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp501
sg16
F1453751177.4117689
sS'trials.thisN'
p502
I20
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp503
sg45
g30
(g70
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp504
sg46
g30
(g32
S'\x00\x00\x00\x00\x00\x00\x18@'
tRp505
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp506
sg51
S'GJDXLW'
p507
sg25
g26
sg53
S'jqmrhf'
p508
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp509
sS'trials.thisIndex'
p510
g30
(g81
S'\x14\x00\x00\x00'
tRp511
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp512
sS'trials.thisRepN'
p513
I0
sg50
g30
(g32
S'\x00\x00\x00\x00\x00\x00\x10@'
tRp514
sg27
g11
sS'trials.thisTrialN'
p515
I20
sg54
g30
(g32
S'\x00\x00\x00\x00\x00\x00 @'
tRp516
sg17
(lp517
S'7'
asa(dp518
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp519
sg19
(lp520
F0.88475418090820312
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp521
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp522
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp523
sg16
F1453751185.4147799
sS'trials.thisN'
p524
I21
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp525
sg45
g30
(g70
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp526
sg46
g30
(g32
S'{\x14\xaeG\xe1z\x18@'
tRp527
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp528
sg51
S'XWMYTB'
p529
sg25
g26
sg53
S'hdnmfk'
p530
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp531
sS'trials.thisIndex'
p532
g30
(g81
S'\x15\x00\x00\x00'
tRp533
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp534
sS'trials.thisRepN'
p535
I0
sg50
g30
(g32
S'{\x14\xaeG\xe1z\x10@'
tRp536
sg27
g11
sS'trials.thisTrialN'
p537
I21
sg54
g30
(g32
S'=\n\xd7\xa3p=*@'
tRp538
sg17
(lp539
S'8'
asa(dp540
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp541
sg19
(lp542
F1.2679409980773926
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp543
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp544
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp545
sg16
F1453751198.5359061
sS'trials.thisN'
p546
I22
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp547
sg45
g30
(g70
S')\t\x00\x00\x00\x00\x00\x00'
tRp548
sg46
g30
(g32
S'_\xbaI\x0c\x02\xab\x19@'
tRp549
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp550
sg51
S'JKFLDH'
p551
sg25
g26
sg53
S'ynqxrg'
p552
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp553
sS'trials.thisIndex'
p554
g30
(g81
S'\x16\x00\x00\x00'
tRp555
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp556
sS'trials.thisRepN'
p557
I0
sg50
g30
(g32
S'^\xbaI\x0c\x02\xab\x11@'
tRp558
sg27
g11
sS'trials.thisTrialN'
p559
I22
sg54
g30
(g32
S'/\xdd$\x06\x81\xd5*@'
tRp560
sg17
(lp561
S'8'
asa(dp562
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp563
sg19
(lp564
F1.4175188541412354
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp565
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp566
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp567
sg16
F1453751211.957305
sS'trials.thisN'
p568
I23
sg43
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp569
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp570
sg46
g30
(g32
S'\x17\xd9\xce\xf7S\xe3\x1f@'
tRp571
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp572
sg51
S'NHWFQR'
p573
sg25
g26
sg53
S'xbktqj'
p574
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp575
sS'trials.thisIndex'
p576
g30
(g81
S'\x17\x00\x00\x00'
tRp577
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp578
sS'trials.thisRepN'
p579
I0
sg50
g30
(g32
S'\x17\xd9\xce\xf7S\xe3\x17@'
tRp580
sg27
g11
sS'trials.thisTrialN'
p581
I23
sg54
g30
(g32
S'\x8cl\xe7\xfb\xa9\xf1#@'
tRp582
sg17
(lp583
S'7'
asa(dp584
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp585
sg45
g30
(g70
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp586
sg46
g30
(g32
S'\x7fj\xbct\x93\x18\x10@'
tRp587
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp588
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp589
sg51
S'QWYKRB'
p590
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp591
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp592
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp593
sS'trials.thisIndex'
p594
g30
(g81
S'\x18\x00\x00\x00'
tRp595
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp596
sS'trials.thisRepN'
p597
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp598
sg16
F1453751221.927942
sg29
g33
sS'trials.thisN'
p599
I24
sg50
g30
(g32
S'\x7fj\xbct\x93\x18\x10@'
tRp600
sS'trials.thisTrialN'
p601
I24
sg54
g30
(g32
S'@5^\xbaI\x0c&@'
tRp602
sg17
Nsa(dp603
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp604
sg45
g30
(g70
S')\t\x00\x00\x00\x00\x00\x00'
tRp605
sg46
g30
(g32
S'5^\xbaI\x0c\x02\x10@'
tRp606
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp607
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp608
sg51
S'HXTQMD'
p609
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp610
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp611
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp612
sS'trials.thisIndex'
p613
g30
(g81
S'\x19\x00\x00\x00'
tRp614
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp615
sS'trials.thisRepN'
p616
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp617
sg16
F1453751232.948338
sg29
g33
sS'trials.thisN'
p618
I25
sg50
g30
(g32
S'5^\xbaI\x0c\x02\x10@'
tRp619
sS'trials.thisTrialN'
p620
I25
sg54
g30
(g32
S'6^\xbaI\x0c\x02\x18@'
tRp621
sg17
Nsa(dp622
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp623
sg19
(lp624
F0.70059895515441895
aF1.3169419765472412
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp625
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp626
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp627
sg16
F1453751238.9506919
sS'trials.thisN'
p628
I26
sg43
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp629
sg45
g30
(g70
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp630
sg46
g30
(g32
S'/\xdd$\x06\x81\x15\x18@'
tRp631
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp632
sg51
S'GRKBTJ'
p633
sg25
g26
sg53
S'nymxql'
p634
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp635
sS'trials.thisIndex'
p636
g30
(g81
S'\x1a\x00\x00\x00'
tRp637
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp638
sS'trials.thisRepN'
p639
I0
sg50
g30
(g32
S'/\xdd$\x06\x81\x15\x10@'
tRp640
sg27
g11
sS'trials.thisTrialN'
p641
I26
sg54
g30
(g32
S'\x97n\x12\x83\xc0\n*@'
tRp642
sg17
(lp643
S'7'
aS'8'
asa(dp644
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp645
sg45
g30
(g70
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp646
sg46
g30
(g32
S'%\x06\x81\x95C\x8b\x11@'
tRp647
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp648
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp649
sg51
S'XTRNKH'
p650
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp651
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp652
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp653
sS'trials.thisIndex'
p654
g30
(g81
S'\x1b\x00\x00\x00'
tRp655
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp656
sS'trials.thisRepN'
p657
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp658
sg16
F1453751251.972446
sg29
g33
sS'trials.thisN'
p659
I27
sg50
g30
(g32
S'%\x06\x81\x95C\x8b\x11@'
tRp660
sS'trials.thisTrialN'
p661
I27
sg54
g30
(g32
S'\x12\x83\xc0\xca\xa1\xc5&@'
tRp662
sg17
Nsa(dp663
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp664
sg45
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp665
sg46
g30
(g32
S'\xf4\xfd\xd4x\xe9&\x10@'
tRp666
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp667
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp668
sg51
S'WLRJNG'
p669
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp670
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp671
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp672
sS'trials.thisIndex'
p673
g30
(g81
S'\x1c\x00\x00\x00'
tRp674
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp675
sS'trials.thisRepN'
p676
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp677
sg16
F1453751263.359982
sg29
g33
sS'trials.thisN'
p678
I28
sg50
g30
(g32
S'\xf4\xfd\xd4x\xe9&\x10@'
tRp679
sS'trials.thisTrialN'
p680
I28
sg54
g30
(g32
S'\xf3\xfd\xd4x\xe9&\x18@'
tRp681
sg17
Nsa(dp682
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp683
sg19
(lp684
F1.2013840675354004
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp685
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp686
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp687
sg16
F1453751269.394815
sS'trials.thisN'
p688
I29
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp689
sg45
g30
(g70
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp690
sg46
g30
(g32
S')\\\x8f\xc2\xf5\xa8\x19@'
tRp691
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp692
sg51
S'XTNJWF'
p693
sg25
g26
sg53
S'ygbqdh'
p694
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp695
sS'trials.thisIndex'
p696
g30
(g81
S'\x1d\x00\x00\x00'
tRp697
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp698
sS'trials.thisRepN'
p699
I0
sg50
g30
(g32
S')\\\x8f\xc2\xf5\xa8\x11@'
tRp700
sg27
g11
sS'trials.thisTrialN'
p701
I29
sg54
g30
(g32
S'\x14\xaeG\xe1z\xd4*@'
tRp702
sg17
(lp703
S'8'
asa(dp704
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp705
sg19
(lp706
F0.96826791763305664
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp707
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp708
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp709
sg16
F1453751282.799171
sS'trials.thisN'
p710
I30
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp711
sg45
g30
(g70
S'\x0c\x00\x00\x00\x00\x00\x00\x00'
tRp712
sg46
g30
(g32
S'O\x8d\x97n\x12\x83\x18@'
tRp713
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp714
sg51
S'KXBLTD'
p715
sg25
g26
sg53
S'mnygrf'
p716
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp717
sS'trials.thisIndex'
p718
g30
(g81
S'\x1e\x00\x00\x00'
tRp719
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp720
sS'trials.thisRepN'
p721
I0
sg50
g30
(g32
S'P\x8d\x97n\x12\x83\x10@'
tRp722
sg27
g11
sS'trials.thisTrialN'
p723
I30
sg54
g30
(g32
S'\xa8\xc6K7\x89A*@'
tRp724
sg17
(lp725
S'8'
asa(dp726
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp727
sg45
g30
(g70
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp728
sg46
g30
(g32
S'\x8f\xc2\xf5(\\\x0f\x10@'
tRp729
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp730
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp731
sg51
S'QRFJDH'
p732
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp733
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp734
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp735
sS'trials.thisIndex'
p736
g30
(g81
S'\x1f\x00\x00\x00'
tRp737
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp738
sS'trials.thisRepN'
p739
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp740
sg16
F1453751295.9209471
sg29
g33
sS'trials.thisN'
p741
I31
sg50
g30
(g32
S'\x8f\xc2\xf5(\\\x0f\x10@'
tRp742
sS'trials.thisTrialN'
p743
I31
sg54
g30
(g32
S'H\xe1z\x14\xae\x07&@'
tRp744
sg17
Nsa(dp745
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp746
sg19
(lp747
F1.0684700012207031
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp748
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp749
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp750
sg16
F1453751306.9414909
sS'trials.thisN'
p751
I32
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp752
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp753
sg46
g30
(g32
S'\x0e-\xb2\x9d\xef\xa7\x18@'
tRp754
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp755
sg51
S'MXRTLF'
p756
sg25
g26
sg53
S'bylqkd'
p757
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp758
sS'trials.thisIndex'
p759
g30
(g81
S' \x00\x00\x00'
tRp760
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp761
sS'trials.thisRepN'
p762
I0
sg50
g30
(g32
S'\x0e-\xb2\x9d\xef\xa7\x10@'
tRp763
sg27
g11
sS'trials.thisTrialN'
p764
I32
sg54
g30
(g32
S'\x88\x16\xd9\xce\xf7S*@'
tRp765
sg17
(lp766
S'7'
asa(dp767
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp768
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp769
sg46
g30
(g32
S'\xc4 \xb0rh\x11\x12@'
tRp770
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp771
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp772
sg51
S'FJKMBQ'
p773
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp774
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp775
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp776
sS'trials.thisIndex'
p777
g30
(g81
S'!\x00\x00\x00'
tRp778
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp779
sS'trials.thisRepN'
p780
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp781
sg16
F1453751320.096216
sg29
g33
sS'trials.thisN'
p782
I33
sg50
g30
(g32
S'\xc4 \xb0rh\x11\x12@'
tRp783
sS'trials.thisTrialN'
p784
I33
sg54
g30
(g32
S'\xc5 \xb0rh\x11\x1a@'
tRp785
sg17
Nsa(dp786
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp787
sg19
(lp788
F1.1512799263000488
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp789
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp790
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp791
sg16
F1453751326.6149709
sS'trials.thisN'
p792
I34
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp793
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp794
sg46
g30
(g32
S'\xb2\x9d\xef\xa7\xc6K\x18@'
tRp795
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp796
sg51
S'YMQHXG'
p797
sg25
g26
sg53
S'twrkjy'
p798
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp799
sS'trials.thisIndex'
p800
g30
(g81
S'"\x00\x00\x00'
tRp801
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp802
sS'trials.thisRepN'
p803
I0
sg50
g30
(g32
S'\xb2\x9d\xef\xa7\xc6K\x10@'
tRp804
sg27
g11
sS'trials.thisTrialN'
p805
I34
sg54
g30
(g32
S'\xda\xce\xf7S\xe3%*@'
tRp806
sg17
(lp807
S'7'
asa(dp808
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp809
sg19
(lp810
F2.0683448314666748
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp811
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp812
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp813
sg16
F1453751339.6866939
sS'trials.thisN'
p814
I35
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp815
sg45
g30
(g70
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp816
sg46
g30
(g32
S'\x85\xebQ\xb8\x1e\x05\x1d@'
tRp817
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp818
sg51
S'JFRBMN'
p819
sg25
g26
sg53
S'nhgxqt'
p820
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp821
sS'trials.thisIndex'
p822
g30
(g81
S'#\x00\x00\x00'
tRp823
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp824
sS'trials.thisRepN'
p825
I0
sg50
g30
(g32
S'\x85\xebQ\xb8\x1e\x05\x15@'
tRp826
sg27
g11
sS'trials.thisTrialN'
p827
I35
sg54
g30
(g32
S'\xc3\xf5(\\\x8f\x82,@'
tRp828
sg17
(lp829
S'7'
asa(dp830
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp831
sg19
(lp832
F1.117682933807373
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp833
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp834
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp835
sg16
F1453751353.9425759
sS'trials.thisN'
p836
I36
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp837
sg45
g30
(g70
S'90\x00\x00\x00\x00\x00\x00'
tRp838
sg46
g30
(g32
S'\xaa\xf1\xd2Mb\x10\x1a@'
tRp839
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp840
sg51
S'GMBFLX'
p841
sg25
g26
sg53
S'hqydrt'
p842
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp843
sS'trials.thisIndex'
p844
g30
(g81
S'$\x00\x00\x00'
tRp845
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp846
sS'trials.thisRepN'
p847
I0
sg50
g30
(g32
S'\xaa\xf1\xd2Mb\x10\x12@'
tRp848
sg27
g11
sS'trials.thisTrialN'
p849
I36
sg54
g30
(g32
S'\xd4x\xe9&1\x08+@'
tRp850
sg17
(lp851
S'8'
asa(dp852
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp853
sg45
g30
(g70
S'90\x00\x00\x00\x00\x00\x00'
tRp854
sg46
g30
(g32
S'Nb\x10X94\x11@'
tRp855
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp856
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp857
sg51
S'MGJHDF'
p858
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp859
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp860
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp861
sS'trials.thisIndex'
p862
g30
(g81
S'%\x00\x00\x00'
tRp863
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp864
sS'trials.thisRepN'
p865
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp866
sg16
F1453751367.4636431
sg29
g33
sS'trials.thisN'
p867
I37
sg50
g30
(g32
S'Nb\x10X94\x11@'
tRp868
sS'trials.thisTrialN'
p869
I37
sg54
g30
(g32
S'Nb\x10X94\x19@'
tRp870
sg17
Nsa(dp871
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp872
sg19
(lp873
F1.6013050079345703
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp874
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp875
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp876
sg16
F1453751373.76544
sS'trials.thisN'
p877
I38
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp878
sg45
g30
(g70
S'\xc8\x01\x00\x00\x00\x00\x00\x00'
tRp879
sg46
g30
(g32
S'\x9a\x99\x99\x99\x99\x19\x18@'
tRp880
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp881
sg51
S'WMJNLK'
p882
sg25
g26
sg53
S'tdyxhb'
p883
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp884
sS'trials.thisIndex'
p885
g30
(g81
S'&\x00\x00\x00'
tRp886
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp887
sS'trials.thisRepN'
p888
I0
sg50
g30
(g32
S'\x9a\x99\x99\x99\x99\x19\x10@'
tRp889
sg27
g11
sS'trials.thisTrialN'
p890
I38
sg54
g30
(g32
S'\xcd\xcc\xcc\xcc\xcc\x0c @'
tRp891
sg17
(lp892
S'8'
asa(dp893
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp894
sg19
(lp895
F1.4349150657653809
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp896
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp897
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp898
sg16
F1453751381.7850959
sS'trials.thisN'
p899
I39
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp900
sg45
g30
(g70
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp901
sg46
g30
(g32
S'sh\x91\xed|?\x19@'
tRp902
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp903
sg51
S'QGMLKT'
p904
sg25
g26
sg53
S'qhyndw'
p905
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp906
sS'trials.thisIndex'
p907
g30
(g81
S"'\x00\x00\x00"
tRp908
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp909
sS'trials.thisRepN'
p910
I0
sg50
g30
(g32
S'sh\x91\xed|?\x11@'
tRp911
sg27
g11
sS'trials.thisTrialN'
p912
I39
sg54
g30
(g32
S':\xb4\xc8v\xbe\x9f*@'
tRp913
sg17
(lp914
S'7'
asa(dp915
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp916
sg19
(lp917
F0.78489184379577637
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp918
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp919
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp920
sg16
F1453751395.0902381
sS'trials.thisN'
p921
I40
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp922
sg45
g30
(g70
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp923
sg46
g30
(g32
S'O\x8d\x97n\x12\x03\x18@'
tRp924
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp925
sg51
S'NHQMRX'
p926
sg25
g26
sg53
S'ljhtbw'
p927
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp928
sS'trials.thisIndex'
p929
g30
(g81
S'(\x00\x00\x00'
tRp930
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp931
sS'trials.thisRepN'
p932
I0
sg50
g30
(g32
S'P\x8d\x97n\x12\x03\x10@'
tRp933
sg27
g11
sS'trials.thisTrialN'
p934
I40
sg54
g30
(g32
S'\xa8\xc6K7\x89\x01*@'
tRp935
sg17
(lp936
S'7'
asa(dp937
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp938
sg19
(lp939
F0.93426895141601562
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp940
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp941
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp942
sg16
F1453751408.0946479
sS'trials.thisN'
p943
I41
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp944
sg45
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp945
sg46
g30
(g32
S'ffffff\x1a@'
tRp946
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp947
sg51
S'NTKWBY'
p948
sg25
g26
sg53
S'dxmrgw'
p949
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp950
sS'trials.thisIndex'
p951
g30
(g81
S')\x00\x00\x00'
tRp952
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp953
sS'trials.thisRepN'
p954
I0
sg50
g30
(g32
S'ffffff\x12@'
tRp955
sg27
g11
sS'trials.thisTrialN'
p956
I41
sg54
g30
(g32
S'333333!@'
tRp957
sg17
(lp958
S'7'
asa(dp959
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp960
sg45
g30
(g70
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp961
sg46
g30
(g32
S"\x0e-\xb2\x9d\xef'\x10@"
tRp962
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp963
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp964
sg51
S'YLTXNK'
p965
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp966
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp967
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp968
sS'trials.thisIndex'
p969
g30
(g81
S'*\x00\x00\x00'
tRp970
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp971
sS'trials.thisRepN'
p972
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp973
sg16
F1453751416.6972051
sg29
g33
sS'trials.thisN'
p974
I42
sg50
g30
(g32
S"\x0e-\xb2\x9d\xef'\x10@"
tRp975
sS'trials.thisTrialN'
p976
I42
sg54
g30
(g32
S"\x0e-\xb2\x9d\xef'\x18@"
tRp977
sg17
Nsa(dp978
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp979
sg19
(lp980
F0.96798491477966309
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp981
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp982
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp983
sg16
F1453751422.732574
sS'trials.thisN'
p984
I43
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp985
sg45
g30
(g70
S'\xc8\x01\x00\x00\x00\x00\x00\x00'
tRp986
sg46
g30
(g32
S'J\x0c\x02+\x87\x96\x18@'
tRp987
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp988
sg51
g419
sg25
g26
sg53
S'btmrgk'
p989
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp990
sS'trials.thisIndex'
p991
g30
(g81
S'+\x00\x00\x00'
tRp992
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp993
sS'trials.thisRepN'
p994
I0
sg50
g30
(g32
S'J\x0c\x02+\x87\x96\x10@'
tRp995
sg27
g11
sS'trials.thisTrialN'
p996
I43
sg54
g30
(g32
S'%\x06\x81\x95CK*@'
tRp997
sg17
(lp998
S'7'
asa(dp999
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1000
sg19
(lp1001
F0.86811494827270508
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1002
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1003
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1004
sg16
F1453751435.871002
sS'trials.thisN'
p1005
I44
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1006
sg45
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1007
sg46
g30
(g32
S'\xfd\xd4x\xe9&\xb1\x18@'
tRp1008
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1009
sg51
S'DHWBGK'
p1010
sg25
g26
sg53
S'grxjnq'
p1011
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1012
sS'trials.thisIndex'
p1013
g30
(g81
S',\x00\x00\x00'
tRp1014
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1015
sS'trials.thisRepN'
p1016
I0
sg50
g30
(g32
S'\xfe\xd4x\xe9&\xb1\x10@'
tRp1017
sg27
g11
sS'trials.thisTrialN'
p1018
I44
sg54
g30
(g32
S'\x7fj\xbct\x93X*@'
tRp1019
sg17
(lp1020
S'7'
asa(dp1021
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1022
sg19
(lp1023
F1.0514571666717529
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1024
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1025
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1026
sg16
F1453751449.0434029
sS'trials.thisN'
p1027
I45
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1028
sg45
g30
(g70
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp1029
sg46
g30
(g32
S'\xfc\xa9\xf1\xd2Mb\x18@'
tRp1030
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1031
sg51
S'BMLJWY'
p1032
sg25
g26
sg53
S'ktnxfh'
p1033
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1034
sS'trials.thisIndex'
p1035
g30
(g81
S'-\x00\x00\x00'
tRp1036
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1037
sS'trials.thisRepN'
p1038
I0
sg50
g30
(g32
S'\xfc\xa9\xf1\xd2Mb\x10@'
tRp1039
sg27
g11
sS'trials.thisTrialN'
p1040
I45
sg54
g30
(g32
S'\xfe\xd4x\xe9&1 @'
tRp1041
sg17
(lp1042
S'8'
asa(dp1043
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1044
sg19
(lp1045
F1.1354060173034668
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1046
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1047
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1048
sg16
F1453751457.1294711
sS'trials.thisN'
p1049
I46
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1050
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1051
sg46
g30
(g32
S'\x03+\x87\x16\xd9\xce\x18@'
tRp1052
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1053
sg51
S'KHGWLF'
p1054
sg25
g26
sg53
S'dqyxtn'
p1055
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1056
sS'trials.thisIndex'
p1057
g30
(g81
S'.\x00\x00\x00'
tRp1058
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1059
sS'trials.thisRepN'
p1060
I0
sg50
g30
(g32
S'\x02+\x87\x16\xd9\xce\x10@'
tRp1061
sg27
g11
sS'trials.thisTrialN'
p1062
I46
sg54
g30
(g32
S'\x81\x95C\x8blg @'
tRp1063
sg17
(lp1064
S'8'
asa(dp1065
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1066
sg19
(lp1067
F1.0677800178527832
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1068
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1069
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1070
sg16
F1453751465.332545
sS'trials.thisN'
p1071
I47
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1072
sg45
g30
(g70
S'90\x00\x00\x00\x00\x00\x00'
tRp1073
sg46
g30
(g32
S'\xc9v\xbe\x9f\x1a\xaf\x1e@'
tRp1074
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1075
sg51
S'KYTQLJ'
p1076
sg25
g26
sg53
S'qxgwrd'
p1077
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1078
sS'trials.thisIndex'
p1079
g30
(g81
S'/\x00\x00\x00'
tRp1080
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1081
sS'trials.thisRepN'
p1082
I0
sg50
g30
(g32
S'\xc9v\xbe\x9f\x1a\xaf\x16@'
tRp1083
sg27
g11
sS'trials.thisTrialN'
p1084
I47
sg54
g30
(g32
S'd;\xdfO\x8dW-@'
tRp1085
sg17
(lp1086
S'7'
asa(dp1087
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1088
sg45
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1089
sg46
g30
(g32
S'\xa8\xc6K7\x89\xc1\x10@'
tRp1090
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1091
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1092
sg51
S'XYLWHD'
p1093
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1094
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1095
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1096
sS'trials.thisIndex'
p1097
g30
(g81
S'0\x00\x00\x00'
tRp1098
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1099
sS'trials.thisRepN'
p1100
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1101
sg16
F1453751480.004077
sg29
g33
sS'trials.thisN'
p1102
I48
sg50
g30
(g32
S'\xa8\xc6K7\x89\xc1\x10@'
tRp1103
sS'trials.thisTrialN'
p1104
I48
sg54
g30
(g32
S'\xa8\xc6K7\x89\xc1\x18@'
tRp1105
sg17
Nsa(dp1106
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1107
sg45
g30
(g70
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp1108
sg46
g30
(g32
S'\xc1\xca\xa1E\xb6s\x11@'
tRp1109
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1110
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1111
sg51
S'LNFKGJ'
p1112
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1113
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1114
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1115
sS'trials.thisIndex'
p1116
g30
(g81
S'1\x00\x00\x00'
tRp1117
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1118
sS'trials.thisRepN'
p1119
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1120
sg16
F1453751486.18942
sg29
g33
sS'trials.thisN'
p1121
I49
sg50
g30
(g32
S'\xc1\xca\xa1E\xb6s\x11@'
tRp1122
sS'trials.thisTrialN'
p1123
I49
sg54
g30
(g32
S'`\xe5\xd0"\xdb\xb9&@'
tRp1124
sg17
Nsa(dp1125
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1126
sg19
(lp1127
F1.0349678993225098
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1128
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1129
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1130
sg16
F1453751497.5433891
sS'trials.thisN'
p1131
I50
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1132
sg45
g30
(g70
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1133
sg46
g30
(g32
S'i\x91\xed|?5\x18@'
tRp1134
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1135
sg51
S'GYHWQK'
p1136
sg25
g26
sg53
S'djxnrf'
p1137
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1138
sS'trials.thisIndex'
p1139
g30
(g81
S'2\x00\x00\x00'
tRp1140
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1141
sS'trials.thisRepN'
p1142
I0
sg50
g30
(g32
S'h\x91\xed|?5\x10@'
tRp1143
sg27
g11
sS'trials.thisTrialN'
p1144
I50
sg54
g30
(g32
S'\xb4\xc8v\xbe\x9f\x1a*@'
tRp1145
sg17
(lp1146
S'8'
asa(dp1147
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1148
sg19
(lp1149
F1.2846889495849609
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1150
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1151
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1152
sg16
F1453751510.59777
sS'trials.thisN'
p1153
I51
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1154
sg45
g30
(g70
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp1155
sg46
g30
(g32
S'\x96C\x8bl\xe7{\x18@'
tRp1156
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1157
sg51
S'RYNLWB'
p1158
sg25
g26
sg53
S'jmtghl'
p1159
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1160
sS'trials.thisIndex'
p1161
g30
(g81
S'3\x00\x00\x00'
tRp1162
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1163
sS'trials.thisRepN'
p1164
I0
sg50
g30
(g32
S'\x96C\x8bl\xe7{\x10@'
tRp1165
sg27
g11
sS'trials.thisTrialN'
p1166
I51
sg54
g30
(g32
S'\xcb\xa1E\xb6\xf3= @'
tRp1167
sg17
(lp1168
S'7'
asa(dp1169
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1170
sg45
g30
(g70
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1171
sg46
g30
(g32
S'\xb6\xf3\xfd\xd4xi\x10@'
tRp1172
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1173
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1174
sg51
S'TYBDRX'
p1175
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1176
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1177
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1178
sS'trials.thisIndex'
p1179
g30
(g81
S'4\x00\x00\x00'
tRp1180
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1181
sS'trials.thisRepN'
p1182
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1183
sg16
F1453751518.7175119
sg29
g33
sS'trials.thisN'
p1184
I52
sg50
g30
(g32
S'\xb6\xf3\xfd\xd4xi\x10@'
tRp1185
sS'trials.thisTrialN'
p1186
I52
sg54
g30
(g32
S'\xb6\xf3\xfd\xd4xi\x18@'
tRp1187
sg17
Nsa(dp1188
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1189
sg45
g30
(g70
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp1190
sg46
g30
(g32
S'\xaeG\xe1z\x14.\x10@'
tRp1191
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1192
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1193
sg51
S'XDYGRT'
p1194
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1195
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1196
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1197
sS'trials.thisIndex'
p1198
g30
(g81
S'5\x00\x00\x00'
tRp1199
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1200
sS'trials.thisRepN'
p1201
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1202
sg16
F1453751524.8195369
sg29
g33
sS'trials.thisN'
p1203
I53
sg50
g30
(g32
S'\xaeG\xe1z\x14.\x10@'
tRp1204
sS'trials.thisTrialN'
p1205
I53
sg54
g30
(g32
S'\xaeG\xe1z\x14.\x18@'
tRp1206
sg17
Nsa(dp1207
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1208
sg45
g30
(g70
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp1209
sg46
g30
(g32
S'\n\xd7\xa3p=\n\x10@'
tRp1210
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1211
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1212
sg51
S'HYDTGR'
p1213
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1214
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1215
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1216
sS'trials.thisIndex'
p1217
g30
(g81
S'6\x00\x00\x00'
tRp1218
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1219
sS'trials.thisRepN'
p1220
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1221
sg16
F1453751530.8548789
sg29
g33
sS'trials.thisN'
p1222
I54
sg50
g30
(g32
S'\n\xd7\xa3p=\n\x10@'
tRp1223
sS'trials.thisTrialN'
p1224
I54
sg54
g30
(g32
S'\n\xd7\xa3p=\n\x18@'
tRp1225
sg17
Nsa(dp1226
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1227
sg19
(lp1228
F0.98492980003356934
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1229
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1230
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1231
sg16
F1453751536.856719
sS'trials.thisN'
p1232
I55
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1233
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1234
sg46
g30
(g32
S'%\x06\x81\x95C\x0b\x18@'
tRp1235
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1236
sg51
S'WNDHRY'
p1237
sg25
g26
sg53
S'txbkml'
p1238
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1239
sS'trials.thisIndex'
p1240
g30
(g81
S'7\x00\x00\x00'
tRp1241
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1242
sS'trials.thisRepN'
p1243
I0
sg50
g30
(g32
S'%\x06\x81\x95C\x0b\x10@'
tRp1244
sg27
g11
sS'trials.thisTrialN'
p1245
I55
sg54
g30
(g32
S'\x12\x83\xc0\xca\xa1\x05*@'
tRp1246
sg17
(lp1247
S'8'
asa(dp1248
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1249
sg19
(lp1250
F0.96755599975585938
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1251
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1252
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1253
sg16
F1453751549.8626449
sS'trials.thisN'
p1254
I56
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1255
sg45
g30
(g70
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp1256
sg46
g30
(g32
S'/\xdd$\x06\x81\x95\x18@'
tRp1257
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1258
sg51
S'NJWFRG'
p1259
sg25
g26
sg53
S'lkqmdj'
p1260
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1261
sS'trials.thisIndex'
p1262
g30
(g81
S'8\x00\x00\x00'
tRp1263
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1264
sS'trials.thisRepN'
p1265
I0
sg50
g30
(g32
S'/\xdd$\x06\x81\x95\x10@'
tRp1266
sg27
g11
sS'trials.thisTrialN'
p1267
I56
sg54
g30
(g32
S'\x97n\x12\x83\xc0J*@'
tRp1268
sg17
(lp1269
S'7'
asa(dp1270
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1271
sg19
(lp1272
F0.80044102668762207
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1273
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1274
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1275
sg16
F1453751563.000859
sS'trials.thisN'
p1276
I57
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1277
sg45
g30
(g70
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp1278
sg46
g30
(g32
S'=\n\xd7\xa3p\xbd\x18@'
tRp1279
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1280
sg51
S'BTXWRQ'
p1281
sg25
g26
sg53
S'mykndj'
p1282
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1283
sS'trials.thisIndex'
p1284
g30
(g81
S'9\x00\x00\x00'
tRp1285
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1286
sS'trials.thisRepN'
p1287
I0
sg50
g30
(g32
S'=\n\xd7\xa3p\xbd\x10@'
tRp1288
sg27
g11
sS'trials.thisTrialN'
p1289
I57
sg54
g30
(g32
S'\x1f\x85\xebQ\xb8^*@'
tRp1290
sg17
(lp1291
S'8'
asa(dp1292
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1293
sg45
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1294
sg46
g30
(g32
S'\xaeG\xe1z\x14.\x10@'
tRp1295
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1296
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1297
sg51
S'MYXJNT'
p1298
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1299
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1300
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1301
sS'trials.thisIndex'
p1302
g30
(g81
S':\x00\x00\x00'
tRp1303
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1304
sS'trials.thisRepN'
p1305
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1306
sg16
F1453751576.1884961
sg29
g33
sS'trials.thisN'
p1307
I58
sg50
g30
(g32
S'\xaeG\xe1z\x14.\x10@'
tRp1308
sS'trials.thisTrialN'
p1309
I58
sg54
g30
(g32
S'\xd7\xa3p=\n\x17&@'
tRp1310
sg17
Nsa(dp1311
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1312
sg45
g30
(g70
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp1313
sg46
g30
(g32
S'y\xe9&1\x08,\x10@'
tRp1314
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1315
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1316
sg51
S'HBYLMQ'
p1317
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1318
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1319
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1320
sS'trials.thisIndex'
p1321
g30
(g81
S';\x00\x00\x00'
tRp1322
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1323
sS'trials.thisRepN'
p1324
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1325
sg16
F1453751587.225708
sg29
g33
sS'trials.thisN'
p1326
I59
sg50
g30
(g32
S'y\xe9&1\x08,\x10@'
tRp1327
sS'trials.thisTrialN'
p1328
I59
sg54
g30
(g32
S'x\xe9&1\x08,\x18@'
tRp1329
sg17
Nsa(dp1330
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1331
sg19
(lp1332
F1.0509920120239258
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1333
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1334
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1335
sg16
F1453751593.261174
sS'trials.thisN'
p1336
I60
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1337
sg45
g30
(g70
S'90\x00\x00\x00\x00\x00\x00'
tRp1338
sg46
g30
(g32
S'i\x91\xed|?\xb5\x19@'
tRp1339
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1340
sg51
S'GLMNYH'
p1341
sg25
g26
sg53
S'knqwxb'
p1342
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1343
sS'trials.thisIndex'
p1344
g30
(g81
S'<\x00\x00\x00'
tRp1345
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1346
sS'trials.thisRepN'
p1347
I0
sg50
g30
(g32
S'h\x91\xed|?\xb5\x11@'
tRp1348
sg27
g11
sS'trials.thisTrialN'
p1349
I60
sg54
g30
(g32
S'\xb4\xc8v\xbe\x9f\xda @'
tRp1350
sg17
(lp1351
S'7'
asa(dp1352
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1353
sg19
(lp1354
F0.86770510673522949
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1355
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1356
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1357
sg16
F1453751601.680876
sS'trials.thisN'
p1358
I61
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1359
sg45
g30
(g70
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp1360
sg46
g30
(g32
S'\xe9&1\x08\xac\x1c\x19@'
tRp1361
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1362
sg51
S'WHXFRB'
p1363
sg25
g26
sg53
S'jdglqm'
p1364
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1365
sS'trials.thisIndex'
p1366
g30
(g81
S'=\x00\x00\x00'
tRp1367
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1368
sS'trials.thisRepN'
p1369
I0
sg50
g30
(g32
S'\xea&1\x08\xac\x1c\x11@'
tRp1370
sg27
g11
sS'trials.thisTrialN'
p1371
I61
sg54
g30
(g32
S't\x93\x18\x04V\x8e*@'
tRp1372
sg17
(lp1373
S'8'
asa(dp1374
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1375
sg19
(lp1376
F0.86770009994506836
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1377
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1378
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1379
sg16
F1453751614.9522719
sS'trials.thisN'
p1380
I62
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1381
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1382
sg46
g30
(g32
S'6^\xbaI\x0c\x02\x18@'
tRp1383
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1384
sg51
S'JRWBTF'
p1385
sg25
g26
sg53
S'lgbnqh'
p1386
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1387
sS'trials.thisIndex'
p1388
g30
(g81
S'>\x00\x00\x00'
tRp1389
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1390
sS'trials.thisRepN'
p1391
I0
sg50
g30
(g32
S'5^\xbaI\x0c\x02\x10@'
tRp1392
sg27
g11
sS'trials.thisTrialN'
p1393
I62
sg54
g30
(g32
S'\x1b/\xdd$\x06\x01*@'
tRp1394
sg17
(lp1395
S'7'
asa(dp1396
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1397
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1398
sg46
g30
(g32
S'\xf8S\xe3\xa5\x9bD\x10@'
tRp1399
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1400
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1401
sg51
S'BDLTMY'
p1402
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1403
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1404
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1405
sS'trials.thisIndex'
p1406
g30
(g81
S'?\x00\x00\x00'
tRp1407
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1408
sS'trials.thisRepN'
p1409
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1410
sg16
F1453751627.9569981
sg29
g33
sS'trials.thisN'
p1411
I63
sg50
g30
(g32
S'\xf8S\xe3\xa5\x9bD\x10@'
tRp1412
sS'trials.thisTrialN'
p1413
I63
sg54
g30
(g32
S'\xfc\xa9\xf1\xd2M"&@'
tRp1414
sg17
Nsa(dp1415
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1416
sg19
(lp1417
F0.91691398620605469
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1418
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1419
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1420
sg16
F1453751639.027128
sS'trials.thisN'
p1421
I64
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1422
sg45
g30
(g70
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp1423
sg46
g30
(g32
S'\xe5\xd0"\xdb\xf9~\x19@'
tRp1424
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1425
sg51
S'QMGDKH'
p1426
sg25
g26
sg53
S'tlxrjy'
p1427
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1428
sS'trials.thisIndex'
p1429
g30
(g81
S'@\x00\x00\x00'
tRp1430
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1431
sS'trials.thisRepN'
p1432
I0
sg50
g30
(g32
S'\xe5\xd0"\xdb\xf9~\x11@'
tRp1433
sg27
g11
sS'trials.thisTrialN'
p1434
I64
sg54
g30
(g32
S'sh\x91\xed|\xbf*@'
tRp1435
sg17
(lp1436
S'8'
asa(dp1437
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1438
sg19
(lp1439
F0.85091590881347656
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1440
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1441
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1442
sg16
F1453751652.399313
sS'trials.thisN'
p1443
I65
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1444
sg45
g30
(g70
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1445
sg46
g30
(g32
S'\x1f\x85\xebQ\xb8\x9e\x18@'
tRp1446
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1447
sg51
S'YWDLHX'
p1448
sg25
g26
sg53
S'tlfbjr'
p1449
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1450
sS'trials.thisIndex'
p1451
g30
(g81
S'A\x00\x00\x00'
tRp1452
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1453
sS'trials.thisRepN'
p1454
I0
sg50
g30
(g32
S'\x1f\x85\xebQ\xb8\x9e\x10@'
tRp1455
sg27
g11
sS'trials.thisTrialN'
p1456
I65
sg54
g30
(g32
S'\x8f\xc2\xf5(\\O*@'
tRp1457
sg17
(lp1458
S'7'
asa(dp1459
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1460
sg45
g30
(g70
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp1461
sg46
g30
(g32
S'\x83\xc0\xca\xa1E6\x10@'
tRp1462
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1463
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1464
sg51
S'HGFJRD'
p1465
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1466
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1467
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1468
sS'trials.thisIndex'
p1469
g30
(g81
S'B\x00\x00\x00'
tRp1470
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1471
sS'trials.thisRepN'
p1472
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1473
sg16
F1453751665.5538681
sg29
g33
sS'trials.thisN'
p1474
I66
sg50
g30
(g32
S'\x83\xc0\xca\xa1E6\x10@'
tRp1475
sS'trials.thisTrialN'
p1476
I66
sg54
g30
(g32
S'A`\xe5\xd0"\x1b&@'
tRp1477
sg17
Nsa(dp1478
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1479
sg19
(lp1480
F1.0347809791564941
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1481
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1482
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1483
sg16
F1453751676.608223
sS'trials.thisN'
p1484
I67
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1485
sg45
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1486
sg46
g30
(g32
S'\xb8\x1e\x85\xebQ8\x18@'
tRp1487
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1488
sg51
S'TNJHXF'
p1489
sg25
g26
sg53
S'xgqrdk'
p1490
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1491
sS'trials.thisIndex'
p1492
g30
(g81
S'C\x00\x00\x00'
tRp1493
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1494
sS'trials.thisRepN'
p1495
I0
sg50
g30
(g32
S'\xb8\x1e\x85\xebQ8\x10@'
tRp1496
sg27
g11
sS'trials.thisTrialN'
p1497
I67
sg54
g30
(g32
S'\\\x8f\xc2\xf5(\x1c*@'
tRp1498
sg17
(lp1499
S'7'
asa(dp1500
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1501
sg45
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1502
sg46
g30
(g32
S'\x04V\x0e-\xb2\x1d\x11@'
tRp1503
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1504
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1505
sg51
S'QWNGHM'
p1506
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1507
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1508
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1509
sS'trials.thisIndex'
p1510
g30
(g81
S'D\x00\x00\x00'
tRp1511
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1512
sS'trials.thisRepN'
p1513
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1514
sg16
F1453751689.6624351
sg29
g33
sS'trials.thisN'
p1515
I68
sg50
g30
(g32
S'\x04V\x0e-\xb2\x1d\x11@'
tRp1516
sS'trials.thisTrialN'
p1517
I68
sg54
g30
(g32
S'\x03+\x87\x16\xd9\x8e&@'
tRp1518
sg17
Nsa(dp1519
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1520
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1521
sg46
g30
(g32
S'R\xb8\x1e\x85\xeb\xd1\x11@'
tRp1522
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1523
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1524
sg51
S'XLNJFR'
p1525
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1526
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1527
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1528
sS'trials.thisIndex'
p1529
g30
(g81
S'E\x00\x00\x00'
tRp1530
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1531
sS'trials.thisRepN'
p1532
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1533
sg16
F1453751700.9328189
sg29
g33
sS'trials.thisN'
p1534
I69
sg50
g30
(g32
S'R\xb8\x1e\x85\xeb\xd1\x11@'
tRp1535
sS'trials.thisTrialN'
p1536
I69
sg54
g30
(g32
S')\\\x8f\xc2\xf5\xe8&@'
tRp1537
sg17
Nsa(dp1538
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1539
sg19
(lp1540
F0.90136408805847168
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1541
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1542
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1543
sg16
F1453751712.387779
sS'trials.thisN'
p1544
I70
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1545
sg45
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1546
sg46
g30
(g32
S'i\x91\xed|?5\x18@'
tRp1547
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1548
sg51
S'DYKFTL'
p1549
sg25
g26
sg53
S'nhqjmr'
p1550
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1551
sS'trials.thisIndex'
p1552
g30
(g81
S'F\x00\x00\x00'
tRp1553
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1554
sS'trials.thisRepN'
p1555
I0
sg50
g30
(g32
S'h\x91\xed|?5\x10@'
tRp1556
sg27
g11
sS'trials.thisTrialN'
p1557
I70
sg54
g30
(g32
S'\xb4\xc8v\xbe\x9f\x1a*@'
tRp1558
sg17
(lp1559
S'8'
asa(dp1560
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1561
sg19
(lp1562
F0.8183140754699707
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1563
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1564
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1565
sg16
F1453751725.441915
sS'trials.thisN'
p1566
I71
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1567
sg45
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1568
sg46
g30
(g32
S'\\\x8f\xc2\xf5(\xdc\x19@'
tRp1569
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1570
sg51
S'BYFQKT'
p1571
sg25
g26
sg53
S'hrxljn'
p1572
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1573
sS'trials.thisIndex'
p1574
g30
(g81
S'G\x00\x00\x00'
tRp1575
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1576
sS'trials.thisRepN'
p1577
I0
sg50
g30
(g32
S'\\\x8f\xc2\xf5(\xdc\x11@'
tRp1578
sg27
g11
sS'trials.thisTrialN'
p1579
I71
sg54
g30
(g32
S'\xaeG\xe1z\x14\xee @'
tRp1580
sg17
(lp1581
S'8'
asa(dp1582
g23
g24
sg27
g11
sg28
S'1'
sg25
g26
sg29
g33
sg16
F1453751733.910784
sa(dp1583
g23
g24
sg27
g11
sg28
S'1'
sg25
g26
sg29
g33
sg16
F1453751743.913491
sa(dp1584
g23
g24
sg27
g11
sg28
S'1'
sg25
g26
sg29
g33
sg16
F1453751743.913552
sasS'loops'
p1585
(lp1586
g1
(cpsychopy.data
TrialHandler
p1587
g3
NtRp1588
(dp1589
S'origin'
p1590
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.01), Thu 24 Sep 2015 11:35:23 AM EDT\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a# from psychopy.hardware.emulator import launchScan\u000aimport time\u000aimport sys\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000aglobal expName\u000aglobal AllowedInputKeys\u000aAllowedInputKeys = ['1', '2','3','4','5','6','7','8','9','down','right']\u000aglobal FullScreenFlag \u000a\u000aFullScreenFlag = True\u000aScreenToUse = 'MacBookPro'\u000aexpName='PartialTrial'\u000a\u000adef TestSomething(subid=9999,visitid=0001):\u000a    expInfo = {u'Visit ID': u'9999', u'Participant ID': u'1'}\u000a    print 'subid is %s'%(subid)\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a    else:\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a    return expInfo\u000a\u000adef PartialTrial(INPUTFILE,subid=9999,visitid=9999):\u000a    #INPUTFILE = 'Optimized60trialsLoads12467_1.xlsx'\u000a    # INPUTFILE = 'TrialListLoads123466_6Repeats_121415_2.csv'\u000a    # INPUTFILE = 'TwoTrials.xlsx'\u000a    IntroTime = 10\u000a    End = 10 # This should be set so that it is at least ten seconds and so the experiment \u000a    # total duration is a multiple of two seconds.\u000a\u000a    MaxLetters = 6\u000a    if MaxLetters == 6:\u000a        SETwrapWidth = 1.5 # The wrap width of text needs to be adjusted based on how manty letters there are\u000a        SETletCycle = 13 # # Spaces are added between letters and this controls the loop which does it\u000a    elif MaxLetters == 7:\u000a        SETwrapWidth = 1.7\u000a        SETletCycle = 15\u000a    expInfo = {u'Visit ID': u'001', u'Participant ID': u''}\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a        if dlg.OK == False: win.close()  # user pressed cancel\u000a    else:\u000a        print "Subid entered is: %s"%(subid)\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a        \u000a    # Store info about the experiment session\u000a\u000a    \u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=True,\u000a        dataFileName=filename)\u000a    #save a log file for detail verbose info\u000a    logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[1366, 768], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor = ScreenToUse, color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'norm')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial"\u000a    trialClock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    \u000a    # THE AIM IS TO \u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=SETwrapWidth, ## Changed from 1.5 because of 7 letters\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=SETwrapWidth,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=SETwrapWidth,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    WaitForScanner = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Waiting for Scanner, press r to advance',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(INPUTFILE),\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a\u000a\u000a    # PRESENT THE SCREEN TO WAIT FOR THE MRI TRIGGER\u000a    #vol = launchScan(win, MR_settings,  mode='Scan')\u000a\u000a    # ########################################################\u000a    # There should be WAITING FOR SCANNER trial here\u000a    # The test2 routine has these parts in it\u000a    #------Prepare to start Routine "ScanWait"-------\u000a    t = 0\u000a    ScanWaitClock = core.Clock()\u000a    ScanWaitClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    ScannerTrigger = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    ScannerTrigger.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    ScanWaitComponents = []\u000a    ScanWaitComponents.append(WaitForScanner)\u000a    ScanWaitComponents.append(ScannerTrigger)\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "ScanWait"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = ScanWaitClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_4* updates\u000a        if t >= 0.0 and WaitForScanner.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            WaitForScanner.tStart = t  # underestimates by a little under one frame\u000a            WaitForScanner.frameNStart = frameN  # exact frame index\u000a            WaitForScanner.setAutoDraw(True)\u000a        \u000a        # *key_resp_3* updates\u000a        if t >= 0.0 and ScannerTrigger.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ScannerTrigger.tStart = t  # underestimates by a little under one frame\u000a            ScannerTrigger.frameNStart = frameN  # exact frame index\u000a            ScannerTrigger.status = STARTED\u000a            # keyboard checking is just starting\u000a            ScannerTrigger.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if ScannerTrigger.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['r','equal'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                ScannerTrigger.keys = theseKeys[-1]  # just the last key pressed\u000a                ScannerTrigger.rt = ScannerTrigger.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ScanWaitComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            \u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "ScanWait"-------\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if ScannerTrigger.keys in ['', [], None]:  # No response was made\u000a       ScannerTrigger.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('ScannerTrigger.keys',ScannerTrigger.keys)\u000a    if ScannerTrigger.keys != None:  # we had a response\u000a        thisExp.addData('ScannerTrigger.rt', ScannerTrigger.rt)\u000a    thisExp.nextEntry()\u000a    # ########################################################\u000a\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a\u000a    # Write out when the experiment begins\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    #------Prepare to start Routine "intro"-------\u000a    t = 0\u000a    introClock = core.Clock()\u000a    introClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(IntroTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    introComponents = []\u000a    introComponents.append(RestCrossHair)\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "intro"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = introClock.getTime()\u000a        \u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_3* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (0.0 + (IntroTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in introComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "intro"-------\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    # ########################################################\u000a\u000a    for thisTrial in trials:\u000a        # Write to the file the time this trial starts\u000a        trials.addData('TrialStartTime',time.time())\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        # ENCODING SET\u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempStimSet = StimSet\u000a        # Letters for space - letter - space - letter ... - space\u000a        StimSet=' '\u000a        for i in tempStimSet:\u000a            StimSet=StimSet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        UpBrackText = ''\u000a        if UpBrack > 0:\u000a            BracketList = list(str(UpBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,SETletCycle,1):   ## Changed from 13 when using 7 letters\u000a                UpBrackText = UpBrackText+' '\u000a            s = list(UpBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            UpBrackText = ''.join(s)\u000a        \u000a        # PROBE \u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempProbeLet = ProbeLet\u000a        # Letters for space - letter - space - letter ... - space\u000a        ProbeLet=' '\u000a        for i in tempProbeLet:\u000a            ProbeLet = ProbeLet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        BotBrackText = ''\u000a        if BotBrack > 0:\u000a            BracketList = list(str(BotBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,SETletCycle,1):   ## Changed from 13 when using 7 letters\u000a                BotBrackText = BotBrackText+' '\u000a            s = list(BotBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            BotBrackText = ''.join(s)\u000a            \u000a        # update component parameters for each repeat\u000a        UpperText.setText(StimSet)\u000a        UpperBrackets.setText(UpBrackText)\u000a        LowerText.setText(ProbeLet)\u000a        LowerBrackets.setText(BotBrackText)\u000a        \u000a        KeyboardResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        KeyboardResp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(TopUpperLine)\u000a        trialComponents.append(UpperText)\u000a        trialComponents.append(UpperBrackets)\u000a        trialComponents.append(BotUpperLine)\u000a        trialComponents.append(TopLowerLine)\u000a        trialComponents.append(LowerText)\u000a        trialComponents.append(LowerBrackets)\u000a        trialComponents.append(BotLowerLine)\u000a        trialComponents.append(TrialCrossHair)\u000a        trialComponents.append(RestCrossHair)\u000a        trialComponents.append(KeyboardResp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            \u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *TopUpperLine* updates\u000a            if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine.frameNStart = frameN  # exact frame index\u000a                TopUpperLine.setAutoDraw(True)\u000a            elif TopUpperLine.status == STARTED and t >= (0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine.setAutoDraw(False)\u000a            \u000a            # *UpperText* updates\u000a            if t >= 0 and UpperText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText.tStart = t  # underestimates by a little under one frame\u000a                UpperText.frameNStart = frameN  # exact frame index\u000a                UpperText.setAutoDraw(True)\u000a            elif UpperText.status == STARTED and t >= (0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets* updates\u000a            if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets.frameNStart = frameN  # exact frame index\u000a                UpperBrackets.setAutoDraw(True)\u000a            elif UpperBrackets.status == STARTED and t >= (0.0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine* updates\u000a            if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine.frameNStart = frameN  # exact frame index\u000a                BotUpperLine.setAutoDraw(True)\u000a            elif BotUpperLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine* updates\u000a            if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine.frameNStart = frameN  # exact frame index\u000a                TopLowerLine.setAutoDraw(True)\u000a            elif TopLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine.setAutoDraw(False)\u000a            \u000a            # *LowerText* updates\u000a            if t >= ProbeStart and LowerText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText.tStart = t  # underestimates by a little under one frame\u000a                LowerText.frameNStart = frameN  # exact frame index\u000a                LowerText.setAutoDraw(True)\u000a            elif LowerText.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets* updates\u000a            if t >= ProbeStart and LowerBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets.frameNStart = frameN  # exact frame index\u000a                LowerBrackets.setAutoDraw(True)\u000a            elif LowerBrackets.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine* updates\u000a            if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine.frameNStart = frameN  # exact frame index\u000a                BotLowerLine.setAutoDraw(True)\u000a            elif BotLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair* updates\u000a            if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair.setAutoDraw(True)\u000a            elif TrialCrossHair.status == STARTED and t >= (0 + (TrialDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= TrialDur and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            elif RestCrossHair.status == STARTED and t >= (TrialDur + (ITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # *KeyboardResp* updates\u000a            if t >= ProbeStart and KeyboardResp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                KeyboardResp.tStart = t  # underestimates by a little under one frame\u000a                KeyboardResp.frameNStart = frameN  # exact frame index\u000a                KeyboardResp.status = STARTED\u000a                # keyboard checking is just starting\u000a                KeyboardResp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif KeyboardResp.status == STARTED and t >= (ProbeStart + (ProbeDurITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                KeyboardResp.status = STOPPED\u000a            if KeyboardResp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    KeyboardResp.keys.extend(theseKeys)  # storing all keys\u000a                    KeyboardResp.rt.append(KeyboardResp.clock.getTime())\u000a                    # was this 'correct'?\u000a                    if (KeyboardResp.keys == str(Correct)) or (KeyboardResp.keys == Correct):\u000a                        KeyboardResp.corr = 1\u000a                    else:\u000a                        KeyboardResp.corr = 0\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(1)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if KeyboardResp.keys in ['', [], None]:  # No response was made\u000a           KeyboardResp.keys=None\u000a           # was no response the correct answer?!\u000a           if str(Correct).lower() == 'none': KeyboardResp.corr = 1  # correct non-response\u000a           else: KeyboardResp.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('KeyboardResp.keys',KeyboardResp.keys)\u000a        trials.addData('KeyboardResp.corr', KeyboardResp.corr)\u000a        if KeyboardResp.keys != None:  # we had a response\u000a            trials.addData('KeyboardResp.rt', KeyboardResp.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    EndTimeClock = core.Clock()\u000a    EndTimeClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(End)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    EndTimeComponents = []\u000a    EndTimeComponents.append(RestCrossHair)\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = EndTimeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        if RestCrossHair.status == STARTED and t >= (0.0 + (End-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in EndTimeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            #win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # ########################################################\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()    \u000a    # completed 1 repeats of 'trials'\u000a    # the Routine "trial" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    win.close()\u000a    #sys.exit()\u000a    return filename\u000a\u000adef PartialTrialFeedback(INPUTFILE,filename,subid=9999,visitid=9999):\u000a    expInfo = {u'Visit ID': u'001', u'Participant ID': u''}\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a        if dlg.OK == False: win.close()  # user pressed cancel\u000a    else:\u000a        print "Subid entered is: %s"%(subid)\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a        \u000a    # Store info about the experiment session\u000a\u000a    \u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    #filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=True,\u000a        dataFileName=filename)\u000a    #save a log file for detail verbose info\u000a    logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=u'testMonitor', color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'use preferences')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial"\u000a    trialClock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=1.7,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=1.7,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=1.5,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    WaitForScanner = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Waiting for Scanner\u005cn Or press r to advance',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    ThankYou = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Merci\u005cnThank you',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    # Initialize components for Routine "Feedback"\u000a    FeedbackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    FeedbackMsg = visual.TextStim(win=win, ori=0, name='FeedbackMsg',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(INPUTFILE),#TrialListShort1#TrialList5Loads6Repeats\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a\u000a\u000a    # PRESENT THE SCREEN TO WAIT FOR THE MRI TRIGGER\u000a    #vol = launchScan(win, MR_settings,  mode='Scan')\u000a\u000a    # ########################################################\u000a    # There should be WAITING FOR SCANNER trial here\u000a    # The test2 routine has these parts in it\u000a    #------Prepare to start Routine "ScanWait"-------\u000a    t = 0\u000a    ScanWaitClock = core.Clock()\u000a    ScanWaitClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    ScannerTrigger = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    ScannerTrigger.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    ScanWaitComponents = []\u000a    ScanWaitComponents.append(WaitForScanner)\u000a    ScanWaitComponents.append(ScannerTrigger)\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "ScanWait"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = ScanWaitClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_4* updates\u000a        if t >= 0.0 and WaitForScanner.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            WaitForScanner.tStart = t  # underestimates by a little under one frame\u000a            WaitForScanner.frameNStart = frameN  # exact frame index\u000a            WaitForScanner.setAutoDraw(True)\u000a        \u000a        # *key_resp_3* updates\u000a        if t >= 0.0 and ScannerTrigger.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ScannerTrigger.tStart = t  # underestimates by a little under one frame\u000a            ScannerTrigger.frameNStart = frameN  # exact frame index\u000a            ScannerTrigger.status = STARTED\u000a            # keyboard checking is just starting\u000a            ScannerTrigger.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if ScannerTrigger.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['5', 'r'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                ScannerTrigger.keys = theseKeys[-1]  # just the last key pressed\u000a                ScannerTrigger.rt = ScannerTrigger.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ScanWaitComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            #core.quit()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "ScanWait"-------\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if ScannerTrigger.keys in ['', [], None]:  # No response was made\u000a       ScannerTrigger.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('ScannerTrigger.keys',ScannerTrigger.keys)\u000a    if ScannerTrigger.keys != None:  # we had a response\u000a        thisExp.addData('ScannerTrigger.rt', ScannerTrigger.rt)\u000a    thisExp.nextEntry()\u000a    # ########################################################\u000a\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a    IntroTime = 5\u000a    # Write out when the experiment begins\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    #------Prepare to start Routine "intro"-------\u000a    t = 0\u000a    introClock = core.Clock()\u000a    introClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(IntroTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    introComponents = []\u000a    introComponents.append(RestCrossHair)\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "intro"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = introClock.getTime()\u000a        \u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_3* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (0.0 + (IntroTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in introComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "intro"-------\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    # ########################################################\u000a\u000a    for thisTrial in trials:\u000a        # Write to the file the time this trial starts\u000a        trials.addData('TrialStartTime',time.time())\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        # ENCODING SET\u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempStimSet = StimSet\u000a        # Letters for space - letter - space - letter ... - space\u000a        StimSet=' '\u000a        for i in tempStimSet:\u000a            StimSet=StimSet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        UpBrackText = ''\u000a        if UpBrack > 0:\u000a            BracketList = list(str(UpBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,13,1):   ## Changed from 13 when using 7 letters\u000a                UpBrackText = UpBrackText+' '\u000a            s = list(UpBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            UpBrackText = ''.join(s)\u000a        \u000a        # PROBE \u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempProbeLet = ProbeLet\u000a        print '%s'%(tempProbeLet)\u000a        # Letters for space - letter - space - letter ... - space\u000a        ProbeLet=' '\u000a        for i in tempProbeLet:\u000a            ProbeLet = ProbeLet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        BotBrackText = ''\u000a        if BotBrack > 0:\u000a            BracketList = list(str(BotBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,13,1):   ## Changed from 13 when using 7 letters\u000a                BotBrackText = BotBrackText+' '\u000a            s = list(BotBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            BotBrackText = ''.join(s)\u000a            \u000a        # update component parameters for each repeat\u000a        UpperText.setText(StimSet)\u000a        UpperBrackets.setText(UpBrackText)\u000a        LowerText.setText(ProbeLet)\u000a        LowerBrackets.setText(BotBrackText)\u000a        \u000a        KeyboardResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        KeyboardResp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(TopUpperLine)\u000a        trialComponents.append(UpperText)\u000a        trialComponents.append(UpperBrackets)\u000a        trialComponents.append(BotUpperLine)\u000a        trialComponents.append(TopLowerLine)\u000a        trialComponents.append(LowerText)\u000a        trialComponents.append(LowerBrackets)\u000a        trialComponents.append(BotLowerLine)\u000a        trialComponents.append(TrialCrossHair)\u000a        trialComponents.append(RestCrossHair)\u000a        trialComponents.append(KeyboardResp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            \u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *TopUpperLine* updates\u000a            if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine.frameNStart = frameN  # exact frame index\u000a                TopUpperLine.setAutoDraw(True)\u000a            elif TopUpperLine.status == STARTED and t >= (0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine.setAutoDraw(False)\u000a            \u000a            # *UpperText* updates\u000a            if t >= 0 and UpperText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText.tStart = t  # underestimates by a little under one frame\u000a                UpperText.frameNStart = frameN  # exact frame index\u000a                UpperText.setAutoDraw(True)\u000a            elif UpperText.status == STARTED and t >= (0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets* updates\u000a            if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets.frameNStart = frameN  # exact frame index\u000a                UpperBrackets.setAutoDraw(True)\u000a            elif UpperBrackets.status == STARTED and t >= (0.0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine* updates\u000a            if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine.frameNStart = frameN  # exact frame index\u000a                BotUpperLine.setAutoDraw(True)\u000a            elif BotUpperLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine* updates\u000a            if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine.frameNStart = frameN  # exact frame index\u000a                TopLowerLine.setAutoDraw(True)\u000a            elif TopLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine.setAutoDraw(False)\u000a            \u000a            # *LowerText* updates\u000a            if t >= ProbeStart and LowerText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText.tStart = t  # underestimates by a little under one frame\u000a                LowerText.frameNStart = frameN  # exact frame index\u000a                LowerText.setAutoDraw(True)\u000a            elif LowerText.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets* updates\u000a            if t >= ProbeStart and LowerBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets.frameNStart = frameN  # exact frame index\u000a                LowerBrackets.setAutoDraw(True)\u000a            elif LowerBrackets.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine* updates\u000a            if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine.frameNStart = frameN  # exact frame index\u000a                BotLowerLine.setAutoDraw(True)\u000a            elif BotLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair* updates\u000a            if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair.setAutoDraw(True)\u000a            elif TrialCrossHair.status == STARTED and t >= (0 + (TrialDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= TrialDur and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            elif RestCrossHair.status == STARTED and t >= (TrialDur + (ITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # *KeyboardResp* updates\u000a            if t >= ProbeStart and KeyboardResp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                KeyboardResp.tStart = t  # underestimates by a little under one frame\u000a                KeyboardResp.frameNStart = frameN  # exact frame index\u000a                KeyboardResp.status = STARTED\u000a                # keyboard checking is just starting\u000a                KeyboardResp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif KeyboardResp.status == STARTED and t >= (ProbeStart + (ProbeDurITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                KeyboardResp.status = STOPPED\u000a            if KeyboardResp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    #KeyboardResp.keys.extend(theseKeys)  # storing all keys\u000a                    KeyboardResp.keys = theseKeys[-1]  # just the last key pressed\u000a                    #KeyboardResp.rt.append(KeyboardResp.clock.getTime())\u000a                    KeyboardResp.rt = KeyboardResp.clock.getTime()\u000a                    # was this 'correct'?\u000a                    # What if the participant responded whenthey were not supposed to?\u000a                    if str(Correct).lower() == 'none':\u000a                        KeyboardResp.corr = -10 # RESPONSE WHEN NONE WAS EXPECTED\u000a                    else:\u000a                        if (KeyboardResp.keys == str(Correct)) or (KeyboardResp.keys == Correct):\u000a                            KeyboardResp.corr = 1 # CORRECT\u000a                        else:\u000a                            KeyboardResp.corr = 0 # INCORRECT\u000a                    # was this 'correct'?\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(1)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if KeyboardResp.keys in ['', [], None]:  # No response was made\u000a           KeyboardResp.keys=None\u000a           # was no response the correct answer?!\u000a           if str(Correct).lower() == 'none': KeyboardResp.corr = 10  # correct non-response\u000a           else: KeyboardResp.corr = -1  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('KeyboardResp.keys',KeyboardResp.keys)\u000a        trials.addData('KeyboardResp.corr', KeyboardResp.corr)\u000a        if KeyboardResp.keys != None:  # we had a response\u000a            trials.addData('KeyboardResp.rt', KeyboardResp.rt)\u000a        thisExp.nextEntry()\u000a        \u000a        \u000a    # ########################################################    \u000a        #------Prepare to start Routine "Feedback"-------\u000a        FeedbackDur = 1.5\u000a        t = 0\u000a        FeedbackClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(FeedbackDur)\u000a        # update component parameters for each repeat\u000a        if KeyboardResp.corr == 1:#stored on last run routine\u000a          msg="Correct! RT=%.3f" %(KeyboardResp.rt)\u000a        elif KeyboardResp.corr == 0:\u000a          msg="Oops! That was wrong"\u000a        elif KeyboardResp.corr == -1:\u000a          msg="No response...miss"\u000a        elif KeyboardResp.corr == 10:\u000a          msg="No response, good!"\u000a        FeedbackMsg.setText(msg)\u000a        # keep track of which components have finished\u000a        FeedbackComponents = []\u000a        FeedbackComponents.append(FeedbackMsg)\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = FeedbackClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *FeedbackMsg* updates\u000a            if t >= 0.0 and FeedbackMsg.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                FeedbackMsg.tStart = t  # underestimates by a little under one frame\u000a                FeedbackMsg.frameNStart = frameN  # exact frame index\u000a                FeedbackMsg.setAutoDraw(True)\u000a            if FeedbackMsg.status == STARTED and t >= (0.0 + (FeedbackDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                FeedbackMsg.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in FeedbackComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback"-------\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a        #------Prepare to start Routine "REST"-------\u000a        t = 0\u000a        RESTClock = core.Clock()\u000a        RESTClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(1.000000)\u000a        # update component parameters for each repeat\u000a        # keep track of which components have finished\u000a        RESTComponents = []\u000a        RESTComponents.append(RestCrossHair)\u000a        for thisComponent in RESTComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "REST"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = RESTClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            if RestCrossHair.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in RESTComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "REST"-------\u000a        for thisComponent in RESTComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        thisExp.nextEntry()\u000a\u000a\u000a    win.flip()\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a    EndTime = 10\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    EndTimeClock = core.Clock()\u000a    EndTimeClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(EndTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    EndTimeComponents = []\u000a    EndTimeComponents.append(RestCrossHair)\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = EndTimeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        if RestCrossHair.status == STARTED and t >= (0.0 + (EndTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in EndTimeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "EndTime"-------\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a            \u000a    # ########################################################        \u000a    # There should be an intro off trial here also\u000a    ThankYouTime = 3\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    ThankYouClock = core.Clock()\u000a    ThankYouClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(ThankYouTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    ThankYouComponents = []\u000a    ThankYouComponents.append(ThankYou)\u000a    for thisComponent in ThankYouComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = ThankYouClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and ThankYou.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ThankYou.tStart = t  # underestimates by a little under one frame\u000a            ThankYou.frameNStart = frameN  # exact frame index\u000a            ThankYou.setAutoDraw(True)\u000a        if ThankYou.status == STARTED and t >= (0.0 + (ThankYouTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            ThankYou.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ThankYouComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "Thank you"-------\u000a    for thisComponent in ThankYouComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)       \u000a    # ########################################################\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()    \u000a    # completed 1 repeats of 'trials'\u000a    win.close()\u000a#    win.close()\u000a\u000adef Instructions():\u000a    # Store info about the experiment session\u000a    expName = u'Instructions'  # from the Builder filename that created this script\u000a    expInfo = {u'session': u'001', u'participant': u''}\u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=False,\u000a        dataFileName=filename)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=u'UbuntuMon', color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'norm')\u000a\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "ButtonPractice"\u000a    ButtonPracticeClock = core.Clock()\u000a    text_28 = visual.TextStim(win=win, ori=0, name='text_28',\u000a        text="First ...\u005cnLet's make sure the buttons work.\u005cnPress the RIGHT INDEX Finger button.",    font='Courier',\u000a        pos=[0,0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    ISI_14 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_14')\u000a    TopUpperLine_14 = visual.Line(win=win, name='TopUpperLine_14',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_14 = visual.TextStim(win=win, ori=0, name='UpperText_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    UpperBrackets_14 = visual.TextStim(win=win, ori=0, name='UpperBrackets_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    BotUpperLine_14 = visual.Line(win=win, name='BotUpperLine_14',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_14 = visual.Line(win=win, name='TopLowerLine_14',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_14 = visual.TextStim(win=win, ori=0, name='LowerText_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    LowerBrackets_14 = visual.TextStim(win=win, ori=0, name='LowerBrackets_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    BotLowerLine_14 = visual.Line(win=win, name='BotLowerLine_14',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_14 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_14',\u000a        text='\u005cn',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    RestCrossHair_14 = visual.TextStim(win=win, ori=0, name='RestCrossHair_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a\u000a    # Initialize components for Routine "Feedback"\u000a    FeedbackClock = core.Clock()\u000a    msg='?????'\u000a    text_25 = visual.TextStim(win=win, ori=0, name='text_25',\u000a        text='default text',    font='Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Initialize components for Routine "ButtonPractice_MIDDLE"\u000a    ButtonPractice_MIDDLEClock = core.Clock()\u000a    text_29 = visual.TextStim(win=win, ori=0, name='text_29',\u000a        text='Press the RIGHT MIDDLE Finger button.',    font='Courier',\u000a        pos=[0,0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    ISI_15 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_15')\u000a    TopUpperLine_15 = visual.Line(win=win, name='TopUpperLine_15',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_15 = visual.TextStim(win=win, ori=0, name='UpperText_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    UpperBrackets_15 = visual.TextStim(win=win, ori=0, name='UpperBrackets_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    BotUpperLine_15 = visual.Line(win=win, name='BotUpperLine_15',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_15 = visual.Line(win=win, name='TopLowerLine_15',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_15 = visual.TextStim(win=win, ori=0, name='LowerText_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    LowerBrackets_15 = visual.TextStim(win=win, ori=0, name='LowerBrackets_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    BotLowerLine_15 = visual.Line(win=win, name='BotLowerLine_15',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_15 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_15',\u000a        text='\u005cn',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    RestCrossHair_15 = visual.TextStim(win=win, ori=0, name='RestCrossHair_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a\u000a    # Initialize components for Routine "Feedback_MIDDLE"\u000a    Feedback_MIDDLEClock = core.Clock()\u000a    msg='?????'\u000a    text_26 = visual.TextStim(win=win, ori=0, name='text_26',\u000a        text='default text',    font=u'Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_2"\u000a    var_6Letters_2Clock = core.Clock()\u000a    text_13 = visual.TextStim(win=win, ori=0, name='text_13',\u000a        text='This is the screen you will see for each trial',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text_16 = visual.TextStim(win=win, ori=0, name='text_16',\u000a        text='With an UPPER Part',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_18 = visual.TextStim(win=win, ori=0, name='text_18',\u000a        text='And a LOWER part',    font='Courier',\u000a        pos=[0,-0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_21 = visual.TextStim(win=win, ori=0, name='text_21',\u000a        text=None,    font='Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_13 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_13')\u000a    TopUpperLine_13 = visual.Line(win=win, name='TopUpperLine_13',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_13 = visual.TextStim(win=win, ori=0, name='UpperText_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_13 = visual.TextStim(win=win, ori=0, name='UpperBrackets_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_13 = visual.Line(win=win, name='BotUpperLine_13',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_13 = visual.Line(win=win, name='TopLowerLine_13',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_13 = visual.TextStim(win=win, ori=0, name='LowerText_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_13 = visual.TextStim(win=win, ori=0, name='LowerBrackets_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_13 = visual.Line(win=win, name='BotLowerLine_13',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_13 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_13',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_13 = visual.TextStim(win=win, ori=0, name='RestCrossHair_13',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_22 = visual.TextStim(win=win, ori=0, name='text_22',\u000a        text='You will also see a cross hair on the screen',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_23 = visual.TextStim(win=win, ori=0, name='text_23',\u000a        text='Either Green',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_24 = visual.TextStim(win=win, ori=0, name='text_24',\u000a        text='Or RED',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_0"\u000a    var_6Letters_0Clock = core.Clock()\u000a    text_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a        text='For this experiment you will see letters at the top of the screen.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.1,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text = visual.TextStim(win=win, ori=0, name='text',\u000a        text='Some of the letters will be enclosed by brackets.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_6 = visual.TextStim(win=win, ori=0, name='text_6',\u000a        text=u'These are the letters to remember.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a        text='The letters will be removed, focus on the green cross hair.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_11 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_11')\u000a    TopUpperLine_11 = visual.Line(win=win, name='TopUpperLine_11',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_11 = visual.TextStim(win=win, ori=0, name='UpperText_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_11 = visual.TextStim(win=win, ori=0, name='UpperBrackets_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_11 = visual.Line(win=win, name='BotUpperLine_11',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_11 = visual.Line(win=win, name='TopLowerLine_11',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_11 = visual.TextStim(win=win, ori=0, name='LowerText_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_11 = visual.TextStim(win=win, ori=0, name='LowerBrackets_11',\u000a        text='  { }        ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_11 = visual.Line(win=win, name='BotLowerLine_11',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_11 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_11',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_11 = visual.TextStim(win=win, ori=0, name='RestCrossHair_11',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_5 = visual.TextStim(win=win, ori=0, name='text_5',\u000a        text='You will then see letters at the bottom.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.1,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a        text='Only one letter will be in brackets.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a    text_8 = visual.TextStim(win=win, ori=0, name='text_8',\u000a        text='You need to decide whether this letter was one that you had to remember.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-18.0)\u000a    text_9 = visual.TextStim(win=win, ori=0, name='text_9',\u000a        text='YES = INDEX finger button\u005cnNO  = MIDDLE finger button',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-19.0)\u000a    text_10 = visual.TextStim(win=win, ori=0, name='text_10',\u000a        text='The trial is then over and the cross hair turns RED.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-20.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_1"\u000a    var_6Letters_1Clock = core.Clock()\u000a    text_11 = visual.TextStim(win=win, ori=0, name='text_11',\u000a        text=u"Let's Repeat",    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_12 = visual.TextStim(win=win, ori=0, name='text_12',\u000a        text='Remember the letters B and C',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_14 = visual.TextStim(win=win, ori=0, name='text_14',\u000a        text=u'Letters are removed',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    ISI_12 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_12')\u000a    TopUpperLine_12 = visual.Line(win=win, name='TopUpperLine_12',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_12 = visual.TextStim(win=win, ori=0, name='UpperText_12',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-5.0)\u000a    UpperBrackets_12 = visual.TextStim(win=win, ori=0, name='UpperBrackets_12',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    BotUpperLine_12 = visual.Line(win=win, name='BotUpperLine_12',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_12 = visual.Line(win=win, name='TopLowerLine_12',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_12 = visual.TextStim(win=win, ori=0, name='LowerText_12',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    LowerBrackets_12 = visual.TextStim(win=win, ori=0, name='LowerBrackets_12',\u000a        text='  { }        ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    BotLowerLine_12 = visual.Line(win=win, name='BotLowerLine_12',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_12 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_12',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-12.0)\u000a    RestCrossHair_12 = visual.TextStim(win=win, ori=0, name='RestCrossHair_12',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    text_17 = visual.TextStim(win=win, ori=0, name='text_17',\u000a        text=u'Are you trying to remember the letter b?',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_19 = visual.TextStim(win=win, ori=0, name='text_19',\u000a        text=u'Yes you are. You would press the INDEX finger button as quickly as possible.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_20 = visual.TextStim(win=win, ori=0, name='text_20',\u000a        text=u'The trial is over and the cross hair turns RED.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "DemoTrialRealTimes"\u000a    DemoTrialRealTimesClock = core.Clock()\u000a    text_44 = visual.TextStim(win=win, ori=0, name='text_44',\u000a        text=u"Let's repeat at the true pace",    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_45 = visual.TextStim(win=win, ori=0, name='text_45',\u000a        text=u'Remember the letters B and C',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_46 = visual.TextStim(win=win, ori=0, name='text_46',\u000a        text=u'Letters are removed',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    ISI_18 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_18')\u000a    TopUpperLine_18 = visual.Line(win=win, name='TopUpperLine_18',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_18 = visual.TextStim(win=win, ori=0, name='UpperText_18',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-5.0)\u000a    UpperBrackets_18 = visual.TextStim(win=win, ori=0, name='UpperBrackets_18',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    BotUpperLine_18 = visual.Line(win=win, name='BotUpperLine_18',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_18 = visual.Line(win=win, name='TopLowerLine_18',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_17 = visual.TextStim(win=win, ori=0, name='LowerText_17',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    LowerBrackets_17 = visual.TextStim(win=win, ori=0, name='LowerBrackets_17',\u000a        text=u'  { }        ',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    BotLowerLine_18 = visual.Line(win=win, name='BotLowerLine_18',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_18 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_18',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-12.0)\u000a    RestCrossHair_18 = visual.TextStim(win=win, ori=0, name='RestCrossHair_18',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-13.0)\u000a    text_48 = visual.TextStim(win=win, ori=0, name='text_48',\u000a        text=u'Respond as quickly as possible',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_49 = visual.TextStim(win=win, ori=0, name='text_49',\u000a        text=u'The trial is over and the cross hair turns RED.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-16.0)\u000a\u000a    # Initialize components for Routine "NumLettersToRem"\u000a    NumLettersToRemClock = core.Clock()\u000a    text_15 = visual.TextStim(win=win, ori=0, name='text_15',\u000a        text='The number of letters to remember',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text_33 = visual.TextStim(win=win, ori=0, name='text_33',\u000a        text='Varies between 1 and 6',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_34 = visual.TextStim(win=win, ori=0, name='text_34',\u000a        text='There will always be six letters presented',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a        text='It is the brackets that indicate which letters to remember.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    text_35 = visual.TextStim(win=win, ori=0, name='text_35',\u000a        text='Here are some examples',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    UpBrack1 = visual.TextStim(win=win, ori=0, name='UpBrack1',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-5.0)\u000a    ISI_17 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_17')\u000a    TopUpperLine_17 = visual.Line(win=win, name='TopUpperLine_17',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_17 = visual.TextStim(win=win, ori=0, name='UpperText_17',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    UpperBrackets_17 = visual.TextStim(win=win, ori=0, name='UpperBrackets_17',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    BotUpperLine_17 = visual.Line(win=win, name='BotUpperLine_17',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_17 = visual.Line(win=win, name='TopLowerLine_17',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    BotLowerLine_17 = visual.Line(win=win, name='BotLowerLine_17',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_17 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_17',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_17 = visual.TextStim(win=win, ori=0, name='RestCrossHair_17',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    UpBrack2 = visual.TextStim(win=win, ori=0, name='UpBrack2',\u000a        text='{   }        ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    UpBrack3 = visual.TextStim(win=win, ori=0, name='UpBrack3',\u000a        text='      {     }',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='Yellow', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    UpBrack4 = visual.TextStim(win=win, ori=0, name='UpBrack4',\u000a        text='  {       }  ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a    UpBrack5 = visual.TextStim(win=win, ori=0, name='UpBrack5',\u000a        text='{         }  ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-18.0)\u000a    UpBrack6 = visual.TextStim(win=win, ori=0, name='UpBrack6',\u000a        text=u'{           }',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-19.0)\u000a    text_38 = visual.TextStim(win=win, ori=0, name='text_38',\u000a        text=u'One letter',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-20.0)\u000a    text_39 = visual.TextStim(win=win, ori=0, name='text_39',\u000a        text=u'Two letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-21.0)\u000a    text_40 = visual.TextStim(win=win, ori=0, name='text_40',\u000a        text=u'Three letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-22.0)\u000a    text_41 = visual.TextStim(win=win, ori=0, name='text_41',\u000a        text=u'Four letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-23.0)\u000a    text_42 = visual.TextStim(win=win, ori=0, name='text_42',\u000a        text=u'Five letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-24.0)\u000a    text_43 = visual.TextStim(win=win, ori=0, name='text_43',\u000a        text=u'Six letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-25.0)\u000a\u000a    # Initialize components for Routine "TrialParts_1"\u000a    TrialParts_1Clock = core.Clock()\u000a    text_27 = visual.TextStim(win=win, ori=0, name='text_27',\u000a        text=u'To help with the analysis of the brain data.\u005cnSome trials are PARTIAL.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_30 = visual.TextStim(win=win, ori=0, name='text_30',\u000a        text='All trials will have a set of letters to study.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_31 = visual.TextStim(win=win, ori=0, name='text_31',\u000a        text='Some will not require a response',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_32 = visual.TextStim(win=win, ori=0, name='text_32',\u000a        text='Some will have no delay between the letters to study and the response.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_16 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_16')\u000a    TopUpperLine_16 = visual.Line(win=win, name='TopUpperLine_16',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_16 = visual.TextStim(win=win, ori=0, name='UpperText_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_16 = visual.TextStim(win=win, ori=0, name='UpperBrackets_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_16 = visual.Line(win=win, name='BotUpperLine_16',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_16 = visual.Line(win=win, name='TopLowerLine_16',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_16 = visual.TextStim(win=win, ori=0, name='LowerText_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_16 = visual.TextStim(win=win, ori=0, name='LowerBrackets_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_16 = visual.Line(win=win, name='BotLowerLine_16',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_16 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_16 = visual.TextStim(win=win, ori=0, name='RestCrossHair_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_36 = visual.TextStim(win=win, ori=0, name='text_36',\u000a        text='What is important is that when the crosshair turns RED. The trial is over.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_37 = visual.TextStim(win=win, ori=0, name='text_37',\u000a        text='Try to forget any of the studied letters and wait for the next trial',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_50 = visual.TextStim(win=win, ori=0, name='text_50',\u000a        text=u'Here is an example trial with feedback.\u005cnRemember respond as quickly as possible.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "trial5_2"\u000a    trial5_2Clock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'      { }    ',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Initialize components for Routine "TrialFeedBack"\u000a    TrialFeedBackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    text_47 = visual.TextStim(win=win, ori=0, name='text_47',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=10, method='sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a    for thisTrial in trials:\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "ButtonPractice"-------\u000a        t = 0\u000a        ButtonPracticeClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(120.000000)\u000a        # update component parameters for each repeat\u000a        UpperText_14.setText('')\u000a        UpperBrackets_14.setText('')\u000a        LowerText_14.setText('')\u000a        key_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        ButtonPracticeComponents = []\u000a        ButtonPracticeComponents.append(text_28)\u000a        ButtonPracticeComponents.append(ISI_14)\u000a        ButtonPracticeComponents.append(TopUpperLine_14)\u000a        ButtonPracticeComponents.append(UpperText_14)\u000a        ButtonPracticeComponents.append(UpperBrackets_14)\u000a        ButtonPracticeComponents.append(BotUpperLine_14)\u000a        ButtonPracticeComponents.append(TopLowerLine_14)\u000a        ButtonPracticeComponents.append(LowerText_14)\u000a        ButtonPracticeComponents.append(LowerBrackets_14)\u000a        ButtonPracticeComponents.append(BotLowerLine_14)\u000a        ButtonPracticeComponents.append(TrialCrossHair_14)\u000a        ButtonPracticeComponents.append(RestCrossHair_14)\u000a        ButtonPracticeComponents.append(key_resp_2)\u000a        for thisComponent in ButtonPracticeComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "ButtonPractice"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = ButtonPracticeClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_28* updates\u000a            if t >= 0 and text_28.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_28.tStart = t  # underestimates by a little under one frame\u000a                text_28.frameNStart = frameN  # exact frame index\u000a                text_28.setAutoDraw(True)\u000a            elif text_28.status == STARTED and t >= (0 + (60-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_28.setAutoDraw(False)\u000a            \u000a            # *TopUpperLine_14* updates\u000a            if t >= 0 and TopUpperLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine_14.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine_14.frameNStart = frameN  # exact frame index\u000a                TopUpperLine_14.setAutoDraw(True)\u000a            elif TopUpperLine_14.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine_14.setAutoDraw(False)\u000a            \u000a            # *UpperText_14* updates\u000a            if t >= 0 and UpperText_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText_14.tStart = t  # underestimates by a little under one frame\u000a                UpperText_14.frameNStart = frameN  # exact frame index\u000a                UpperText_14.setAutoDraw(True)\u000a            elif UpperText_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText_14.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets_14* updates\u000a            if t >= 0 and UpperBrackets_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets_14.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets_14.frameNStart = frameN  # exact frame index\u000a                UpperBrackets_14.setAutoDraw(True)\u000a            elif UpperBrackets_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets_14.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine_14* updates\u000a            if t >= 0.0 and BotUpperLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine_14.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine_14.frameNStart = frameN  # exact frame index\u000a                BotUpperLine_14.setAutoDraw(True)\u000a            elif BotUpperLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine_14.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine_14* updates\u000a            if t >= 0.0 and TopLowerLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine_14.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine_14.frameNStart = frameN  # exact frame index\u000a                TopLowerLine_14.setAutoDraw(True)\u000a            elif TopLowerLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine_14.setAutoDraw(False)\u000a            \u000a            # *LowerText_14* updates\u000a            if t >= 0 and LowerText_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText_14.tStart = t  # underestimates by a little under one frame\u000a                LowerText_14.frameNStart = frameN  # exact frame index\u000a                LowerText_14.setAutoDraw(True)\u000a            elif LowerText_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText_14.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets_14* updates\u000a            if t >= 0 and LowerBrackets_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets_14.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets_14.frameNStart = frameN  # exact frame index\u000a                LowerBrackets_14.setAutoDraw(True)\u000a            elif LowerBrackets_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets_14.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine_14* updates\u000a            if t >= 0.0 and BotLowerLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine_14.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine_14.frameNStart = frameN  # exact frame index\u000a                BotLowerLine_14.setAutoDraw(True)\u000a            elif BotLowerLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine_14.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair_14* updates\u000a            if t >= 0 and TrialCrossHair_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair_14.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair_14.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair_14.setAutoDraw(True)\u000a            elif TrialCrossHair_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair_14.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair_14* updates\u000a            if t >= 0 and RestCrossHair_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair_14.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair_14.frameNStart = frameN  # exact frame index\u000a                RestCrossHair_14.setAutoDraw(True)\u000a            elif RestCrossHair_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair_14.setAutoDraw(False)\u000a            \u000a            # *key_resp_2* updates\u000a            if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_2.tStart = t  # underestimates by a little under one frame\u000a                key_resp_2.frameNStart = frameN  # exact frame index\u000a                key_resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif key_resp_2.status == STARTED and t >= (0.0 + (60-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_2.status = STOPPED\u000a            if key_resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8', '9','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_2.rt = key_resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_2.keys == str('6')) or (key_resp_2.keys == 'down'):\u000a                        key_resp_2.corr = 1\u000a                    else:\u000a                        key_resp_2.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            # *ISI_14* period\u000a            if t >= 0.0 and ISI_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI_14.tStart = t  # underestimates by a little under one frame\u000a                ISI_14.frameNStart = frameN  # exact frame index\u000a                ISI_14.start(1)\u000a            elif ISI_14.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI_14.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in ButtonPracticeComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                #win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "ButtonPractice"-------\u000a        for thisComponent in ButtonPracticeComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_2.keys in ['', [], None]:  # No response was made\u000a           key_resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str('6').lower() == 'none': key_resp_2.corr = 1  # correct non-response\u000a           else: key_resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('key_resp_2.keys',key_resp_2.keys)\u000a        trials.addData('key_resp_2.corr', key_resp_2.corr)\u000a        if key_resp_2.keys != None:  # we had a response\u000a            trials.addData('key_resp_2.rt', key_resp_2.rt)\u000a        \u000a        #------Prepare to start Routine "Feedback"-------\u000a        t = 0\u000a        FeedbackClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        if len(key_resp_2.keys)<1:\u000a            msg="Please press the RIGHT INDEX Finger button"\u000a            trials.finished = Falses\u000a        elif key_resp_2.corr:#stored on last run routine\u000a            msg="Correct! That button indicates a YES response." \u000a            trials.finished = True\u000a        else:\u000a            msg="Oops! Wrong button, please try again."\u000a            trials.finished = False\u000a        text_25.setText(msg)\u000a        # keep track of which components have finished\u000a        FeedbackComponents = []\u000a        FeedbackComponents.append(text_25)\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = FeedbackClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_25* updates\u000a            if t >= 0.0 and text_25.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_25.tStart = t  # underestimates by a little under one frame\u000a                text_25.frameNStart = frameN  # exact frame index\u000a                text_25.setAutoDraw(True)\u000a            elif text_25.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_25.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in FeedbackComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                \u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback"-------\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 10 repeats of 'trials'\u000a\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials_2 = data.TrialHandler(nReps=10, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='trials_2')\u000a    thisExp.addLoop(trials_2)  # add the loop to the experiment\u000a    thisTrial_2 = trials_2.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_2.rgb)\u000a    if thisTrial_2 != None:\u000a        for paramName in thisTrial_2.keys():\u000a            exec(paramName + '= thisTrial_2.' + paramName)\u000a\u000a    for thisTrial_2 in trials_2:\u000a        currentLoop = trials_2\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_2.rgb)\u000a        if thisTrial_2 != None:\u000a            for paramName in thisTrial_2.keys():\u000a                exec(paramName + '= thisTrial_2.' + paramName)\u000a        \u000a        #------Prepare to start Routine "ButtonPractice_MIDDLE"-------\u000a        t = 0\u000a        ButtonPractice_MIDDLEClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(20.000000)\u000a        # update component parameters for each repeat\u000a        UpperText_15.setText('')\u000a        UpperBrackets_15.setText('')\u000a        LowerText_15.setText('')\u000a        key_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_3.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        ButtonPractice_MIDDLEComponents = []\u000a        ButtonPractice_MIDDLEComponents.append(text_29)\u000a        ButtonPractice_MIDDLEComponents.append(ISI_15)\u000a        ButtonPractice_MIDDLEComponents.append(TopUpperLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(UpperText_15)\u000a        ButtonPractice_MIDDLEComponents.append(UpperBrackets_15)\u000a        ButtonPractice_MIDDLEComponents.append(BotUpperLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(TopLowerLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(LowerText_15)\u000a        ButtonPractice_MIDDLEComponents.append(LowerBrackets_15)\u000a        ButtonPractice_MIDDLEComponents.append(BotLowerLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(TrialCrossHair_15)\u000a        ButtonPractice_MIDDLEComponents.append(RestCrossHair_15)\u000a        ButtonPractice_MIDDLEComponents.append(key_resp_3)\u000a        for thisComponent in ButtonPractice_MIDDLEComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "ButtonPractice_MIDDLE"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = ButtonPractice_MIDDLEClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_29* updates\u000a            if t >= 0 and text_29.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_29.tStart = t  # underestimates by a little under one frame\u000a                text_29.frameNStart = frameN  # exact frame index\u000a                text_29.setAutoDraw(True)\u000a            elif text_29.status == STARTED and t >= (0 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_29.setAutoDraw(False)\u000a            \u000a            # *TopUpperLine_15* updates\u000a            if t >= 0 and TopUpperLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine_15.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine_15.frameNStart = frameN  # exact frame index\u000a                TopUpperLine_15.setAutoDraw(True)\u000a            elif TopUpperLine_15.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine_15.setAutoDraw(False)\u000a            \u000a            # *UpperText_15* updates\u000a            if t >= 0 and UpperText_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText_15.tStart = t  # underestimates by a little under one frame\u000a                UpperText_15.frameNStart = frameN  # exact frame index\u000a                UpperText_15.setAutoDraw(True)\u000a            elif UpperText_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText_15.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets_15* updates\u000a            if t >= 0 and UpperBrackets_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets_15.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets_15.frameNStart = frameN  # exact frame index\u000a                UpperBrackets_15.setAutoDraw(True)\u000a            elif UpperBrackets_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets_15.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine_15* updates\u000a            if t >= 0.0 and BotUpperLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine_15.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine_15.frameNStart = frameN  # exact frame index\u000a                BotUpperLine_15.setAutoDraw(True)\u000a            elif BotUpperLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine_15.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine_15* updates\u000a            if t >= 0.0 and TopLowerLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine_15.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine_15.frameNStart = frameN  # exact frame index\u000a                TopLowerLine_15.setAutoDraw(True)\u000a            elif TopLowerLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine_15.setAutoDraw(False)\u000a            \u000a            # *LowerText_15* updates\u000a            if t >= 0 and LowerText_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText_15.tStart = t  # underestimates by a little under one frame\u000a                LowerText_15.frameNStart = frameN  # exact frame index\u000a                LowerText_15.setAutoDraw(True)\u000a            elif LowerText_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText_15.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets_15* updates\u000a            if t >= 0 and LowerBrackets_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets_15.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets_15.frameNStart = frameN  # exact frame index\u000a                LowerBrackets_15.setAutoDraw(True)\u000a            elif LowerBrackets_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets_15.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine_15* updates\u000a            if t >= 0.0 and BotLowerLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine_15.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine_15.frameNStart = frameN  # exact frame index\u000a                BotLowerLine_15.setAutoDraw(True)\u000a            elif BotLowerLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine_15.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair_15* updates\u000a            if t >= 0 and TrialCrossHair_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair_15.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair_15.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair_15.setAutoDraw(True)\u000a            elif TrialCrossHair_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair_15.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair_15* updates\u000a            if t >= 0 and RestCrossHair_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair_15.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair_15.frameNStart = frameN  # exact frame index\u000a                RestCrossHair_15.setAutoDraw(True)\u000a            elif RestCrossHair_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair_15.setAutoDraw(False)\u000a            \u000a            # *key_resp_3* updates\u000a            if t >= 0.0 and key_resp_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_3.tStart = t  # underestimates by a little under one frame\u000a                key_resp_3.frameNStart = frameN  # exact frame index\u000a                key_resp_3.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_3.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif key_resp_3.status == STARTED and t >= (0.0 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_3.status = STOPPED\u000a            if key_resp_3.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8', '9','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_3.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_3.rt = key_resp_3.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_3.keys == str('7')) or (key_resp_3.keys == 'right'):\u000a                        key_resp_3.corr = 1\u000a                    else:\u000a                        key_resp_3.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            # *ISI_15* period\u000a            if t >= 0.0 and ISI_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI_15.tStart = t  # underestimates by a little under one frame\u000a                ISI_15.frameNStart = frameN  # exact frame index\u000a                ISI_15.start(1)\u000a            elif ISI_15.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI_15.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in ButtonPractice_MIDDLEComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "ButtonPractice_MIDDLE"-------\u000a        for thisComponent in ButtonPractice_MIDDLEComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_3.keys in ['', [], None]:  # No response was made\u000a           key_resp_3.keys=None\u000a           # was no response the correct answer?!\u000a           if str('7').lower() == 'none': key_resp_3.corr = 1  # correct non-response\u000a           else: key_resp_3.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials_2 (TrialHandler)\u000a        trials_2.addData('key_resp_3.keys',key_resp_3.keys)\u000a        trials_2.addData('key_resp_3.corr', key_resp_3.corr)\u000a        if key_resp_3.keys != None:  # we had a response\u000a            trials_2.addData('key_resp_3.rt', key_resp_3.rt)\u000a        \u000a        #------Prepare to start Routine "Feedback_MIDDLE"-------\u000a        t = 0\u000a        Feedback_MIDDLEClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        if len(key_resp_3.keys)<1:\u000a            msg="Please press the RIGHT MIDDLE Finger button"\u000a            trials_2.finished = Falses\u000a        elif key_resp_3.corr:#stored on last run routine\u000a            msg="Good! That button indicates a NO response." \u000a            trials_2.finished = True\u000a        else:\u000a            msg="Oops! Wrong button, please try again."\u000a            trials_2.finished = False\u000a        text_26.setText(msg)\u000a        # keep track of which components have finished\u000a        Feedback_MIDDLEComponents = []\u000a        Feedback_MIDDLEComponents.append(text_26)\u000a        for thisComponent in Feedback_MIDDLEComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback_MIDDLE"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = Feedback_MIDDLEClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_26* updates\u000a            if t >= 0.0 and text_26.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_26.tStart = t  # underestimates by a little under one frame\u000a                text_26.frameNStart = frameN  # exact frame index\u000a                text_26.setAutoDraw(True)\u000a            elif text_26.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_26.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Feedback_MIDDLEComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback_MIDDLE"-------\u000a        for thisComponent in Feedback_MIDDLEComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 10 repeats of 'trials_2'\u000a\u000a\u000a    #------Prepare to start Routine "var_6Letters_2"-------\u000a    t = 0\u000a    var_6Letters_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(20.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_13.setText('')\u000a    UpperBrackets_13.setText('')\u000a    LowerText_13.setText('')\u000a    # keep track of which components have finished\u000a    var_6Letters_2Components = []\u000a    var_6Letters_2Components.append(text_13)\u000a    var_6Letters_2Components.append(text_16)\u000a    var_6Letters_2Components.append(text_18)\u000a    var_6Letters_2Components.append(text_21)\u000a    var_6Letters_2Components.append(ISI_13)\u000a    var_6Letters_2Components.append(TopUpperLine_13)\u000a    var_6Letters_2Components.append(UpperText_13)\u000a    var_6Letters_2Components.append(UpperBrackets_13)\u000a    var_6Letters_2Components.append(BotUpperLine_13)\u000a    var_6Letters_2Components.append(TopLowerLine_13)\u000a    var_6Letters_2Components.append(LowerText_13)\u000a    var_6Letters_2Components.append(LowerBrackets_13)\u000a    var_6Letters_2Components.append(BotLowerLine_13)\u000a    var_6Letters_2Components.append(TrialCrossHair_13)\u000a    var_6Letters_2Components.append(RestCrossHair_13)\u000a    var_6Letters_2Components.append(text_22)\u000a    var_6Letters_2Components.append(text_23)\u000a    var_6Letters_2Components.append(text_24)\u000a    for thisComponent in var_6Letters_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_13* updates\u000a        if t >= 0.0 and text_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_13.tStart = t  # underestimates by a little under one frame\u000a            text_13.frameNStart = frameN  # exact frame index\u000a            text_13.setAutoDraw(True)\u000a        elif text_13.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_13.setAutoDraw(False)\u000a        \u000a        # *text_16* updates\u000a        if t >= 3 and text_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_16.tStart = t  # underestimates by a little under one frame\u000a            text_16.frameNStart = frameN  # exact frame index\u000a            text_16.setAutoDraw(True)\u000a        elif text_16.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_16.setAutoDraw(False)\u000a        \u000a        # *text_18* updates\u000a        if t >= 6 and text_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_18.tStart = t  # underestimates by a little under one frame\u000a            text_18.frameNStart = frameN  # exact frame index\u000a            text_18.setAutoDraw(True)\u000a        elif text_18.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_18.setAutoDraw(False)\u000a        \u000a        # *text_21* updates\u000a        if t >= 0 and text_21.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_21.tStart = t  # underestimates by a little under one frame\u000a            text_21.frameNStart = frameN  # exact frame index\u000a            text_21.setAutoDraw(True)\u000a        elif text_21.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_21.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_13* updates\u000a        if t >= 0 and TopUpperLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_13.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_13.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_13.setAutoDraw(True)\u000a        elif TopUpperLine_13.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_13.setAutoDraw(False)\u000a        \u000a        # *UpperText_13* updates\u000a        if t >= 0 and UpperText_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_13.tStart = t  # underestimates by a little under one frame\u000a            UpperText_13.frameNStart = frameN  # exact frame index\u000a            UpperText_13.setAutoDraw(True)\u000a        elif UpperText_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_13.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_13* updates\u000a        if t >= 0 and UpperBrackets_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_13.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_13.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_13.setAutoDraw(True)\u000a        elif UpperBrackets_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_13.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_13* updates\u000a        if t >= 0.0 and BotUpperLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_13.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_13.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_13.setAutoDraw(True)\u000a        elif BotUpperLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_13.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_13* updates\u000a        if t >= 0.0 and TopLowerLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_13.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_13.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_13.setAutoDraw(True)\u000a        elif TopLowerLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_13.setAutoDraw(False)\u000a        \u000a        # *LowerText_13* updates\u000a        if t >= 0 and LowerText_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_13.tStart = t  # underestimates by a little under one frame\u000a            LowerText_13.frameNStart = frameN  # exact frame index\u000a            LowerText_13.setAutoDraw(True)\u000a        elif LowerText_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_13.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_13* updates\u000a        if t >= 0 and LowerBrackets_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_13.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_13.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_13.setAutoDraw(True)\u000a        elif LowerBrackets_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_13.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_13* updates\u000a        if t >= 0.0 and BotLowerLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_13.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_13.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_13.setAutoDraw(True)\u000a        elif BotLowerLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_13.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_13* updates\u000a        if t >= 12 and TrialCrossHair_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_13.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_13.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_13.setAutoDraw(True)\u000a        elif TrialCrossHair_13.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_13.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_13* updates\u000a        if t >= 15 and RestCrossHair_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_13.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_13.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_13.setAutoDraw(True)\u000a        elif RestCrossHair_13.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_13.setAutoDraw(False)\u000a        \u000a        # *text_22* updates\u000a        if t >= 9 and text_22.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_22.tStart = t  # underestimates by a little under one frame\u000a            text_22.frameNStart = frameN  # exact frame index\u000a            text_22.setAutoDraw(True)\u000a        elif text_22.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_22.setAutoDraw(False)\u000a        \u000a        # *text_23* updates\u000a        if t >= 12 and text_23.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_23.tStart = t  # underestimates by a little under one frame\u000a            text_23.frameNStart = frameN  # exact frame index\u000a            text_23.setAutoDraw(True)\u000a        elif text_23.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_23.setAutoDraw(False)\u000a        \u000a        # *text_24* updates\u000a        if t >= 15 and text_24.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_24.tStart = t  # underestimates by a little under one frame\u000a            text_24.frameNStart = frameN  # exact frame index\u000a            text_24.setAutoDraw(True)\u000a        elif text_24.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_24.setAutoDraw(False)\u000a        # *ISI_13* period\u000a        if t >= 0.0 and ISI_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_13.tStart = t  # underestimates by a little under one frame\u000a            ISI_13.frameNStart = frameN  # exact frame index\u000a            ISI_13.start(1)\u000a        elif ISI_13.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_13.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_2"-------\u000a    for thisComponent in var_6Letters_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "var_6Letters_0"-------\u000a    t = 0\u000a    var_6Letters_0Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(30.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_11.setText(' A B C D E F ')\u000a    UpperBrackets_11.setText('  {   }      ')\u000a    LowerText_11.setText(' a b c d e f ')\u000a    KeyboardResp_11 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_11.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    var_6Letters_0Components = []\u000a    var_6Letters_0Components.append(text_2)\u000a    var_6Letters_0Components.append(text)\u000a    var_6Letters_0Components.append(text_6)\u000a    var_6Letters_0Components.append(text_4)\u000a    var_6Letters_0Components.append(ISI_11)\u000a    var_6Letters_0Components.append(TopUpperLine_11)\u000a    var_6Letters_0Components.append(UpperText_11)\u000a    var_6Letters_0Components.append(UpperBrackets_11)\u000a    var_6Letters_0Components.append(BotUpperLine_11)\u000a    var_6Letters_0Components.append(TopLowerLine_11)\u000a    var_6Letters_0Components.append(LowerText_11)\u000a    var_6Letters_0Components.append(LowerBrackets_11)\u000a    var_6Letters_0Components.append(BotLowerLine_11)\u000a    var_6Letters_0Components.append(TrialCrossHair_11)\u000a    var_6Letters_0Components.append(RestCrossHair_11)\u000a    var_6Letters_0Components.append(KeyboardResp_11)\u000a    var_6Letters_0Components.append(text_5)\u000a    var_6Letters_0Components.append(text_7)\u000a    var_6Letters_0Components.append(text_8)\u000a    var_6Letters_0Components.append(text_9)\u000a    var_6Letters_0Components.append(text_10)\u000a    for thisComponent in var_6Letters_0Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_0"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_0Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_2* updates\u000a        if t >= 0.0 and text_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_2.tStart = t  # underestimates by a little under one frame\u000a            text_2.frameNStart = frameN  # exact frame index\u000a            text_2.setAutoDraw(True)\u000a        elif text_2.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_2.setAutoDraw(False)\u000a        \u000a        # *text* updates\u000a        if t >= 3 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        elif text.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # *text_6* updates\u000a        if t >= 6 and text_6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_6.tStart = t  # underestimates by a little under one frame\u000a            text_6.frameNStart = frameN  # exact frame index\u000a            text_6.setAutoDraw(True)\u000a        elif text_6.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_6.setAutoDraw(False)\u000a        \u000a        # *text_4* updates\u000a        if t >= 9 and text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_4.tStart = t  # underestimates by a little under one frame\u000a            text_4.frameNStart = frameN  # exact frame index\u000a            text_4.setAutoDraw(True)\u000a        elif text_4.status == STARTED and t >= (9 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_4.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_11* updates\u000a        if t >= 0 and TopUpperLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_11.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_11.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_11.setAutoDraw(True)\u000a        elif TopUpperLine_11.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_11.setAutoDraw(False)\u000a        \u000a        # *UpperText_11* updates\u000a        if t >= 0 and UpperText_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_11.tStart = t  # underestimates by a little under one frame\u000a            UpperText_11.frameNStart = frameN  # exact frame index\u000a            UpperText_11.setAutoDraw(True)\u000a        elif UpperText_11.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_11.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_11* updates\u000a        if t >= 3 and UpperBrackets_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_11.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_11.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_11.setAutoDraw(True)\u000a        elif UpperBrackets_11.status == STARTED and t >= (3 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_11.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_11* updates\u000a        if t >= 0.0 and BotUpperLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_11.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_11.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_11.setAutoDraw(True)\u000a        elif BotUpperLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_11.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_11* updates\u000a        if t >= 0.0 and TopLowerLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_11.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_11.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_11.setAutoDraw(True)\u000a        elif TopLowerLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_11.setAutoDraw(False)\u000a        \u000a        # *LowerText_11* updates\u000a        if t >= 14 and LowerText_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_11.tStart = t  # underestimates by a little under one frame\u000a            LowerText_11.frameNStart = frameN  # exact frame index\u000a            LowerText_11.setAutoDraw(True)\u000a        elif LowerText_11.status == STARTED and t >= (14 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_11.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_11* updates\u000a        if t >= 17 and LowerBrackets_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_11.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_11.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_11.setAutoDraw(True)\u000a        elif LowerBrackets_11.status == STARTED and t >= (17 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_11.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_11* updates\u000a        if t >= 0.0 and BotLowerLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_11.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_11.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_11.setAutoDraw(True)\u000a        elif BotLowerLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_11.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_11* updates\u000a        if t >= 0 and TrialCrossHair_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_11.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_11.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_11.setAutoDraw(True)\u000a        elif TrialCrossHair_11.status == STARTED and t >= (0 + (26-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_11.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_11* updates\u000a        if t >= 26 and RestCrossHair_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_11.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_11.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_11.setAutoDraw(True)\u000a        elif RestCrossHair_11.status == STARTED and t >= (26 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_11.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_11* updates\u000a        if t >= 0 and KeyboardResp_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_11.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_11.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_11.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_11.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_11.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_11.status = STOPPED\u000a        if KeyboardResp_11.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_11.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_11.rt.append(KeyboardResp_11.clock.getTime())\u000a        \u000a        # *text_5* updates\u000a        if t >= 14 and text_5.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_5.tStart = t  # underestimates by a little under one frame\u000a            text_5.frameNStart = frameN  # exact frame index\u000a            text_5.setAutoDraw(True)\u000a        elif text_5.status == STARTED and t >= (14 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_5.setAutoDraw(False)\u000a        \u000a        # *text_7* updates\u000a        if t >= 17 and text_7.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_7.tStart = t  # underestimates by a little under one frame\u000a            text_7.frameNStart = frameN  # exact frame index\u000a            text_7.setAutoDraw(True)\u000a        elif text_7.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_7.setAutoDraw(False)\u000a        \u000a        # *text_8* updates\u000a        if t >= 20 and text_8.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_8.tStart = t  # underestimates by a little under one frame\u000a            text_8.frameNStart = frameN  # exact frame index\u000a            text_8.setAutoDraw(True)\u000a        elif text_8.status == STARTED and t >= (20 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_8.setAutoDraw(False)\u000a        \u000a        # *text_9* updates\u000a        if t >= 23 and text_9.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_9.tStart = t  # underestimates by a little under one frame\u000a            text_9.frameNStart = frameN  # exact frame index\u000a            text_9.setAutoDraw(True)\u000a        elif text_9.status == STARTED and t >= (23 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_9.setAutoDraw(False)\u000a        \u000a        # *text_10* updates\u000a        if t >= 26 and text_10.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_10.tStart = t  # underestimates by a little under one frame\u000a            text_10.frameNStart = frameN  # exact frame index\u000a            text_10.setAutoDraw(True)\u000a        elif text_10.status == STARTED and t >= (26 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_10.setAutoDraw(False)\u000a        # *ISI_11* period\u000a        if t >= 0.0 and ISI_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_11.tStart = t  # underestimates by a little under one frame\u000a            ISI_11.frameNStart = frameN  # exact frame index\u000a            ISI_11.start(1)\u000a        elif ISI_11.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_11.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_0Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_0"-------\u000a    for thisComponent in var_6Letters_0Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_11.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_11.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_11.keys',KeyboardResp_11.keys)\u000a    if KeyboardResp_11.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_11.rt', KeyboardResp_11.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "var_6Letters_1"-------\u000a    t = 0\u000a    var_6Letters_1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(22.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_12.setText(' A B C D E F ')\u000a    UpperBrackets_12.setText('  {   }      ')\u000a    LowerText_12.setText(u' a b c d e f ')\u000a    KeyboardResp_12 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_12.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    var_6Letters_1Components = []\u000a    var_6Letters_1Components.append(text_11)\u000a    var_6Letters_1Components.append(text_12)\u000a    var_6Letters_1Components.append(text_14)\u000a    var_6Letters_1Components.append(ISI_12)\u000a    var_6Letters_1Components.append(TopUpperLine_12)\u000a    var_6Letters_1Components.append(UpperText_12)\u000a    var_6Letters_1Components.append(UpperBrackets_12)\u000a    var_6Letters_1Components.append(BotUpperLine_12)\u000a    var_6Letters_1Components.append(TopLowerLine_12)\u000a    var_6Letters_1Components.append(LowerText_12)\u000a    var_6Letters_1Components.append(LowerBrackets_12)\u000a    var_6Letters_1Components.append(BotLowerLine_12)\u000a    var_6Letters_1Components.append(TrialCrossHair_12)\u000a    var_6Letters_1Components.append(RestCrossHair_12)\u000a    var_6Letters_1Components.append(KeyboardResp_12)\u000a    var_6Letters_1Components.append(text_17)\u000a    var_6Letters_1Components.append(text_19)\u000a    var_6Letters_1Components.append(text_20)\u000a    for thisComponent in var_6Letters_1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_11* updates\u000a        if t >= 0.0 and text_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_11.tStart = t  # underestimates by a little under one frame\u000a            text_11.frameNStart = frameN  # exact frame index\u000a            text_11.setAutoDraw(True)\u000a        elif text_11.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_11.setAutoDraw(False)\u000a        \u000a        # *text_12* updates\u000a        if t >= 3 and text_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_12.tStart = t  # underestimates by a little under one frame\u000a            text_12.frameNStart = frameN  # exact frame index\u000a            text_12.setAutoDraw(True)\u000a        elif text_12.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_12.setAutoDraw(False)\u000a        \u000a        # *text_14* updates\u000a        if t >= 6 and text_14.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_14.tStart = t  # underestimates by a little under one frame\u000a            text_14.frameNStart = frameN  # exact frame index\u000a            text_14.setAutoDraw(True)\u000a        elif text_14.status == STARTED and t >= (6 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_14.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_12* updates\u000a        if t >= 0 and TopUpperLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_12.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_12.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_12.setAutoDraw(True)\u000a        elif TopUpperLine_12.status == STARTED and t >= (0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_12.setAutoDraw(False)\u000a        \u000a        # *UpperText_12* updates\u000a        if t >= 0 and UpperText_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_12.tStart = t  # underestimates by a little under one frame\u000a            UpperText_12.frameNStart = frameN  # exact frame index\u000a            UpperText_12.setAutoDraw(True)\u000a        elif UpperText_12.status == STARTED and t >= (0 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_12.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_12* updates\u000a        if t >= 3 and UpperBrackets_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_12.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_12.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_12.setAutoDraw(True)\u000a        elif UpperBrackets_12.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_12.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_12* updates\u000a        if t >= 0.0 and BotUpperLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_12.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_12.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_12.setAutoDraw(True)\u000a        elif BotUpperLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_12.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_12* updates\u000a        if t >= 0.0 and TopLowerLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_12.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_12.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_12.setAutoDraw(True)\u000a        elif TopLowerLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_12.setAutoDraw(False)\u000a        \u000a        # *LowerText_12* updates\u000a        if t >= 11 and LowerText_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_12.tStart = t  # underestimates by a little under one frame\u000a            LowerText_12.frameNStart = frameN  # exact frame index\u000a            LowerText_12.setAutoDraw(True)\u000a        elif LowerText_12.status == STARTED and t >= (11 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_12.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_12* updates\u000a        if t >= 11 and LowerBrackets_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_12.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_12.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_12.setAutoDraw(True)\u000a        elif LowerBrackets_12.status == STARTED and t >= (11 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_12.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_12* updates\u000a        if t >= 0.0 and BotLowerLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_12.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_12.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_12.setAutoDraw(True)\u000a        elif BotLowerLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_12.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_12* updates\u000a        if t >= 0 and TrialCrossHair_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_12.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_12.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_12.setAutoDraw(True)\u000a        elif TrialCrossHair_12.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_12.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_12* updates\u000a        if t >= 17 and RestCrossHair_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_12.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_12.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_12.setAutoDraw(True)\u000a        elif RestCrossHair_12.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_12.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_12* updates\u000a        if t >= 0 and KeyboardResp_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_12.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_12.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_12.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_12.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_12.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_12.status = STOPPED\u000a        if KeyboardResp_12.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_12.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_12.rt.append(KeyboardResp_12.clock.getTime())\u000a        \u000a        # *text_17* updates\u000a        if t >= 11 and text_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_17.tStart = t  # underestimates by a little under one frame\u000a            text_17.frameNStart = frameN  # exact frame index\u000a            text_17.setAutoDraw(True)\u000a        elif text_17.status == STARTED and t >= (11 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_17.setAutoDraw(False)\u000a        \u000a        # *text_19* updates\u000a        if t >= 14 and text_19.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_19.tStart = t  # underestimates by a little under one frame\u000a            text_19.frameNStart = frameN  # exact frame index\u000a            text_19.setAutoDraw(True)\u000a        elif text_19.status == STARTED and t >= (14 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_19.setAutoDraw(False)\u000a        \u000a        # *text_20* updates\u000a        if t >= 17 and text_20.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_20.tStart = t  # underestimates by a little under one frame\u000a            text_20.frameNStart = frameN  # exact frame index\u000a            text_20.setAutoDraw(True)\u000a        elif text_20.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_20.setAutoDraw(False)\u000a        # *ISI_12* period\u000a        if t >= 0.0 and ISI_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_12.tStart = t  # underestimates by a little under one frame\u000a            ISI_12.frameNStart = frameN  # exact frame index\u000a            ISI_12.start(1)\u000a        elif ISI_12.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_12.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_1"-------\u000a    for thisComponent in var_6Letters_1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_12.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_12.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_12.keys',KeyboardResp_12.keys)\u000a    if KeyboardResp_12.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_12.rt', KeyboardResp_12.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "DemoTrialRealTimes"-------\u000a    t = 0\u000a    DemoTrialRealTimesClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(17.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_18.setText(u' A B C D E F ')\u000a    UpperBrackets_18.setText(u'  {   }      ')\u000a    LowerText_17.setText(u' a b c d e f ')\u000a    KeyboardResp_13 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_13.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    DemoTrialRealTimesComponents = []\u000a    DemoTrialRealTimesComponents.append(text_44)\u000a    DemoTrialRealTimesComponents.append(text_45)\u000a    DemoTrialRealTimesComponents.append(text_46)\u000a    DemoTrialRealTimesComponents.append(ISI_18)\u000a    DemoTrialRealTimesComponents.append(TopUpperLine_18)\u000a    DemoTrialRealTimesComponents.append(UpperText_18)\u000a    DemoTrialRealTimesComponents.append(UpperBrackets_18)\u000a    DemoTrialRealTimesComponents.append(BotUpperLine_18)\u000a    DemoTrialRealTimesComponents.append(TopLowerLine_18)\u000a    DemoTrialRealTimesComponents.append(LowerText_17)\u000a    DemoTrialRealTimesComponents.append(LowerBrackets_17)\u000a    DemoTrialRealTimesComponents.append(BotLowerLine_18)\u000a    DemoTrialRealTimesComponents.append(TrialCrossHair_18)\u000a    DemoTrialRealTimesComponents.append(RestCrossHair_18)\u000a    DemoTrialRealTimesComponents.append(KeyboardResp_13)\u000a    DemoTrialRealTimesComponents.append(text_48)\u000a    DemoTrialRealTimesComponents.append(text_49)\u000a    for thisComponent in DemoTrialRealTimesComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "DemoTrialRealTimes"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = DemoTrialRealTimesClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_44* updates\u000a        if t >= 0.0 and text_44.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_44.tStart = t  # underestimates by a little under one frame\u000a            text_44.frameNStart = frameN  # exact frame index\u000a            text_44.setAutoDraw(True)\u000a        elif text_44.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_44.setAutoDraw(False)\u000a        \u000a        # *text_45* updates\u000a        if t >= 3 and text_45.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_45.tStart = t  # underestimates by a little under one frame\u000a            text_45.frameNStart = frameN  # exact frame index\u000a            text_45.setAutoDraw(True)\u000a        elif text_45.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_45.setAutoDraw(False)\u000a        \u000a        # *text_46* updates\u000a        if t >= 5 and text_46.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_46.tStart = t  # underestimates by a little under one frame\u000a            text_46.frameNStart = frameN  # exact frame index\u000a            text_46.setAutoDraw(True)\u000a        elif text_46.status == STARTED and t >= (5 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_46.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_18* updates\u000a        if t >= 0 and TopUpperLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_18.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_18.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_18.setAutoDraw(True)\u000a        elif TopUpperLine_18.status == STARTED and t >= (0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_18.setAutoDraw(False)\u000a        \u000a        # *UpperText_18* updates\u000a        if t >= 3 and UpperText_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_18.tStart = t  # underestimates by a little under one frame\u000a            UpperText_18.frameNStart = frameN  # exact frame index\u000a            UpperText_18.setAutoDraw(True)\u000a        elif UpperText_18.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_18.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_18* updates\u000a        if t >= 3 and UpperBrackets_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_18.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_18.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_18.setAutoDraw(True)\u000a        elif UpperBrackets_18.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_18.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_18* updates\u000a        if t >= 0.0 and BotUpperLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_18.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_18.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_18.setAutoDraw(True)\u000a        elif BotUpperLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_18.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_18* updates\u000a        if t >= 0.0 and TopLowerLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_18.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_18.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_18.setAutoDraw(True)\u000a        elif TopLowerLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_18.setAutoDraw(False)\u000a        \u000a        # *LowerText_17* updates\u000a        if t >= 10 and LowerText_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_17.tStart = t  # underestimates by a little under one frame\u000a            LowerText_17.frameNStart = frameN  # exact frame index\u000a            LowerText_17.setAutoDraw(True)\u000a        elif LowerText_17.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_17.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_17* updates\u000a        if t >= 10 and LowerBrackets_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_17.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_17.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_17.setAutoDraw(True)\u000a        elif LowerBrackets_17.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_17.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_18* updates\u000a        if t >= 0.0 and BotLowerLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_18.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_18.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_18.setAutoDraw(True)\u000a        elif BotLowerLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_18.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_18* updates\u000a        if t >= 0 and TrialCrossHair_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_18.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_18.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_18.setAutoDraw(True)\u000a        elif TrialCrossHair_18.status == STARTED and t >= (0 + (12-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_18.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_18* updates\u000a        if t >= 12 and RestCrossHair_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_18.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_18.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_18.setAutoDraw(True)\u000a        elif RestCrossHair_18.status == STARTED and t >= (12 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_18.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_13* updates\u000a        if t >= 0 and KeyboardResp_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_13.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_13.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_13.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_13.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_13.status = STOPPED\u000a        if KeyboardResp_13.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_13.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_13.rt.append(KeyboardResp_13.clock.getTime())\u000a        \u000a        # *text_48* updates\u000a        if t >= 10 and text_48.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_48.tStart = t  # underestimates by a little under one frame\u000a            text_48.frameNStart = frameN  # exact frame index\u000a            text_48.setAutoDraw(True)\u000a        elif text_48.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_48.setAutoDraw(False)\u000a        \u000a        # *text_49* updates\u000a        if t >= 12 and text_49.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_49.tStart = t  # underestimates by a little under one frame\u000a            text_49.frameNStart = frameN  # exact frame index\u000a            text_49.setAutoDraw(True)\u000a        elif text_49.status == STARTED and t >= (12 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_49.setAutoDraw(False)\u000a        # *ISI_18* period\u000a        if t >= 0.0 and ISI_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_18.tStart = t  # underestimates by a little under one frame\u000a            ISI_18.frameNStart = frameN  # exact frame index\u000a            ISI_18.start(1)\u000a        elif ISI_18.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_18.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in DemoTrialRealTimesComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "DemoTrialRealTimes"-------\u000a    for thisComponent in DemoTrialRealTimesComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_13.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_13.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_13.keys',KeyboardResp_13.keys)\u000a    if KeyboardResp_13.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_13.rt', KeyboardResp_13.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "NumLettersToRem"-------\u000a    t = 0\u000a    NumLettersToRemClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(30.000000)\u000a    # update component parameters for each repeat\u000a    UpBrack1.setText('        { }  ')\u000a    UpperText_17.setText(' A B C D E F ')\u000a    UpperBrackets_17.setText('')\u000a    # keep track of which components have finished\u000a    NumLettersToRemComponents = []\u000a    NumLettersToRemComponents.append(text_15)\u000a    NumLettersToRemComponents.append(text_33)\u000a    NumLettersToRemComponents.append(text_34)\u000a    NumLettersToRemComponents.append(text_3)\u000a    NumLettersToRemComponents.append(text_35)\u000a    NumLettersToRemComponents.append(UpBrack1)\u000a    NumLettersToRemComponents.append(ISI_17)\u000a    NumLettersToRemComponents.append(TopUpperLine_17)\u000a    NumLettersToRemComponents.append(UpperText_17)\u000a    NumLettersToRemComponents.append(UpperBrackets_17)\u000a    NumLettersToRemComponents.append(BotUpperLine_17)\u000a    NumLettersToRemComponents.append(TopLowerLine_17)\u000a    NumLettersToRemComponents.append(BotLowerLine_17)\u000a    NumLettersToRemComponents.append(TrialCrossHair_17)\u000a    NumLettersToRemComponents.append(RestCrossHair_17)\u000a    NumLettersToRemComponents.append(UpBrack2)\u000a    NumLettersToRemComponents.append(UpBrack3)\u000a    NumLettersToRemComponents.append(UpBrack4)\u000a    NumLettersToRemComponents.append(UpBrack5)\u000a    NumLettersToRemComponents.append(UpBrack6)\u000a    NumLettersToRemComponents.append(text_38)\u000a    NumLettersToRemComponents.append(text_39)\u000a    NumLettersToRemComponents.append(text_40)\u000a    NumLettersToRemComponents.append(text_41)\u000a    NumLettersToRemComponents.append(text_42)\u000a    NumLettersToRemComponents.append(text_43)\u000a    for thisComponent in NumLettersToRemComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "NumLettersToRem"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = NumLettersToRemClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_15* updates\u000a        if t >= 0.0 and text_15.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_15.tStart = t  # underestimates by a little under one frame\u000a            text_15.frameNStart = frameN  # exact frame index\u000a            text_15.setAutoDraw(True)\u000a        elif text_15.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_15.setAutoDraw(False)\u000a        \u000a        # *text_33* updates\u000a        if t >= 3 and text_33.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_33.tStart = t  # underestimates by a little under one frame\u000a            text_33.frameNStart = frameN  # exact frame index\u000a            text_33.setAutoDraw(True)\u000a        elif text_33.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_33.setAutoDraw(False)\u000a        \u000a        # *text_34* updates\u000a        if t >= 6 and text_34.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_34.tStart = t  # underestimates by a little under one frame\u000a            text_34.frameNStart = frameN  # exact frame index\u000a            text_34.setAutoDraw(True)\u000a        elif text_34.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_34.setAutoDraw(False)\u000a        \u000a        # *text_3* updates\u000a        if t >= 9 and text_3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_3.tStart = t  # underestimates by a little under one frame\u000a            text_3.frameNStart = frameN  # exact frame index\u000a            text_3.setAutoDraw(True)\u000a        elif text_3.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_3.setAutoDraw(False)\u000a        \u000a        # *text_35* updates\u000a        if t >= 12 and text_35.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_35.tStart = t  # underestimates by a little under one frame\u000a            text_35.frameNStart = frameN  # exact frame index\u000a            text_35.setAutoDraw(True)\u000a        elif text_35.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_35.setAutoDraw(False)\u000a        \u000a        # *UpBrack1* updates\u000a        if t >= 15 and UpBrack1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack1.tStart = t  # underestimates by a little under one frame\u000a            UpBrack1.frameNStart = frameN  # exact frame index\u000a            UpBrack1.setAutoDraw(True)\u000a        elif UpBrack1.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack1.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_17* updates\u000a        if t >= 0 and TopUpperLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_17.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_17.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_17.setAutoDraw(True)\u000a        elif TopUpperLine_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_17.setAutoDraw(False)\u000a        \u000a        # *UpperText_17* updates\u000a        if t >= 0 and UpperText_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_17.tStart = t  # underestimates by a little under one frame\u000a            UpperText_17.frameNStart = frameN  # exact frame index\u000a            UpperText_17.setAutoDraw(True)\u000a        elif UpperText_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_17.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_17* updates\u000a        if t >= 0.0 and UpperBrackets_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_17.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_17.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_17.setAutoDraw(True)\u000a        elif UpperBrackets_17.status == STARTED and t >= (0.0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_17.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_17* updates\u000a        if t >= 0.0 and BotUpperLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_17.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_17.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_17.setAutoDraw(True)\u000a        elif BotUpperLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_17.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_17* updates\u000a        if t >= 0.0 and TopLowerLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_17.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_17.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_17.setAutoDraw(True)\u000a        elif TopLowerLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_17.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_17* updates\u000a        if t >= 0.0 and BotLowerLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_17.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_17.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_17.setAutoDraw(True)\u000a        elif BotLowerLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_17.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_17* updates\u000a        if t >= 0 and TrialCrossHair_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_17.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_17.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_17.setAutoDraw(True)\u000a        elif TrialCrossHair_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_17.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_17* updates\u000a        if t >= 0.0 and RestCrossHair_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_17.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_17.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_17.setAutoDraw(True)\u000a        elif RestCrossHair_17.status == STARTED and t >= (0.0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_17.setAutoDraw(False)\u000a        \u000a        # *UpBrack2* updates\u000a        if t >= 18 and UpBrack2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack2.tStart = t  # underestimates by a little under one frame\u000a            UpBrack2.frameNStart = frameN  # exact frame index\u000a            UpBrack2.setAutoDraw(True)\u000a        elif UpBrack2.status == STARTED and t >= (18 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack2.setAutoDraw(False)\u000a        \u000a        # *UpBrack3* updates\u000a        if t >= 20 and UpBrack3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack3.tStart = t  # underestimates by a little under one frame\u000a            UpBrack3.frameNStart = frameN  # exact frame index\u000a            UpBrack3.setAutoDraw(True)\u000a        elif UpBrack3.status == STARTED and t >= (20 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack3.setAutoDraw(False)\u000a        \u000a        # *UpBrack4* updates\u000a        if t >= 22 and UpBrack4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack4.tStart = t  # underestimates by a little under one frame\u000a            UpBrack4.frameNStart = frameN  # exact frame index\u000a            UpBrack4.setAutoDraw(True)\u000a        elif UpBrack4.status == STARTED and t >= (22 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack4.setAutoDraw(False)\u000a        \u000a        # *UpBrack5* updates\u000a        if t >= 24 and UpBrack5.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack5.tStart = t  # underestimates by a little under one frame\u000a            UpBrack5.frameNStart = frameN  # exact frame index\u000a            UpBrack5.setAutoDraw(True)\u000a        elif UpBrack5.status == STARTED and t >= (24 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack5.setAutoDraw(False)\u000a        \u000a        # *UpBrack6* updates\u000a        if t >= 26 and UpBrack6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack6.tStart = t  # underestimates by a little under one frame\u000a            UpBrack6.frameNStart = frameN  # exact frame index\u000a            UpBrack6.setAutoDraw(True)\u000a        elif UpBrack6.status == STARTED and t >= (26 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack6.setAutoDraw(False)\u000a        \u000a        # *text_38* updates\u000a        if t >= 15 and text_38.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_38.tStart = t  # underestimates by a little under one frame\u000a            text_38.frameNStart = frameN  # exact frame index\u000a            text_38.setAutoDraw(True)\u000a        elif text_38.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_38.setAutoDraw(False)\u000a        \u000a        # *text_39* updates\u000a        if t >= 18 and text_39.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_39.tStart = t  # underestimates by a little under one frame\u000a            text_39.frameNStart = frameN  # exact frame index\u000a            text_39.setAutoDraw(True)\u000a        elif text_39.status == STARTED and t >= (18 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_39.setAutoDraw(False)\u000a        \u000a        # *text_40* updates\u000a        if t >= 20 and text_40.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_40.tStart = t  # underestimates by a little under one frame\u000a            text_40.frameNStart = frameN  # exact frame index\u000a            text_40.setAutoDraw(True)\u000a        elif text_40.status == STARTED and t >= (20 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_40.setAutoDraw(False)\u000a        \u000a        # *text_41* updates\u000a        if t >= 22 and text_41.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_41.tStart = t  # underestimates by a little under one frame\u000a            text_41.frameNStart = frameN  # exact frame index\u000a            text_41.setAutoDraw(True)\u000a        elif text_41.status == STARTED and t >= (22 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_41.setAutoDraw(False)\u000a        \u000a        # *text_42* updates\u000a        if t >= 24 and text_42.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_42.tStart = t  # underestimates by a little under one frame\u000a            text_42.frameNStart = frameN  # exact frame index\u000a            text_42.setAutoDraw(True)\u000a        elif text_42.status == STARTED and t >= (24 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_42.setAutoDraw(False)\u000a        \u000a        # *text_43* updates\u000a        if t >= 26 and text_43.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_43.tStart = t  # underestimates by a little under one frame\u000a            text_43.frameNStart = frameN  # exact frame index\u000a            text_43.setAutoDraw(True)\u000a        elif text_43.status == STARTED and t >= (26 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_43.setAutoDraw(False)\u000a        # *ISI_17* period\u000a        if t >= 0.0 and ISI_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_17.tStart = t  # underestimates by a little under one frame\u000a            ISI_17.frameNStart = frameN  # exact frame index\u000a            ISI_17.start(1)\u000a        elif ISI_17.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_17.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in NumLettersToRemComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "NumLettersToRem"-------\u000a    for thisComponent in NumLettersToRemComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "TrialParts_1"-------\u000a    t = 0\u000a    TrialParts_1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(25.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_16.setText('')\u000a    UpperBrackets_16.setText('')\u000a    LowerText_16.setText('')\u000a    # keep track of which components have finished\u000a    TrialParts_1Components = []\u000a    TrialParts_1Components.append(text_27)\u000a    TrialParts_1Components.append(text_30)\u000a    TrialParts_1Components.append(text_31)\u000a    TrialParts_1Components.append(text_32)\u000a    TrialParts_1Components.append(ISI_16)\u000a    TrialParts_1Components.append(TopUpperLine_16)\u000a    TrialParts_1Components.append(UpperText_16)\u000a    TrialParts_1Components.append(UpperBrackets_16)\u000a    TrialParts_1Components.append(BotUpperLine_16)\u000a    TrialParts_1Components.append(TopLowerLine_16)\u000a    TrialParts_1Components.append(LowerText_16)\u000a    TrialParts_1Components.append(LowerBrackets_16)\u000a    TrialParts_1Components.append(BotLowerLine_16)\u000a    TrialParts_1Components.append(TrialCrossHair_16)\u000a    TrialParts_1Components.append(RestCrossHair_16)\u000a    TrialParts_1Components.append(text_36)\u000a    TrialParts_1Components.append(text_37)\u000a    TrialParts_1Components.append(text_50)\u000a    for thisComponent in TrialParts_1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialParts_1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialParts_1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_27* updates\u000a        if t >= 0.0 and text_27.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_27.tStart = t  # underestimates by a little under one frame\u000a            text_27.frameNStart = frameN  # exact frame index\u000a            text_27.setAutoDraw(True)\u000a        elif text_27.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_27.setAutoDraw(False)\u000a        \u000a        # *text_30* updates\u000a        if t >= 3 and text_30.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_30.tStart = t  # underestimates by a little under one frame\u000a            text_30.frameNStart = frameN  # exact frame index\u000a            text_30.setAutoDraw(True)\u000a        elif text_30.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_30.setAutoDraw(False)\u000a        \u000a        # *text_31* updates\u000a        if t >= 6 and text_31.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_31.tStart = t  # underestimates by a little under one frame\u000a            text_31.frameNStart = frameN  # exact frame index\u000a            text_31.setAutoDraw(True)\u000a        elif text_31.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_31.setAutoDraw(False)\u000a        \u000a        # *text_32* updates\u000a        if t >= 9 and text_32.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_32.tStart = t  # underestimates by a little under one frame\u000a            text_32.frameNStart = frameN  # exact frame index\u000a            text_32.setAutoDraw(True)\u000a        elif text_32.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_32.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_16* updates\u000a        if t >= 0 and TopUpperLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_16.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_16.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_16.setAutoDraw(True)\u000a        elif TopUpperLine_16.status == STARTED and t >= (0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_16.setAutoDraw(False)\u000a        \u000a        # *UpperText_16* updates\u000a        if t >= 0 and UpperText_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_16.tStart = t  # underestimates by a little under one frame\u000a            UpperText_16.frameNStart = frameN  # exact frame index\u000a            UpperText_16.setAutoDraw(True)\u000a        elif UpperText_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_16.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_16* updates\u000a        if t >= 0 and UpperBrackets_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_16.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_16.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_16.setAutoDraw(True)\u000a        elif UpperBrackets_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_16.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_16* updates\u000a        if t >= 0.0 and BotUpperLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_16.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_16.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_16.setAutoDraw(True)\u000a        elif BotUpperLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_16.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_16* updates\u000a        if t >= 0.0 and TopLowerLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_16.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_16.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_16.setAutoDraw(True)\u000a        elif TopLowerLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_16.setAutoDraw(False)\u000a        \u000a        # *LowerText_16* updates\u000a        if t >= 0 and LowerText_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_16.tStart = t  # underestimates by a little under one frame\u000a            LowerText_16.frameNStart = frameN  # exact frame index\u000a            LowerText_16.setAutoDraw(True)\u000a        elif LowerText_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_16.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_16* updates\u000a        if t >= 0 and LowerBrackets_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_16.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_16.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_16.setAutoDraw(True)\u000a        elif LowerBrackets_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_16.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_16* updates\u000a        if t >= 0.0 and BotLowerLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_16.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_16.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_16.setAutoDraw(True)\u000a        elif BotLowerLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_16.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_16* updates\u000a        if t >= 0 and TrialCrossHair_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_16.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_16.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_16.setAutoDraw(True)\u000a        elif TrialCrossHair_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_16.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_16* updates\u000a        if t >= 0 and RestCrossHair_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_16.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_16.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_16.setAutoDraw(True)\u000a        elif RestCrossHair_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_16.setAutoDraw(False)\u000a        \u000a        # *text_36* updates\u000a        if t >= 12 and text_36.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_36.tStart = t  # underestimates by a little under one frame\u000a            text_36.frameNStart = frameN  # exact frame index\u000a            text_36.setAutoDraw(True)\u000a        elif text_36.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_36.setAutoDraw(False)\u000a        \u000a        # *text_37* updates\u000a        if t >= 15 and text_37.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_37.tStart = t  # underestimates by a little under one frame\u000a            text_37.frameNStart = frameN  # exact frame index\u000a            text_37.setAutoDraw(True)\u000a        elif text_37.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_37.setAutoDraw(False)\u000a        \u000a        # *text_50* updates\u000a        if t >= 20 and text_50.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_50.tStart = t  # underestimates by a little under one frame\u000a            text_50.frameNStart = frameN  # exact frame index\u000a            text_50.setAutoDraw(True)\u000a        elif text_50.status == STARTED and t >= (20 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_50.setAutoDraw(False)\u000a        # *ISI_16* period\u000a        if t >= 0.0 and ISI_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_16.tStart = t  # underestimates by a little under one frame\u000a            ISI_16.frameNStart = frameN  # exact frame index\u000a            ISI_16.start(1)\u000a        elif ISI_16.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_16.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialParts_1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialParts_1"-------\u000a    for thisComponent in TrialParts_1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "trial5_2"-------\u000a    t = 0\u000a    trial5_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    UpperText.setText(u' L K R G M X ')\u000a    UpperBrackets.setText(u'  {         }')\u000a    LowerText.setText(u' b t y g q j ')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trial5_2Components = []\u000a    trial5_2Components.append(ISI)\u000a    trial5_2Components.append(TopUpperLine)\u000a    trial5_2Components.append(UpperText)\u000a    trial5_2Components.append(UpperBrackets)\u000a    trial5_2Components.append(BotUpperLine)\u000a    trial5_2Components.append(TopLowerLine)\u000a    trial5_2Components.append(LowerText)\u000a    trial5_2Components.append(LowerBrackets)\u000a    trial5_2Components.append(BotLowerLine)\u000a    trial5_2Components.append(TrialCrossHair)\u000a    trial5_2Components.append(RestCrossHair)\u000a    trial5_2Components.append(resp)\u000a    for thisComponent in trial5_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "trial5_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial5_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *TopUpperLine* updates\u000a        if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine.frameNStart = frameN  # exact frame index\u000a            TopUpperLine.setAutoDraw(True)\u000a        elif TopUpperLine.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine.setAutoDraw(False)\u000a        \u000a        # *UpperText* updates\u000a        if t >= 0 and UpperText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText.tStart = t  # underestimates by a little under one frame\u000a            UpperText.frameNStart = frameN  # exact frame index\u000a            UpperText.setAutoDraw(True)\u000a        elif UpperText.status == STARTED and t >= (0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets* updates\u000a        if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets.frameNStart = frameN  # exact frame index\u000a            UpperBrackets.setAutoDraw(True)\u000a        elif UpperBrackets.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine* updates\u000a        if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine.frameNStart = frameN  # exact frame index\u000a            BotUpperLine.setAutoDraw(True)\u000a        elif BotUpperLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine* updates\u000a        if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine.frameNStart = frameN  # exact frame index\u000a            TopLowerLine.setAutoDraw(True)\u000a        elif TopLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine.setAutoDraw(False)\u000a        \u000a        # *LowerText* updates\u000a        if t >= 7 and LowerText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText.tStart = t  # underestimates by a little under one frame\u000a            LowerText.frameNStart = frameN  # exact frame index\u000a            LowerText.setAutoDraw(True)\u000a        elif LowerText.status == STARTED and t >= (7 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets* updates\u000a        if t >= 7 and LowerBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets.frameNStart = frameN  # exact frame index\u000a            LowerBrackets.setAutoDraw(True)\u000a        elif LowerBrackets.status == STARTED and t >= (7 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine* updates\u000a        if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine.frameNStart = frameN  # exact frame index\u000a            BotLowerLine.setAutoDraw(True)\u000a        elif BotLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair* updates\u000a        if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair.setAutoDraw(True)\u000a        elif TrialCrossHair.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair* updates\u000a        if t >= 9 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (9 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # *resp* updates\u000a        if t >= 7 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif resp.status == STARTED and t >= (7 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(u'6')) or (resp.keys == u'6'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(1)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial5_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "trial5_2"-------\u000a    for thisComponent in trial5_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(u'6').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('resp.keys',resp.keys)\u000a    thisExp.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        thisExp.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "TrialFeedBack"-------\u000a    t = 0\u000a    TrialFeedBackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.000000)\u000a    # update component parameters for each repeat\u000a    if ((resp.corr) & (resp.rt < 2.0)):#stored on last run routine\u000a      msg="Correct and on time! RT=%.3f" %(resp.rt)\u000a    elif ((resp.corr) & (resp.rt > 2.0)):#stored on last run routine\u000a      msg="Correct, but too slow!\u005cn RT=%.3f\u005cnResponse time should be less than two seconds." %(resp.rt)\u000a    else:\u000a      if resp.rt < 2.0:\u000a        msg="Oops! That was incorrect, but on time!"\u000a      else: \u000a        msg="Oops! That was incorrect and too slow!"\u000a    text_47.setText(msg)\u000a    # keep track of which components have finished\u000a    TrialFeedBackComponents = []\u000a    TrialFeedBackComponents.append(text_47)\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialFeedBack"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialFeedBackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text_47* updates\u000a        if t >= 0.0 and text_47.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_47.tStart = t  # underestimates by a little under one frame\u000a            text_47.frameNStart = frameN  # exact frame index\u000a            text_47.setAutoDraw(True)\u000a        elif text_47.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_47.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialFeedBackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialFeedBack"-------\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    msg='Ended'\u000a    win.close()\u000a#    win.close()\u000a\u000adef Test(subid,visitid):\u000a    expInfo = {u'Visit ID': u'9999', u'Participant ID': u'1'}\u000a    print 'subid is %s'%(subid)\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a    else:\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid    \u000a    # Store info about the experiment session\u000a\u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'],expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=False,\u000a        dataFileName=filename)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=ScreenToUse, color=[-1,-1,-1], colorSpace='rgb',\u000a        blendMode='average', useFBO=True,\u000a        units='cm')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial_2"\u000a    trial_2Clock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text='      { }    ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Initialize components for Routine "TrialFeedBack"\u000a    TrialFeedBackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    text = visual.TextStim(win=win, ori=0, name='text',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    #------Prepare to start Routine "trial_2"-------\u000a    t = 0\u000a    trial_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    UpperText.setText(' A B C D E F ')\u000a    UpperBrackets.setText('  {         }')\u000a    LowerText.setText(' a b c d e f ')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trial_2Components = []\u000a    trial_2Components.append(ISI)\u000a    trial_2Components.append(TopUpperLine)\u000a    trial_2Components.append(UpperText)\u000a    trial_2Components.append(UpperBrackets)\u000a    trial_2Components.append(BotUpperLine)\u000a    trial_2Components.append(TopLowerLine)\u000a    trial_2Components.append(LowerText)\u000a    trial_2Components.append(LowerBrackets)\u000a    trial_2Components.append(BotLowerLine)\u000a    trial_2Components.append(TrialCrossHair)\u000a    trial_2Components.append(RestCrossHair)\u000a    trial_2Components.append(resp)\u000a    for thisComponent in trial_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "trial_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *TopUpperLine* updates\u000a        if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine.frameNStart = frameN  # exact frame index\u000a            TopUpperLine.setAutoDraw(True)\u000a        elif TopUpperLine.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine.setAutoDraw(False)\u000a        \u000a        # *UpperText* updates\u000a        if t >= 0 and UpperText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText.tStart = t  # underestimates by a little under one frame\u000a            UpperText.frameNStart = frameN  # exact frame index\u000a            UpperText.setAutoDraw(True)\u000a        elif UpperText.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets* updates\u000a        if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets.frameNStart = frameN  # exact frame index\u000a            UpperBrackets.setAutoDraw(True)\u000a        elif UpperBrackets.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine* updates\u000a        if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine.frameNStart = frameN  # exact frame index\u000a            BotUpperLine.setAutoDraw(True)\u000a        elif BotUpperLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine* updates\u000a        if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine.frameNStart = frameN  # exact frame index\u000a            TopLowerLine.setAutoDraw(True)\u000a        elif TopLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine.setAutoDraw(False)\u000a        \u000a        # *LowerText* updates\u000a        if t >= 7 and LowerText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText.tStart = t  # underestimates by a little under one frame\u000a            LowerText.frameNStart = frameN  # exact frame index\u000a            LowerText.setAutoDraw(True)\u000a        elif LowerText.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets* updates\u000a        if t >= 7 and LowerBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets.frameNStart = frameN  # exact frame index\u000a            LowerBrackets.setAutoDraw(True)\u000a        elif LowerBrackets.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine* updates\u000a        if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine.frameNStart = frameN  # exact frame index\u000a            BotLowerLine.setAutoDraw(True)\u000a        elif BotLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair* updates\u000a        if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair.setAutoDraw(True)\u000a        elif TrialCrossHair.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair* updates\u000a        if t >= 9 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (9 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # *resp* updates\u000a        if t >= 7 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif resp.status == STARTED and t >= (7 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(u'6')) or (resp.keys == u'6'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(1)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "trial_2"-------\u000a    for thisComponent in trial_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(u'6').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('resp.keys',resp.keys)\u000a    thisExp.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        thisExp.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "TrialFeedBack"-------\u000a    t = 0\u000a    TrialFeedBackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.000000)\u000a    # update component parameters for each repeat\u000a    if ((resp.corr) & (resp.rt < 2.0)):#stored on last run routine\u000a      msg="Correct and on time! RT=%.3f" %(resp.rt)\u000a    elif ((resp.corr) & (resp.rt > 2.0)):#stored on last run routine\u000a      msg="Correct, but too slow!\u005cn RT=%.3f\u005cnResponse time should be less than two seconds." %(resp.rt)\u000a    else:\u000a      if resp.rt < 2.0:\u000a        msg="Oops! That was incorrect, but on time!"\u000a      else: \u000a        msg="Oops! That was incorrect and too slow!"\u000a    text.setText(msg)\u000a    # keep track of which components have finished\u000a    TrialFeedBackComponents = []\u000a    TrialFeedBackComponents.append(text)\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialFeedBack"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialFeedBackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        elif text.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialFeedBackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialFeedBack"-------\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    msg='Ended'\u000a\u000a    win.close()\u000a\u000a
p1591
sS'thisTrial'
p1592
(lp1593
sS'_exp'
p1594
I425787920
sg10
S'trials'
p1595
sg6
S'/Users/jason/Dropbox/SteffenerColumbia/Scripts/ExperimentalStimuli/PartialTrialDIR/Scripts/PsychoPyTask/PartialTrialFunction.py'
p1596
sS'thisRepN'
p1597
I1
sg20
I01
sg21
g22
sS'data'
p1598
g1
(cpsychopy.data
DataHandler
p1599
c__builtin__
dict
p1600
(dp1601
g18
cnumpy.ma.core
_mareconstruct
p1602
(cnumpy.ma.core
MaskedArray
p1603
cnumpy
ndarray
p1604
(I0
tp1605
S'b'
tRp1606
(I1
(I72
I1
tg31
(S'f4'
I0
I1
tRp1607
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
cnumpy.core.multiarray
_reconstruct
p1608
(g1604
(I0
tS'b'
tRp1609
(I1
(I72
I1
tg31
(S'O4'
I0
I1
tRp1610
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp1611
S'--'
p1612
aS'--'
p1613
ag111
ag133
ag155
ag177
ag199
ag221
ag243
aS'--'
p1614
ag284
ag306
aS'--'
p1615
ag347
aS'--'
p1616
ag388
ag410
ag432
ag454
ag476
ag498
ag520
ag542
ag564
aS'--'
p1617
aS'--'
p1618
ag624
aS'--'
p1619
aS'--'
p1620
ag684
ag706
aS'--'
p1621
ag747
aS'--'
p1622
ag788
ag810
ag832
aS'--'
p1623
ag873
ag895
ag917
ag939
aS'--'
p1624
ag980
ag1001
ag1023
ag1045
ag1067
aS'--'
p1625
aS'--'
p1626
ag1127
ag1149
aS'--'
p1627
aS'--'
p1628
aS'--'
p1629
ag1228
ag1250
ag1272
aS'--'
p1630
aS'--'
p1631
ag1332
ag1354
ag1376
aS'--'
p1632
ag1417
ag1439
aS'--'
p1633
ag1480
aS'--'
p1634
aS'--'
p1635
ag1540
ag1562
atbsS'ran'
p1636
g1602
(g1603
g1604
g1605
S'b'
tRp1637
(I1
(I72
I1
tg1607
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
g1608
(g1604
(I0
tS'b'
tRp1638
(I1
(I72
I1
tg1610
I00
(lp1639
NaNag130
ag152
ag174
ag196
ag218
ag240
ag262
aNag303
ag325
aNag366
aNag407
ag429
ag451
ag473
ag495
ag517
ag539
ag561
ag583
aNaNag643
aNaNag703
ag725
aNag766
aNag807
ag829
ag851
aNag892
ag914
ag936
ag958
aNag998
ag1020
ag1042
ag1064
ag1086
aNaNag1146
ag1168
aNaNaNag1247
ag1269
ag1291
aNaNag1351
ag1373
ag1395
aNag1436
ag1458
aNag1499
aNaNag1559
ag1581
atbsg16
g1602
(g1603
g1604
g1605
S'b'
tRp1640
(I1
(I72
I1
tg1607
I00
S'\xf5L\xadN\xf5L\xadN\xf5L\xadN\xf6L\xadN\xf6L\xadN\xf6L\xadN\xf6L\xadN\xf6L\xadN\xf6L\xadN\xf6L\xadN\xf6L\xadN\xf6L\xadN\xf6L\xadN\xf6L\xadN\xf6L\xadN\xf7L\xadN\xf7L\xadN\xf7L\xadN\xf7L\xadN\xf7L\xadN\xf7L\xadN\xf7L\xadN\xf7L\xadN\xf7L\xadN\xf7L\xadN\xf8L\xadN\xf8L\xadN\xf8L\xadN\xf8L\xadN\xf8L\xadN\xf8L\xadN\xf8L\xadN\xf8L\xadN\xf8L\xadN\xf8L\xadN\xf8L\xadN\xf8L\xadN\xf9L\xadN\xf9L\xadN\xf9L\xadN\xf9L\xadN\xf9L\xadN\xf9L\xadN\xf9L\xadN\xf9L\xadN\xf9L\xadN\xf9L\xadN\xf9L\xadN\xf9L\xadN\xf9L\xadN\xfaL\xadN\xfaL\xadN\xfaL\xadN\xfaL\xadN\xfaL\xadN\xfaL\xadN\xfaL\xadN\xfaL\xadN\xfaL\xadN\xfaL\xadN\xfaL\xadN\xfaL\xadN\xfaL\xadN\xfbL\xadN\xfbL\xadN\xfbL\xadN\xfbL\xadN\xfbL\xadN\xfbL\xadN\xfbL\xadN\xfbL\xadN\xfbL\xadN'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p1641
g1602
(g1603
g1604
g1605
S'b'
tRp1642
(I1
(I72
I1
tg1607
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB\x00\x00 B\x00\x00$B\x00\x00(B\x00\x00,B\x00\x000B\x00\x004B\x00\x008B\x00\x00<B\x00\x00@B\x00\x00DB\x00\x00HB\x00\x00LB\x00\x00PB\x00\x00TB\x00\x00XB\x00\x00\\B\x00\x00`B\x00\x00dB\x00\x00hB\x00\x00lB\x00\x00pB\x00\x00tB\x00\x00xB\x00\x00|B\x00\x00\x80B\x00\x00\x82B\x00\x00\x84B\x00\x00\x86B\x00\x00\x88B\x00\x00\x8aB\x00\x00\x8cB\x00\x00\x8eB'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1643
(dp1644
S'isNumeric'
p1645
(dp1646
g18
I01
sg1636
I01
sg16
I01
sg19
I00
sg17
I00
sg1641
I01
ssg1595
g1588
sS'dataTypes'
p1647
(lp1648
g1636
ag1641
ag16
ag17
ag18
ag19
asS'dataShape'
p1649
(lp1650
I72
aI1
asbsS'method'
p1651
Vsequential
p1652
sS'sequenceIndices'
p1653
g1608
(g1604
(I0
tS'b'
tRp1654
(I1
(I72
I1
tg81
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00(\x00\x00\x00)\x00\x00\x00*\x00\x00\x00+\x00\x00\x00,\x00\x00\x00-\x00\x00\x00.\x00\x00\x00/\x00\x00\x000\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x004\x00\x00\x005\x00\x00\x006\x00\x00\x007\x00\x00\x008\x00\x00\x009\x00\x00\x00:\x00\x00\x00;\x00\x00\x00<\x00\x00\x00=\x00\x00\x00>\x00\x00\x00?\x00\x00\x00@\x00\x00\x00A\x00\x00\x00B\x00\x00\x00C\x00\x00\x00D\x00\x00\x00E\x00\x00\x00F\x00\x00\x00G\x00\x00\x00'
tbsS'finished'
p1655
I01
sS'nReps'
p1656
I1
sS'nRemaining'
p1657
I-1
sS'trialList'
p1658
(lp1659
g1
(cpsychopy.data
TrialType
p1660
g1600
(dp1661
g42
g79
sg43
g71
sg44
g83
sg45
g72
sg46
g73
sg47
g85
sg48
g74
sg49
g75
sg50
g87
sg51
g76
sg52
g77
sg53
S' '
sg54
g89
sg55
g78
stRp1662
ag1
(g1660
g1600
(dp1663
g42
g99
sg43
g91
sg44
g102
sg45
g92
sg46
g93
sg47
g104
sg48
g94
sg49
g95
sg50
g106
sg51
g96
sg52
g97
sg53
S' '
sg54
g108
sg55
g98
stRp1664
ag1
(g1660
g1600
(dp1665
g42
g122
sg43
g116
sg44
g125
sg45
g117
sg46
g118
sg47
g114
sg48
g119
sg49
g110
sg50
g127
sg51
g120
sg52
g112
sg53
g121
sg54
g129
sg55
g113
stRp1666
ag1
(g1660
g1600
(dp1667
g42
g144
sg43
g138
sg44
g147
sg45
g139
sg46
g140
sg47
g136
sg48
g141
sg49
g132
sg50
g149
sg51
g142
sg52
g134
sg53
g143
sg54
g151
sg55
g135
stRp1668
ag1
(g1660
g1600
(dp1669
g42
g166
sg43
g160
sg44
g169
sg45
g161
sg46
g162
sg47
g158
sg48
g163
sg49
g154
sg50
g171
sg51
g164
sg52
g156
sg53
g165
sg54
g173
sg55
g157
stRp1670
ag1
(g1660
g1600
(dp1671
g42
g188
sg43
g182
sg44
g191
sg45
g183
sg46
g184
sg47
g180
sg48
g185
sg49
g176
sg50
g193
sg51
g186
sg52
g178
sg53
g187
sg54
g195
sg55
g179
stRp1672
ag1
(g1660
g1600
(dp1673
g42
g210
sg43
g204
sg44
g213
sg45
g205
sg46
g206
sg47
g202
sg48
g207
sg49
g198
sg50
g215
sg51
g208
sg52
g200
sg53
g209
sg54
g217
sg55
g201
stRp1674
ag1
(g1660
g1600
(dp1675
g42
g232
sg43
g226
sg44
g235
sg45
g227
sg46
g228
sg47
g224
sg48
g229
sg49
g220
sg50
g237
sg51
g230
sg52
g222
sg53
g231
sg54
g239
sg55
g223
stRp1676
ag1
(g1660
g1600
(dp1677
g42
g254
sg43
g248
sg44
g257
sg45
g249
sg46
g250
sg47
g246
sg48
g251
sg49
g242
sg50
g259
sg51
g252
sg52
g244
sg53
g253
sg54
g261
sg55
g245
stRp1678
ag1
(g1660
g1600
(dp1679
g42
g272
sg43
g264
sg44
g275
sg45
g265
sg46
g266
sg47
g277
sg48
g267
sg49
g268
sg50
g279
sg51
g269
sg52
g270
sg53
S' '
sg54
g281
sg55
g271
stRp1680
ag1
(g1660
g1600
(dp1681
g42
g295
sg43
g289
sg44
g298
sg45
g290
sg46
g291
sg47
g287
sg48
g292
sg49
g283
sg50
g300
sg51
g293
sg52
g285
sg53
g294
sg54
g302
sg55
g286
stRp1682
ag1
(g1660
g1600
(dp1683
g42
g317
sg43
g311
sg44
g320
sg45
g312
sg46
g313
sg47
g309
sg48
g314
sg49
g305
sg50
g322
sg51
g315
sg52
g307
sg53
g316
sg54
g324
sg55
g308
stRp1684
ag1
(g1660
g1600
(dp1685
g42
g335
sg43
g327
sg44
g338
sg45
g328
sg46
g329
sg47
g340
sg48
g330
sg49
g331
sg50
g342
sg51
g332
sg52
g333
sg53
S' '
sg54
g344
sg55
g334
stRp1686
ag1
(g1660
g1600
(dp1687
g42
g358
sg43
g352
sg44
g361
sg45
g353
sg46
g354
sg47
g350
sg48
g355
sg49
g346
sg50
g363
sg51
g356
sg52
g348
sg53
g357
sg54
g365
sg55
g349
stRp1688
ag1
(g1660
g1600
(dp1689
g42
g376
sg43
g368
sg44
g379
sg45
g369
sg46
g370
sg47
g381
sg48
g371
sg49
g372
sg50
g383
sg51
g373
sg52
g374
sg53
S' '
sg54
g385
sg55
g375
stRp1690
ag1
(g1660
g1600
(dp1691
g42
g399
sg43
g393
sg44
g402
sg45
g394
sg46
g395
sg47
g391
sg48
g396
sg49
g387
sg50
g404
sg51
g397
sg52
g389
sg53
g398
sg54
g406
sg55
g390
stRp1692
ag1
(g1660
g1600
(dp1693
g42
g421
sg43
g415
sg44
g424
sg45
g416
sg46
g417
sg47
g413
sg48
g418
sg49
g409
sg50
g426
sg51
g419
sg52
g411
sg53
g420
sg54
g428
sg55
g412
stRp1694
ag1
(g1660
g1600
(dp1695
g42
g443
sg43
g437
sg44
g446
sg45
g438
sg46
g439
sg47
g435
sg48
g440
sg49
g431
sg50
g448
sg51
g441
sg52
g433
sg53
g442
sg54
g450
sg55
g434
stRp1696
ag1
(g1660
g1600
(dp1697
g42
g465
sg43
g459
sg44
g468
sg45
g460
sg46
g461
sg47
g457
sg48
g462
sg49
g453
sg50
g470
sg51
g463
sg52
g455
sg53
g464
sg54
g472
sg55
g456
stRp1698
ag1
(g1660
g1600
(dp1699
g42
g487
sg43
g481
sg44
g490
sg45
g482
sg46
g483
sg47
g479
sg48
g484
sg49
g475
sg50
g492
sg51
g485
sg52
g477
sg53
g486
sg54
g494
sg55
g478
stRp1700
ag1
(g1660
g1600
(dp1701
g42
g509
sg43
g503
sg44
g512
sg45
g504
sg46
g505
sg47
g501
sg48
g506
sg49
g497
sg50
g514
sg51
g507
sg52
g499
sg53
g508
sg54
g516
sg55
g500
stRp1702
ag1
(g1660
g1600
(dp1703
g42
g531
sg43
g525
sg44
g534
sg45
g526
sg46
g527
sg47
g523
sg48
g528
sg49
g519
sg50
g536
sg51
g529
sg52
g521
sg53
g530
sg54
g538
sg55
g522
stRp1704
ag1
(g1660
g1600
(dp1705
g42
g553
sg43
g547
sg44
g556
sg45
g548
sg46
g549
sg47
g545
sg48
g550
sg49
g541
sg50
g558
sg51
g551
sg52
g543
sg53
g552
sg54
g560
sg55
g544
stRp1706
ag1
(g1660
g1600
(dp1707
g42
g575
sg43
g569
sg44
g578
sg45
g570
sg46
g571
sg47
g567
sg48
g572
sg49
g563
sg50
g580
sg51
g573
sg52
g565
sg53
g574
sg54
g582
sg55
g566
stRp1708
ag1
(g1660
g1600
(dp1709
g42
g593
sg43
g585
sg44
g596
sg45
g586
sg46
g587
sg47
g598
sg48
g588
sg49
g589
sg50
g600
sg51
g590
sg52
g591
sg53
S' '
sg54
g602
sg55
g592
stRp1710
ag1
(g1660
g1600
(dp1711
g42
g612
sg43
g604
sg44
g615
sg45
g605
sg46
g606
sg47
g617
sg48
g607
sg49
g608
sg50
g619
sg51
g609
sg52
g610
sg53
S' '
sg54
g621
sg55
g611
stRp1712
ag1
(g1660
g1600
(dp1713
g42
g635
sg43
g629
sg44
g638
sg45
g630
sg46
g631
sg47
g627
sg48
g632
sg49
g623
sg50
g640
sg51
g633
sg52
g625
sg53
g634
sg54
g642
sg55
g626
stRp1714
ag1
(g1660
g1600
(dp1715
g42
g653
sg43
g645
sg44
g656
sg45
g646
sg46
g647
sg47
g658
sg48
g648
sg49
g649
sg50
g660
sg51
g650
sg52
g651
sg53
S' '
sg54
g662
sg55
g652
stRp1716
ag1
(g1660
g1600
(dp1717
g42
g672
sg43
g664
sg44
g675
sg45
g665
sg46
g666
sg47
g677
sg48
g667
sg49
g668
sg50
g679
sg51
g669
sg52
g670
sg53
S' '
sg54
g681
sg55
g671
stRp1718
ag1
(g1660
g1600
(dp1719
g42
g695
sg43
g689
sg44
g698
sg45
g690
sg46
g691
sg47
g687
sg48
g692
sg49
g683
sg50
g700
sg51
g693
sg52
g685
sg53
g694
sg54
g702
sg55
g686
stRp1720
ag1
(g1660
g1600
(dp1721
g42
g717
sg43
g711
sg44
g720
sg45
g712
sg46
g713
sg47
g709
sg48
g714
sg49
g705
sg50
g722
sg51
g715
sg52
g707
sg53
g716
sg54
g724
sg55
g708
stRp1722
ag1
(g1660
g1600
(dp1723
g42
g735
sg43
g727
sg44
g738
sg45
g728
sg46
g729
sg47
g740
sg48
g730
sg49
g731
sg50
g742
sg51
g732
sg52
g733
sg53
S' '
sg54
g744
sg55
g734
stRp1724
ag1
(g1660
g1600
(dp1725
g42
g758
sg43
g752
sg44
g761
sg45
g753
sg46
g754
sg47
g750
sg48
g755
sg49
g746
sg50
g763
sg51
g756
sg52
g748
sg53
g757
sg54
g765
sg55
g749
stRp1726
ag1
(g1660
g1600
(dp1727
g42
g776
sg43
g768
sg44
g779
sg45
g769
sg46
g770
sg47
g781
sg48
g771
sg49
g772
sg50
g783
sg51
g773
sg52
g774
sg53
S' '
sg54
g785
sg55
g775
stRp1728
ag1
(g1660
g1600
(dp1729
g42
g799
sg43
g793
sg44
g802
sg45
g794
sg46
g795
sg47
g791
sg48
g796
sg49
g787
sg50
g804
sg51
g797
sg52
g789
sg53
g798
sg54
g806
sg55
g790
stRp1730
ag1
(g1660
g1600
(dp1731
g42
g821
sg43
g815
sg44
g824
sg45
g816
sg46
g817
sg47
g813
sg48
g818
sg49
g809
sg50
g826
sg51
g819
sg52
g811
sg53
g820
sg54
g828
sg55
g812
stRp1732
ag1
(g1660
g1600
(dp1733
g42
g843
sg43
g837
sg44
g846
sg45
g838
sg46
g839
sg47
g835
sg48
g840
sg49
g831
sg50
g848
sg51
g841
sg52
g833
sg53
g842
sg54
g850
sg55
g834
stRp1734
ag1
(g1660
g1600
(dp1735
g42
g861
sg43
g853
sg44
g864
sg45
g854
sg46
g855
sg47
g866
sg48
g856
sg49
g857
sg50
g868
sg51
g858
sg52
g859
sg53
S' '
sg54
g870
sg55
g860
stRp1736
ag1
(g1660
g1600
(dp1737
g42
g884
sg43
g878
sg44
g887
sg45
g879
sg46
g880
sg47
g876
sg48
g881
sg49
g872
sg50
g889
sg51
g882
sg52
g874
sg53
g883
sg54
g891
sg55
g875
stRp1738
ag1
(g1660
g1600
(dp1739
g42
g906
sg43
g900
sg44
g909
sg45
g901
sg46
g902
sg47
g898
sg48
g903
sg49
g894
sg50
g911
sg51
g904
sg52
g896
sg53
g905
sg54
g913
sg55
g897
stRp1740
ag1
(g1660
g1600
(dp1741
g42
g928
sg43
g922
sg44
g931
sg45
g923
sg46
g924
sg47
g920
sg48
g925
sg49
g916
sg50
g933
sg51
g926
sg52
g918
sg53
g927
sg54
g935
sg55
g919
stRp1742
ag1
(g1660
g1600
(dp1743
g42
g950
sg43
g944
sg44
g953
sg45
g945
sg46
g946
sg47
g942
sg48
g947
sg49
g938
sg50
g955
sg51
g948
sg52
g940
sg53
g949
sg54
g957
sg55
g941
stRp1744
ag1
(g1660
g1600
(dp1745
g42
g968
sg43
g960
sg44
g971
sg45
g961
sg46
g962
sg47
g973
sg48
g963
sg49
g964
sg50
g975
sg51
g965
sg52
g966
sg53
S' '
sg54
g977
sg55
g967
stRp1746
ag1
(g1660
g1600
(dp1747
g42
g990
sg43
g985
sg44
g993
sg45
g986
sg46
g987
sg47
g983
sg48
g988
sg49
g979
sg50
g995
sg51
g419
sg52
g981
sg53
g989
sg54
g997
sg55
g982
stRp1748
ag1
(g1660
g1600
(dp1749
g42
g1012
sg43
g1006
sg44
g1015
sg45
g1007
sg46
g1008
sg47
g1004
sg48
g1009
sg49
g1000
sg50
g1017
sg51
g1010
sg52
g1002
sg53
g1011
sg54
g1019
sg55
g1003
stRp1750
ag1
(g1660
g1600
(dp1751
g42
g1034
sg43
g1028
sg44
g1037
sg45
g1029
sg46
g1030
sg47
g1026
sg48
g1031
sg49
g1022
sg50
g1039
sg51
g1032
sg52
g1024
sg53
g1033
sg54
g1041
sg55
g1025
stRp1752
ag1
(g1660
g1600
(dp1753
g42
g1056
sg43
g1050
sg44
g1059
sg45
g1051
sg46
g1052
sg47
g1048
sg48
g1053
sg49
g1044
sg50
g1061
sg51
g1054
sg52
g1046
sg53
g1055
sg54
g1063
sg55
g1047
stRp1754
ag1
(g1660
g1600
(dp1755
g42
g1078
sg43
g1072
sg44
g1081
sg45
g1073
sg46
g1074
sg47
g1070
sg48
g1075
sg49
g1066
sg50
g1083
sg51
g1076
sg52
g1068
sg53
g1077
sg54
g1085
sg55
g1069
stRp1756
ag1
(g1660
g1600
(dp1757
g42
g1096
sg43
g1088
sg44
g1099
sg45
g1089
sg46
g1090
sg47
g1101
sg48
g1091
sg49
g1092
sg50
g1103
sg51
g1093
sg52
g1094
sg53
S' '
sg54
g1105
sg55
g1095
stRp1758
ag1
(g1660
g1600
(dp1759
g42
g1115
sg43
g1107
sg44
g1118
sg45
g1108
sg46
g1109
sg47
g1120
sg48
g1110
sg49
g1111
sg50
g1122
sg51
g1112
sg52
g1113
sg53
S' '
sg54
g1124
sg55
g1114
stRp1760
ag1
(g1660
g1600
(dp1761
g42
g1138
sg43
g1132
sg44
g1141
sg45
g1133
sg46
g1134
sg47
g1130
sg48
g1135
sg49
g1126
sg50
g1143
sg51
g1136
sg52
g1128
sg53
g1137
sg54
g1145
sg55
g1129
stRp1762
ag1
(g1660
g1600
(dp1763
g42
g1160
sg43
g1154
sg44
g1163
sg45
g1155
sg46
g1156
sg47
g1152
sg48
g1157
sg49
g1148
sg50
g1165
sg51
g1158
sg52
g1150
sg53
g1159
sg54
g1167
sg55
g1151
stRp1764
ag1
(g1660
g1600
(dp1765
g42
g1178
sg43
g1170
sg44
g1181
sg45
g1171
sg46
g1172
sg47
g1183
sg48
g1173
sg49
g1174
sg50
g1185
sg51
g1175
sg52
g1176
sg53
S' '
sg54
g1187
sg55
g1177
stRp1766
ag1
(g1660
g1600
(dp1767
g42
g1197
sg43
g1189
sg44
g1200
sg45
g1190
sg46
g1191
sg47
g1202
sg48
g1192
sg49
g1193
sg50
g1204
sg51
g1194
sg52
g1195
sg53
S' '
sg54
g1206
sg55
g1196
stRp1768
ag1
(g1660
g1600
(dp1769
g42
g1216
sg43
g1208
sg44
g1219
sg45
g1209
sg46
g1210
sg47
g1221
sg48
g1211
sg49
g1212
sg50
g1223
sg51
g1213
sg52
g1214
sg53
S' '
sg54
g1225
sg55
g1215
stRp1770
ag1
(g1660
g1600
(dp1771
g42
g1239
sg43
g1233
sg44
g1242
sg45
g1234
sg46
g1235
sg47
g1231
sg48
g1236
sg49
g1227
sg50
g1244
sg51
g1237
sg52
g1229
sg53
g1238
sg54
g1246
sg55
g1230
stRp1772
ag1
(g1660
g1600
(dp1773
g42
g1261
sg43
g1255
sg44
g1264
sg45
g1256
sg46
g1257
sg47
g1253
sg48
g1258
sg49
g1249
sg50
g1266
sg51
g1259
sg52
g1251
sg53
g1260
sg54
g1268
sg55
g1252
stRp1774
ag1
(g1660
g1600
(dp1775
g42
g1283
sg43
g1277
sg44
g1286
sg45
g1278
sg46
g1279
sg47
g1275
sg48
g1280
sg49
g1271
sg50
g1288
sg51
g1281
sg52
g1273
sg53
g1282
sg54
g1290
sg55
g1274
stRp1776
ag1
(g1660
g1600
(dp1777
g42
g1301
sg43
g1293
sg44
g1304
sg45
g1294
sg46
g1295
sg47
g1306
sg48
g1296
sg49
g1297
sg50
g1308
sg51
g1298
sg52
g1299
sg53
S' '
sg54
g1310
sg55
g1300
stRp1778
ag1
(g1660
g1600
(dp1779
g42
g1320
sg43
g1312
sg44
g1323
sg45
g1313
sg46
g1314
sg47
g1325
sg48
g1315
sg49
g1316
sg50
g1327
sg51
g1317
sg52
g1318
sg53
S' '
sg54
g1329
sg55
g1319
stRp1780
ag1
(g1660
g1600
(dp1781
g42
g1343
sg43
g1337
sg44
g1346
sg45
g1338
sg46
g1339
sg47
g1335
sg48
g1340
sg49
g1331
sg50
g1348
sg51
g1341
sg52
g1333
sg53
g1342
sg54
g1350
sg55
g1334
stRp1782
ag1
(g1660
g1600
(dp1783
g42
g1365
sg43
g1359
sg44
g1368
sg45
g1360
sg46
g1361
sg47
g1357
sg48
g1362
sg49
g1353
sg50
g1370
sg51
g1363
sg52
g1355
sg53
g1364
sg54
g1372
sg55
g1356
stRp1784
ag1
(g1660
g1600
(dp1785
g42
g1387
sg43
g1381
sg44
g1390
sg45
g1382
sg46
g1383
sg47
g1379
sg48
g1384
sg49
g1375
sg50
g1392
sg51
g1385
sg52
g1377
sg53
g1386
sg54
g1394
sg55
g1378
stRp1786
ag1
(g1660
g1600
(dp1787
g42
g1405
sg43
g1397
sg44
g1408
sg45
g1398
sg46
g1399
sg47
g1410
sg48
g1400
sg49
g1401
sg50
g1412
sg51
g1402
sg52
g1403
sg53
S' '
sg54
g1414
sg55
g1404
stRp1788
ag1
(g1660
g1600
(dp1789
g42
g1428
sg43
g1422
sg44
g1431
sg45
g1423
sg46
g1424
sg47
g1420
sg48
g1425
sg49
g1416
sg50
g1433
sg51
g1426
sg52
g1418
sg53
g1427
sg54
g1435
sg55
g1419
stRp1790
ag1
(g1660
g1600
(dp1791
g42
g1450
sg43
g1444
sg44
g1453
sg45
g1445
sg46
g1446
sg47
g1442
sg48
g1447
sg49
g1438
sg50
g1455
sg51
g1448
sg52
g1440
sg53
g1449
sg54
g1457
sg55
g1441
stRp1792
ag1
(g1660
g1600
(dp1793
g42
g1468
sg43
g1460
sg44
g1471
sg45
g1461
sg46
g1462
sg47
g1473
sg48
g1463
sg49
g1464
sg50
g1475
sg51
g1465
sg52
g1466
sg53
S' '
sg54
g1477
sg55
g1467
stRp1794
ag1
(g1660
g1600
(dp1795
g42
g1491
sg43
g1485
sg44
g1494
sg45
g1486
sg46
g1487
sg47
g1483
sg48
g1488
sg49
g1479
sg50
g1496
sg51
g1489
sg52
g1481
sg53
g1490
sg54
g1498
sg55
g1482
stRp1796
ag1
(g1660
g1600
(dp1797
g42
g1509
sg43
g1501
sg44
g1512
sg45
g1502
sg46
g1503
sg47
g1514
sg48
g1504
sg49
g1505
sg50
g1516
sg51
g1506
sg52
g1507
sg53
S' '
sg54
g1518
sg55
g1508
stRp1798
ag1
(g1660
g1600
(dp1799
g42
g1528
sg43
g1520
sg44
g1531
sg45
g1521
sg46
g1522
sg47
g1533
sg48
g1523
sg49
g1524
sg50
g1535
sg51
g1525
sg52
g1526
sg53
S' '
sg54
g1537
sg55
g1527
stRp1800
ag1
(g1660
g1600
(dp1801
g42
g1551
sg43
g1545
sg44
g1554
sg45
g1546
sg46
g1547
sg47
g1543
sg48
g1548
sg49
g1539
sg50
g1556
sg51
g1549
sg52
g1541
sg53
g1550
sg54
g1558
sg55
g1542
stRp1802
ag1
(g1660
g1600
(dp1803
g42
g1573
sg43
g1567
sg44
g1576
sg45
g1568
sg46
g1569
sg47
g1565
sg48
g1570
sg49
g1561
sg50
g1578
sg51
g1571
sg52
g1563
sg53
g1572
sg54
g1580
sg55
g1564
stRp1804
asS'seed'
p1805
NsS'thisIndex'
p1806
g1575
sS'thisN'
p1807
I72
sS'thisTrialN'
p1808
I0
sS'nTotal'
p1809
I72
sS'_warnUseOfNext'
p1810
I01
sbasS'savePickle'
p1811
I00
sb.