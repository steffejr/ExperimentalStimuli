ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Users/jason/Dropbox/SteffenerColumbia/Scripts/ExperimentalStimuli/PartialTrialDIR/Scripts/PsychoPyTask/data/2002_1_PartialTrial_2016_Jan_25_1458
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'PartialTrial'
p11
sS'dataNames'
p12
(lp13
S'ScannerTrigger.keys'
p14
aS'ScannerTrigger.rt'
p15
aS'TrialStartTime'
p16
aS'KeyboardResp.keys'
p17
aS'KeyboardResp.corr'
p18
aS'KeyboardResp.rt'
p19
asS'autoLog'
p20
I01
sS'extraInfo'
p21
(dp22
VParticipant ID
p23
S'2002'
p24
sS'date'
p25
V2016_Jan_25_1458
p26
sS'expName'
p27
g11
sVVisit ID
p28
S'1'
sS'frameRate'
p29
cnumpy.core.multiarray
scalar
p30
(cnumpy
dtype
p31
(S'f8'
I0
I1
tRp32
(I3
S'<'
NNNI-1
I-1
I0
tbS'\xb5\xcb%\x1c/\xfeM@'
tRp33
ssS'loopsUnfinished'
p34
(lp35
sS'saveWideText'
p36
I01
sS'thisEntry'
p37
(dp38
sS'version'
p39
S''
sS'_paramNamesSoFar'
p40
(lp41
S'RetDur'
p42
aS'BotBrack'
p43
aS'StimDur'
p44
aS'UpBrack'
p45
aS'ProbeDurITI'
p46
aS'ProbeDur'
p47
aS'ProbeStart'
p48
aS'TrialDur'
p49
aS'ITI'
p50
aS'StimSet'
p51
aS'RetStart'
p52
aS'ProbeLet'
p53
aS'TrialITIDur'
p54
aS'Correct'
p55
asS'entries'
p56
(lp57
(dp58
g23
g24
sS'trials.thisIndex'
p59
I0
sg27
g11
sg28
S'1'
sS'trials.thisRepN'
p60
I0
sg29
g33
sS'trials.thisN'
p61
I-1
sg15
F6.0189568996429443
sS'trials.thisTrialN'
p62
I-1
sg25
g26
sg14
S'equal'
p63
sa(dp64
g23
g24
sS'trials.thisIndex'
p65
I0
sg28
S'1'
sS'trials.thisRepN'
p66
I0
sg29
g33
sg16
F1453751946.3381121
sS'trials.thisN'
p67
I-1
sg27
g11
sS'trials.thisTrialN'
p68
I-1
sg25
g26
sa(dp69
g23
g24
sg29
g33
sg49
g30
(g31
(S'i8'
I0
I1
tRp70
(I3
S'<'
NNNI-1
I-1
I0
tbS'\t\x00\x00\x00\x00\x00\x00\x00'
tRp71
sg19
(lp72
F1.0179669857025146
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp73
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp74
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp75
sg16
F1453751956.340632
sS'trials.thisN'
p76
I0
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp77
sg45
g30
(g70
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp78
sg46
g30
(g32
S'\xbbI\x0c\x02+\x07\x18@'
tRp79
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp80
sg51
S'LXDRFJ'
p81
sg25
g26
sg53
S'gynqbh'
p82
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp83
sS'trials.thisIndex'
p84
g30
(g31
(S'i4'
I0
I1
tRp85
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00'
tRp86
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp87
sS'trials.thisRepN'
p88
I0
sg50
g30
(g32
S'\xbaI\x0c\x02+\x07\x10@'
tRp89
sg27
g11
sS'trials.thisTrialN'
p90
I0
sg54
g30
(g32
S'\xdd$\x06\x81\x95\x03*@'
tRp91
sg17
(lp92
S'8'
asa(dp93
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp94
sg45
g30
(g70
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp95
sg46
g30
(g32
S'5^\xbaI\x0c\x02\x10@'
tRp96
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp97
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp98
sg51
S'YXDMLR'
p99
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp100
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp101
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp102
sS'trials.thisIndex'
p103
g30
(g85
S'\x01\x00\x00\x00'
tRp104
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp105
sS'trials.thisRepN'
p106
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp107
sg16
F1453751969.3470919
sg29
g33
sS'trials.thisN'
p108
I1
sg50
g30
(g32
S'5^\xbaI\x0c\x02\x10@'
tRp109
sS'trials.thisTrialN'
p110
I1
sg54
g30
(g32
S'6^\xbaI\x0c\x02\x18@'
tRp111
sg17
Nsa(dp112
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp113
sg45
g30
(g70
S'8\x00\x00\x00\x00\x00\x00\x00'
tRp114
sg46
g30
(g32
S'A`\xe5\xd0"[\x10@'
tRp115
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp116
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp117
sg51
S'GKQNHJ'
p118
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp119
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp120
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp121
sS'trials.thisIndex'
p122
g30
(g85
S'\x02\x00\x00\x00'
tRp123
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp124
sS'trials.thisRepN'
p125
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp126
sg16
F1453751975.3486879
sg29
g33
sS'trials.thisN'
p127
I2
sg50
g30
(g32
S'A`\xe5\xd0"[\x10@'
tRp128
sS'trials.thisTrialN'
p129
I2
sg54
g30
(g32
S'A`\xe5\xd0"[\x18@'
tRp130
sg17
Nsa(dp131
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp132
sg19
(lp133
F0.7181549072265625
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp134
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp135
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp136
sg16
F1453751981.4344089
sS'trials.thisN'
p137
I3
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp138
sg45
g30
(g70
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp139
sg46
g30
(g32
S'\x92\xed|?5\xde\x1b@'
tRp140
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp141
sg51
S'JDMHWQ'
p142
sg25
g26
sg53
S'xrtdgl'
p143
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp144
sS'trials.thisIndex'
p145
g30
(g85
S'\x03\x00\x00\x00'
tRp146
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp147
sS'trials.thisRepN'
p148
I0
sg50
g30
(g32
S'\x91\xed|?5\xde\x13@'
tRp149
sg27
g11
sS'trials.thisTrialN'
p150
I3
sg54
g30
(g32
S'\xc9v\xbe\x9f\x1a\xef+@'
tRp151
sg17
(lp152
S'7'
asa(dp153
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp154
sg45
g30
(g70
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp155
sg46
g30
(g32
S'\xcd\xcc\xcc\xcc\xccL\x10@'
tRp156
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp157
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp158
sg51
S'TJFXRG'
p159
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp160
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp161
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp162
sS'trials.thisIndex'
p163
g30
(g85
S'\x04\x00\x00\x00'
tRp164
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp165
sS'trials.thisRepN'
p166
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp167
sg16
F1453751995.4049611
sg29
g33
sS'trials.thisN'
p168
I4
sg50
g30
(g32
S'\xcd\xcc\xcc\xcc\xccL\x10@'
tRp169
sS'trials.thisTrialN'
p170
I4
sg54
g30
(g32
S'fffff&&@'
tRp171
sg17
Nsa(dp172
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp173
sg19
(lp174
F0.81705021858215332
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp175
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp176
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp177
sg16
F1453752006.475909
sS'trials.thisN'
p178
I5
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp179
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp180
sg46
g30
(g32
S'R\xb8\x1e\x85\xebQ\x18@'
tRp181
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp182
sg51
S'WKXGRJ'
p183
sg25
g26
sg53
S'nrbfth'
p184
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp185
sS'trials.thisIndex'
p186
g30
(g85
S'\x05\x00\x00\x00'
tRp187
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp188
sS'trials.thisRepN'
p189
I0
sg50
g30
(g32
S'R\xb8\x1e\x85\xebQ\x10@'
tRp190
sg27
g11
sS'trials.thisTrialN'
p191
I5
sg54
g30
(g32
S')\\\x8f\xc2\xf5(*@'
tRp192
sg17
(lp193
S'7'
asa(dp194
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp195
sg19
(lp196
F0.73445796966552734
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp197
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp198
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp199
sg16
F1453752019.547117
sS'trials.thisN'
p200
I6
sg43
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp201
sg45
g30
(g70
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp202
sg46
g30
(g32
S'\xee|?5^:\x18@'
tRp203
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp204
sg51
S'RYXTHJ'
p205
sg25
g26
sg53
S'mwnbyd'
p206
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp207
sS'trials.thisIndex'
p208
g30
(g85
S'\x06\x00\x00\x00'
tRp209
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp210
sS'trials.thisRepN'
p211
I0
sg50
g30
(g32
S'\xed|?5^:\x10@'
tRp212
sg27
g11
sS'trials.thisTrialN'
p213
I6
sg54
g30
(g32
S'w\xbe\x9f\x1a/\x1d*@'
tRp214
sg17
(lp215
S'7'
asa(dp216
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp217
sg45
g30
(g70
S'90\x00\x00\x00\x00\x00\x00'
tRp218
sg46
g30
(g32
S'J\x0c\x02+\x87\x16\x10@'
tRp219
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp220
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp221
sg51
S'DHTFLB'
p222
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp223
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp224
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp225
sS'trials.thisIndex'
p226
g30
(g85
S'\x07\x00\x00\x00'
tRp227
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp228
sS'trials.thisRepN'
p229
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp230
sg16
F1453752032.602051
sg29
g33
sS'trials.thisN'
p231
I7
sg50
g30
(g32
S'J\x0c\x02+\x87\x16\x10@'
tRp232
sS'trials.thisTrialN'
p233
I7
sg54
g30
(g32
S'%\x06\x81\x95C\x0b&@'
tRp234
sg17
Nsa(dp235
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp236
sg19
(lp237
F0.76749587059020996
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp238
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp239
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp240
sg16
F1453752043.6222889
sS'trials.thisN'
p241
I8
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp242
sg45
g30
(g70
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp243
sg46
g30
(g32
S'\x8cl\xe7\xfb\xa9\xf1\x19@'
tRp244
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp245
sg51
S'NFJTWY'
p246
sg25
g26
sg53
S'xmrbhg'
p247
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp248
sS'trials.thisIndex'
p249
g30
(g85
S'\x08\x00\x00\x00'
tRp250
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp251
sS'trials.thisRepN'
p252
I0
sg50
g30
(g32
S'\x8cl\xe7\xfb\xa9\xf1\x11@'
tRp253
sg27
g11
sS'trials.thisTrialN'
p254
I8
sg54
g30
(g32
S'E\xb6\xf3\xfd\xd4\xf8*@'
tRp255
sg17
(lp256
S'8'
asa(dp257
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp258
sg45
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp259
sg46
g30
(g32
S'c\x10X9\xb4\xc8\x12@'
tRp260
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp261
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp262
sg51
S'YNXJRW'
p263
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp264
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp265
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp266
sS'trials.thisIndex'
p267
g30
(g85
S'\t\x00\x00\x00'
tRp268
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp269
sS'trials.thisRepN'
p270
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp271
sg16
F1453752057.1107731
sg29
g33
sS'trials.thisN'
p272
I9
sg50
g30
(g32
S'c\x10X9\xb4\xc8\x12@'
tRp273
sS'trials.thisTrialN'
p274
I9
sg54
g30
(g32
S"1\x08\xac\x1cZd'@"
tRp275
sg17
Nsa(dp276
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp277
sg45
g30
(g70
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp278
sg46
g30
(g32
S'j\xbct\x93\x18\x04\x10@'
tRp279
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp280
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp281
sg51
S'NQYXLJ'
p282
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp283
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp284
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp285
sS'trials.thisIndex'
p286
g30
(g85
S'\n\x00\x00\x00'
tRp287
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp288
sS'trials.thisRepN'
p289
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp290
sg16
F1453752068.7983999
sg29
g33
sS'trials.thisN'
p291
I10
sg50
g30
(g32
S'j\xbct\x93\x18\x04\x10@'
tRp292
sS'trials.thisTrialN'
p293
I10
sg54
g30
(g32
S'j\xbct\x93\x18\x04\x18@'
tRp294
sg17
Nsa(dp295
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp296
sg19
(lp297
F1.1848759651184082
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp298
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp299
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp300
sg16
F1453752074.800878
sS'trials.thisN'
p301
I11
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp302
sg45
g30
(g70
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp303
sg46
g30
(g32
S'\xb6\xf3\xfd\xd4xi\x18@'
tRp304
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp305
sg51
S'MHFLXR'
p306
sg25
g26
sg53
S'jkdtnf'
p307
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp308
sS'trials.thisIndex'
p309
g30
(g85
S'\x0b\x00\x00\x00'
tRp310
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp311
sS'trials.thisRepN'
p312
I0
sg50
g30
(g32
S'\xb6\xf3\xfd\xd4xi\x10@'
tRp313
sg27
g11
sS'trials.thisTrialN'
p314
I11
sg54
g30
(g32
S'\xdb\xf9~j\xbc4 @'
tRp315
sg17
(lp316
S'7'
asa(dp317
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp318
sg19
(lp319
F1.2350101470947266
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp320
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp321
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp322
sg16
F1453752082.9040511
sS'trials.thisN'
p323
I12
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp324
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp325
sg46
g30
(g32
S'\x9a\x99\x99\x99\x99\x99\x1a@'
tRp326
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp327
sg51
S'HGDJQF'
p328
sg25
g26
sg53
S'bqlxwr'
p329
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp330
sS'trials.thisIndex'
p331
g30
(g85
S'\x0c\x00\x00\x00'
tRp332
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp333
sS'trials.thisRepN'
p334
I0
sg50
g30
(g32
S'\x9a\x99\x99\x99\x99\x99\x12@'
tRp335
sg27
g11
sS'trials.thisTrialN'
p336
I12
sg54
g30
(g32
S'\xcd\xcc\xcc\xcc\xccL!@'
tRp337
sg17
(lp338
S'7'
asa(dp339
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp340
sg19
(lp341
F0.83374500274658203
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp342
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp343
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp344
sg16
F1453752091.5576949
sS'trials.thisN'
p345
I13
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp346
sg45
g30
(g70
S'\x0c\x00\x00\x00\x00\x00\x00\x00'
tRp347
sg46
g30
(g32
S'\xe5\xd0"\xdb\xf9\xfe\x19@'
tRp348
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp349
sg51
S'BKGRHD'
p350
sg25
g26
sg53
S'njqxfy'
p351
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp352
sS'trials.thisIndex'
p353
g30
(g85
S'\r\x00\x00\x00'
tRp354
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp355
sS'trials.thisRepN'
p356
I0
sg50
g30
(g32
S'\xe5\xd0"\xdb\xf9\xfe\x11@'
tRp357
sg27
g11
sS'trials.thisTrialN'
p358
I13
sg54
g30
(g32
S'sh\x91\xed|\xff*@'
tRp359
sg17
(lp360
S'8'
asa(dp361
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp362
sg19
(lp363
F0.96790289878845215
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp364
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp365
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp366
sg16
F1453752105.0611119
sS'trials.thisN'
p367
I14
sg43
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp368
sg45
g30
(g70
S')\t\x00\x00\x00\x00\x00\x00'
tRp369
sg46
g30
(g32
S'\xa8\xc6K7\x89A\x19@'
tRp370
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp371
sg51
S'XKGNRJ'
p372
sg25
g26
sg53
S'lytmqh'
p373
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp374
sS'trials.thisIndex'
p375
g30
(g85
S'\x0e\x00\x00\x00'
tRp376
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp377
sS'trials.thisRepN'
p378
I0
sg50
g30
(g32
S'\xa8\xc6K7\x89A\x11@'
tRp379
sg27
g11
sS'trials.thisTrialN'
p380
I14
sg54
g30
(g32
S'T\xe3\xa5\x9b\xc4\xa0*@'
tRp381
sg17
(lp382
S'8'
asa(dp383
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp384
sg19
(lp385
F0.7674410343170166
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp386
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp387
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp388
sg16
F1453752118.3659661
sS'trials.thisN'
p389
I15
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp390
sg45
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp391
sg46
g30
(g32
S'D\x8bl\xe7\xfb\xa9\x18@'
tRp392
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp393
sg51
S'LNRXJH'
p394
sg25
g26
sg53
S'kgdyfm'
p395
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp396
sS'trials.thisIndex'
p397
g30
(g85
S'\x0f\x00\x00\x00'
tRp398
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp399
sS'trials.thisRepN'
p400
I0
sg50
g30
(g32
S'D\x8bl\xe7\xfb\xa9\x10@'
tRp401
sg27
g11
sS'trials.thisTrialN'
p402
I15
sg54
g30
(g32
S'\xa2E\xb6\xf3\xfdT @'
tRp403
sg17
(lp404
S'8'
asa(dp405
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp406
sg19
(lp407
F0.83364105224609375
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp408
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp409
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp410
sg16
F1453752126.535851
sS'trials.thisN'
p411
I16
sg43
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp412
sg45
g30
(g70
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp413
sg46
g30
(g32
S'E\xb6\xf3\xfd\xd4x\x1c@'
tRp414
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp415
sg51
S'MDJHWK'
p416
sg25
g26
sg53
S'btfgkr'
p417
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp418
sS'trials.thisIndex'
p419
g30
(g85
S'\x10\x00\x00\x00'
tRp420
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp421
sS'trials.thisRepN'
p422
I0
sg50
g30
(g32
S'F\xb6\xf3\xfd\xd4x\x14@'
tRp423
sg27
g11
sS'trials.thisTrialN'
p424
I16
sg54
g30
(g32
S'#\xdb\xf9~j<"@'
tRp425
sg17
(lp426
S'7'
asa(dp427
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp428
sg19
(lp429
F0.73447918891906738
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp430
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp431
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp432
sg16
F1453752135.6553681
sS'trials.thisN'
p433
I17
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp434
sg45
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp435
sg46
g30
(g32
S'Nb\x10X94\x18@'
tRp436
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp437
sg51
S'MWLDYH'
p438
sg25
g26
sg53
S'nkjfgr'
p439
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp440
sS'trials.thisIndex'
p441
g30
(g85
S'\x11\x00\x00\x00'
tRp442
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp443
sS'trials.thisRepN'
p444
I0
sg50
g30
(g32
S'Nb\x10X94\x10@'
tRp445
sg27
g11
sS'trials.thisTrialN'
p446
I17
sg54
g30
(g32
S'&1\x08\xac\x1c\x1a*@'
tRp447
sg17
(lp448
S'8'
asa(dp449
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp450
sg19
(lp451
F0.78433489799499512
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp452
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp453
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp454
sg16
F1453752148.7097189
sS'trials.thisN'
p455
I18
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp456
sg45
g30
(g70
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp457
sg46
g30
(g32
S'\x08\xac\x1cZd;\x18@'
tRp458
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp459
sg51
S'TXJGDQ'
p460
sg25
g26
sg53
S'ryfbmw'
p461
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp462
sS'trials.thisIndex'
p463
g30
(g85
S'\x12\x00\x00\x00'
tRp464
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp465
sS'trials.thisRepN'
p466
I0
sg50
g30
(g32
S'\x08\xac\x1cZd;\x10@'
tRp467
sg27
g11
sS'trials.thisTrialN'
p468
I18
sg54
g30
(g32
S'\x04V\x0e-\xb2\x1d @'
tRp469
sg17
(lp470
S'8'
asa(dp471
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp472
sg19
(lp473
F0.70101189613342285
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp474
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp475
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp476
sg16
F1453752156.7630761
sS'trials.thisN'
p477
I19
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp478
sg45
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp479
sg46
g30
(g32
S'\xda\xce\xf7S\xe3\xa5\x18@'
tRp480
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp481
sg51
S'FQHLYT'
p482
sg25
g26
sg53
S'xrjdkn'
p483
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp484
sS'trials.thisIndex'
p485
g30
(g85
S'\x13\x00\x00\x00'
tRp486
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp487
sS'trials.thisRepN'
p488
I0
sg50
g30
(g32
S'\xd9\xce\xf7S\xe3\xa5\x10@'
tRp489
sg27
g11
sS'trials.thisTrialN'
p490
I19
sg54
g30
(g32
S'm\xe7\xfb\xa9\xf1R*@'
tRp491
sg17
(lp492
S'8'
asa(dp493
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp494
sg19
(lp495
F0.78497481346130371
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp496
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp497
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp498
sg16
F1453752169.918344
sS'trials.thisN'
p499
I20
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp500
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp501
sg46
g30
(g32
S'7\x89A`\xe5P\x18@'
tRp502
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp503
sg51
S'YRBWLK'
p504
sg25
g26
sg53
S'mfnhdq'
p505
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp506
sS'trials.thisIndex'
p507
g30
(g85
S'\x14\x00\x00\x00'
tRp508
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp509
sS'trials.thisRepN'
p510
I0
sg50
g30
(g32
S'7\x89A`\xe5P\x10@'
tRp511
sg27
g11
sS'trials.thisTrialN'
p512
I20
sg54
g30
(g32
S'\x9c\xc4 \xb0r( @'
tRp513
sg17
(lp514
S'8'
asa(dp515
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp516
sg45
g30
(g70
S')\t\x00\x00\x00\x00\x00\x00'
tRp517
sg46
g30
(g32
S'`\xe5\xd0"\xdb\xf9\x11@'
tRp518
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp519
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp520
sg51
S'NWLGFK'
p521
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp522
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp523
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp524
sS'trials.thisIndex'
p525
g30
(g85
S'\x15\x00\x00\x00'
tRp526
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp527
sS'trials.thisRepN'
p528
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp529
sg16
F1453752177.9881721
sg29
g33
sS'trials.thisN'
p530
I21
sg50
g30
(g32
S'`\xe5\xd0"\xdb\xf9\x11@'
tRp531
sS'trials.thisTrialN'
p532
I21
sg54
g30
(g32
S'\xb1rh\x91\xed\xfc&@'
tRp533
sg17
Nsa(dp534
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp535
sg19
(lp536
F1.2182629108428955
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp537
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp538
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp539
sg16
F1453752189.4759359
sS'trials.thisN'
p540
I22
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp541
sg45
g30
(g70
S'90\x00\x00\x00\x00\x00\x00'
tRp542
sg46
g30
(g32
S'\xa8\xc6K7\x89A\x18@'
tRp543
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp544
sg51
S'GYKWTB'
p545
sg25
g26
sg53
S'ldxqnf'
p546
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp547
sS'trials.thisIndex'
p548
g30
(g85
S'\x16\x00\x00\x00'
tRp549
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp550
sS'trials.thisRepN'
p551
I0
sg50
g30
(g32
S'\xa8\xc6K7\x89A\x10@'
tRp552
sg27
g11
sS'trials.thisTrialN'
p553
I22
sg54
g30
(g32
S'T\xe3\xa5\x9b\xc4  @'
tRp554
sg17
(lp555
S'8'
asa(dp556
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp557
sg19
(lp558
F0.75125789642333984
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp559
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp560
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp561
sg16
F1453752197.5456729
sS'trials.thisN'
p562
I23
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp563
sg45
g30
(g70
S'90\x00\x00\x00\x00\x00\x00'
tRp564
sg46
g30
(g32
S'\x1cZd;\xdf\xcf\x18@'
tRp565
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp566
sg51
S'HWRQXK'
p567
sg25
g26
sg53
S'fydbng'
p568
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp569
sS'trials.thisIndex'
p570
g30
(g85
S'\x17\x00\x00\x00'
tRp571
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp572
sS'trials.thisRepN'
p573
I0
sg50
g30
(g32
S'\x1dZd;\xdf\xcf\x10@'
tRp574
sg27
g11
sS'trials.thisTrialN'
p575
I23
sg54
g30
(g32
S'\x0e-\xb2\x9d\xefg*@'
tRp576
sg17
(lp577
S'8'
asa(dp578
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp579
sg45
g30
(g70
S')\t\x00\x00\x00\x00\x00\x00'
tRp580
sg46
g30
(g32
S'\x04V\x0e-\xb2\x1d\x11@'
tRp581
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp582
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp583
sg51
S'RTDFBG'
p584
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp585
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp586
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp587
sS'trials.thisIndex'
p588
g30
(g85
S'\x18\x00\x00\x00'
tRp589
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp590
sS'trials.thisRepN'
p591
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp592
sg16
F1453752210.749027
sg29
g33
sS'trials.thisN'
p593
I24
sg50
g30
(g32
S'\x04V\x0e-\xb2\x1d\x11@'
tRp594
sS'trials.thisTrialN'
p595
I24
sg54
g30
(g32
S'\x04V\x0e-\xb2\x1d\x19@'
tRp596
sg17
Nsa(dp597
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp598
sg45
g30
(g70
S'90\x00\x00\x00\x00\x00\x00'
tRp599
sg46
g30
(g32
S'T\xe3\xa5\x9b\xc4 \x10@'
tRp600
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp601
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp602
sg51
S'QJXNDK'
p603
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp604
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp605
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp606
sS'trials.thisIndex'
p607
g30
(g85
S'\x19\x00\x00\x00'
tRp608
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp609
sS'trials.thisRepN'
p610
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp611
sg16
F1453752217.0175221
sg29
g33
sS'trials.thisN'
p612
I25
sg50
g30
(g32
S'T\xe3\xa5\x9b\xc4 \x10@'
tRp613
sS'trials.thisTrialN'
p614
I25
sg54
g30
(g32
S'T\xe3\xa5\x9b\xc4 \x18@'
tRp615
sg17
Nsa(dp616
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp617
sg45
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp618
sg46
g30
(g32
S'{\x14\xaeG\xe1\xfa\x10@'
tRp619
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp620
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp621
sg51
S'RDXLBF'
p622
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp623
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp624
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp625
sS'trials.thisIndex'
p626
g30
(g85
S'\x1a\x00\x00\x00'
tRp627
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp628
sS'trials.thisRepN'
p629
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp630
sg16
F1453752223.052886
sg29
g33
sS'trials.thisN'
p631
I26
sg50
g30
(g32
S'{\x14\xaeG\xe1\xfa\x10@'
tRp632
sS'trials.thisTrialN'
p633
I26
sg54
g30
(g32
S'{\x14\xaeG\xe1\xfa\x18@'
tRp634
sg17
Nsa(dp635
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp636
sg19
(lp637
F0.91802000999450684
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp638
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp639
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp640
sg16
F1453752229.2890511
sS'trials.thisN'
p641
I27
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp642
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp643
sg46
g30
(g32
S'j\xbct\x93\x18\x04\x18@'
tRp644
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp645
sg51
S'YDFHTM'
p646
sg25
g26
sg53
S'wrqxbg'
p647
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp648
sS'trials.thisIndex'
p649
g30
(g85
S'\x1b\x00\x00\x00'
tRp650
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp651
sS'trials.thisRepN'
p652
I0
sg50
g30
(g32
S'j\xbct\x93\x18\x04\x10@'
tRp653
sg27
g11
sS'trials.thisTrialN'
p654
I27
sg54
g30
(g32
S'6^\xbaI\x0c\x02*@'
tRp655
sg17
(lp656
S'8'
asa(dp657
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp658
sg19
(lp659
F0.81775379180908203
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp660
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp661
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp662
sg16
F1453752242.2936211
sS'trials.thisN'
p663
I28
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp664
sg45
g30
(g70
S')\t\x00\x00\x00\x00\x00\x00'
tRp665
sg46
g30
(g32
S'\\\x8f\xc2\xf5(\\\x18@'
tRp666
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp667
sg51
S'DMYNBQ'
p668
sg25
g26
sg53
S'jfrhtl'
p669
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp670
sS'trials.thisIndex'
p671
g30
(g85
S'\x1c\x00\x00\x00'
tRp672
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp673
sS'trials.thisRepN'
p674
I0
sg50
g30
(g32
S'\\\x8f\xc2\xf5(\\\x10@'
tRp675
sg27
g11
sS'trials.thisTrialN'
p676
I28
sg54
g30
(g32
S'\xaeG\xe1z\x14. @'
tRp677
sg17
(lp678
S'8'
asa(dp679
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp680
sg19
(lp681
F0.80124115943908691
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp682
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp683
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp684
sg16
F1453752250.3800299
sS'trials.thisN'
p685
I29
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp686
sg45
g30
(g70
S'\x0c\x00\x00\x00\x00\x00\x00\x00'
tRp687
sg46
g30
(g32
S'\xc5 \xb0rh\x11\x18@'
tRp688
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp689
sg51
S'FTHKMG'
p690
sg25
g26
sg53
S'jqwxrb'
p691
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp692
sS'trials.thisIndex'
p693
g30
(g85
S'\x1d\x00\x00\x00'
tRp694
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp695
sS'trials.thisRepN'
p696
I0
sg50
g30
(g32
S'\xc4 \xb0rh\x11\x10@'
tRp697
sg27
g11
sS'trials.thisTrialN'
p698
I29
sg54
g30
(g32
S'c\x10X9\xb4\x08*@'
tRp699
sg17
(lp700
S'8'
asa(dp701
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp702
sg19
(lp703
F0.61796188354492188
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp704
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp705
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp706
sg16
F1453752263.401139
sS'trials.thisN'
p707
I30
sg43
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp708
sg45
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp709
sg46
g30
(g32
S'\xb6\xf3\xfd\xd4xi\x19@'
tRp710
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp711
sg51
S'NJRKLB'
p712
sg25
g26
sg53
S'hdgqkm'
p713
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp714
sS'trials.thisIndex'
p715
g30
(g85
S'\x1e\x00\x00\x00'
tRp716
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp717
sS'trials.thisRepN'
p718
I0
sg50
g30
(g32
S'\xb6\xf3\xfd\xd4xi\x11@'
tRp719
sg27
g11
sS'trials.thisTrialN'
p720
I30
sg54
g30
(g32
S'\xdb\xf9~j\xbc\xb4*@'
tRp721
sg17
(lp722
S'7'
asa(dp723
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp724
sg19
(lp725
F0.88454604148864746
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp726
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp727
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp728
sg16
F1453752276.7571321
sS'trials.thisN'
p729
I31
sg43
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp730
sg45
g30
(g70
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp731
sg46
g30
(g32
S'j\xbct\x93\x18\x04\x18@'
tRp732
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp733
sg51
S'FKMLQB'
p734
sg25
g26
sg53
S'jdwnqr'
p735
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp736
sS'trials.thisIndex'
p737
g30
(g85
S'\x1f\x00\x00\x00'
tRp738
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp739
sS'trials.thisRepN'
p740
I0
sg50
g30
(g32
S'j\xbct\x93\x18\x04\x10@'
tRp741
sg27
g11
sS'trials.thisTrialN'
p742
I31
sg54
g30
(g32
S'6^\xbaI\x0c\x02*@'
tRp743
sg17
(lp744
S'7'
asa(dp745
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp746
sg19
(lp747
F0.83372592926025391
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp748
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp749
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp750
sg16
F1453752289.7616651
sS'trials.thisN'
p751
I32
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp752
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp753
sg46
g30
(g32
S'D\x8bl\xe7\xfb\xa9\x18@'
tRp754
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp755
sg51
S'NTWHYG'
p756
sg25
g26
sg53
S'qdrbjk'
p757
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp758
sS'trials.thisIndex'
p759
g30
(g85
S' \x00\x00\x00'
tRp760
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp761
sS'trials.thisRepN'
p762
I0
sg50
g30
(g32
S'D\x8bl\xe7\xfb\xa9\x10@'
tRp763
sg27
g11
sS'trials.thisTrialN'
p764
I32
sg54
g30
(g32
S'\xa1E\xb6\xf3\xfdT*@'
tRp765
sg17
(lp766
S'8'
asa(dp767
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp768
sg19
(lp769
F0.95124912261962891
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp770
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp771
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp772
sg16
F1453752302.933244
sS'trials.thisN'
p773
I33
sg43
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp774
sg45
g30
(g70
S')\t\x00\x00\x00\x00\x00\x00'
tRp775
sg46
g30
(g32
S'\x93\x18\x04V\x0e-\x19@'
tRp776
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp777
sg51
S'BQDTJX'
p778
sg25
g26
sg53
S'mrkhdw'
p779
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp780
sS'trials.thisIndex'
p781
g30
(g85
S'!\x00\x00\x00'
tRp782
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp783
sS'trials.thisRepN'
p784
I0
sg50
g30
(g32
S'\x93\x18\x04V\x0e-\x11@'
tRp785
sg27
g11
sS'trials.thisTrialN'
p786
I33
sg54
g30
(g32
S'J\x0c\x02+\x87\x96 @'
tRp787
sg17
(lp788
S'7'
asa(dp789
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp790
sg45
g30
(g70
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp791
sg46
g30
(g32
S'\x8cl\xe7\xfb\xa9q\x11@'
tRp792
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp793
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp794
sg51
S'HNLYGQ'
p795
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp796
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp797
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp798
sS'trials.thisIndex'
p799
g30
(g85
S'"\x00\x00\x00'
tRp800
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp801
sS'trials.thisRepN'
p802
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp803
sg16
F1453752311.218821
sg29
g33
sS'trials.thisN'
p804
I34
sg50
g30
(g32
S'\x8cl\xe7\xfb\xa9q\x11@'
tRp805
sS'trials.thisTrialN'
p806
I34
sg54
g30
(g32
S'E\xb6\xf3\xfd\xd4\xb8&@'
tRp807
sg17
Nsa(dp808
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp809
sg45
g30
(g70
S'"\x00\x00\x00\x00\x00\x00\x00'
tRp810
sg46
g30
(g32
S'\xb0rh\x91\xed\xfc\x10@'
tRp811
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp812
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp813
sg51
S'GTQJKD'
p814
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp815
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp816
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp817
sS'trials.thisIndex'
p818
g30
(g85
S'#\x00\x00\x00'
tRp819
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp820
sS'trials.thisRepN'
p821
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp822
sg16
F1453752322.5727761
sg29
g33
sS'trials.thisN'
p823
I35
sg50
g30
(g32
S'\xb0rh\x91\xed\xfc\x10@'
tRp824
sS'trials.thisTrialN'
p825
I35
sg54
g30
(g32
S'X9\xb4\xc8v~&@'
tRp826
sg17
Nsa(dp827
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp828
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp829
sg46
g30
(g32
S'\x83\xc0\xca\xa1E\xb6\x11@'
tRp830
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp831
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp832
sg51
S'DHLTQN'
p833
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp834
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp835
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp836
sS'trials.thisIndex'
p837
g30
(g85
S'$\x00\x00\x00'
tRp838
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp839
sS'trials.thisRepN'
p840
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp841
sg16
F1453752333.809993
sg29
g33
sS'trials.thisN'
p842
I36
sg50
g30
(g32
S'\x83\xc0\xca\xa1E\xb6\x11@'
tRp843
sS'trials.thisTrialN'
p844
I36
sg54
g30
(g32
S'A`\xe5\xd0"\xdb&@'
tRp845
sg17
Nsa(dp846
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp847
sg19
(lp848
F0.83406519889831543
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp849
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp850
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp851
sg16
F1453752345.2309389
sS'trials.thisN'
p852
I37
sg43
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp853
sg45
g30
(g70
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp854
sg46
g30
(g32
S'\xca\xa1E\xb6\xf3\xfd\x1a@'
tRp855
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp856
sg51
S'MDHTBK'
p857
sg25
g26
sg53
S'lnrjbq'
p858
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp859
sS'trials.thisIndex'
p860
g30
(g85
S'%\x00\x00\x00'
tRp861
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp862
sS'trials.thisRepN'
p863
I0
sg50
g30
(g32
S'\xcb\xa1E\xb6\xf3\xfd\x12@'
tRp864
sg27
g11
sS'trials.thisTrialN'
p865
I37
sg54
g30
(g32
S'\xe5\xd0"\xdb\xf9~+@'
tRp866
sg17
(lp867
S'7'
asa(dp868
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp869
sg45
g30
(g70
S')\t\x00\x00\x00\x00\x00\x00'
tRp870
sg46
g30
(g32
S'\xc1\xca\xa1E\xb6s\x13@'
tRp871
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp872
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp873
sg51
S'KJQWFN'
p874
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp875
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp876
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp877
sS'trials.thisIndex'
p878
g30
(g85
S'&\x00\x00\x00'
tRp879
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp880
sS'trials.thisRepN'
p881
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp882
sg16
F1453752358.968847
sg29
g33
sS'trials.thisN'
p883
I38
sg50
g30
(g32
S'\xc1\xca\xa1E\xb6s\x13@'
tRp884
sS'trials.thisTrialN'
p885
I38
sg54
g30
(g32
S'\xc0\xca\xa1E\xb6s\x1b@'
tRp886
sg17
Nsa(dp887
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp888
sg19
(lp889
F1.1505091190338135
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp890
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp891
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp892
sg16
F1453752365.8215411
sS'trials.thisN'
p893
I39
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp894
sg45
g30
(g70
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp895
sg46
g30
(g32
S'\xcd\xcc\xcc\xcc\xcc\xcc\x1a@'
tRp896
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp897
sg51
S'GDHQYL'
p898
sg25
g26
sg53
S'xfkbmr'
p899
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp900
sS'trials.thisIndex'
p901
g30
(g85
S"'\x00\x00\x00"
tRp902
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp903
sS'trials.thisRepN'
p904
I0
sg50
g30
(g32
S'\xcd\xcc\xcc\xcc\xcc\xcc\x12@'
tRp905
sg27
g11
sS'trials.thisTrialN'
p906
I39
sg54
g30
(g32
S'ffffff!@'
tRp907
sg17
(lp908
S'8'
asa(dp909
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp910
sg45
g30
(g70
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp911
sg46
g30
(g32
S'\x11X9\xb4\xc8v\x10@'
tRp912
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp913
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp914
sg51
S'DKWJGL'
p915
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp916
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp917
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp918
sS'trials.thisIndex'
p919
g30
(g85
S'(\x00\x00\x00'
tRp920
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp921
sS'trials.thisRepN'
p922
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp923
sg16
F1453752374.525048
sg29
g33
sS'trials.thisN'
p924
I40
sg50
g30
(g32
S'\x11X9\xb4\xc8v\x10@'
tRp925
sS'trials.thisTrialN'
p926
I40
sg54
g30
(g32
S'\x08\xac\x1cZd;&@'
tRp927
sg17
Nsa(dp928
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp929
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp930
sg46
g30
(g32
S'F\xb6\xf3\xfd\xd4\xf8\x12@'
tRp931
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp932
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp933
sg51
S'RWYKXJ'
p934
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp935
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp936
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp937
sS'trials.thisIndex'
p938
g30
(g85
S')\x00\x00\x00'
tRp939
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp940
sS'trials.thisRepN'
p941
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp942
sg16
F1453752385.645653
sg29
g33
sS'trials.thisN'
p943
I41
sg50
g30
(g32
S'F\xb6\xf3\xfd\xd4\xf8\x12@'
tRp944
sS'trials.thisTrialN'
p945
I41
sg54
g30
(g32
S"#\xdb\xf9~j|'@"
tRp946
sg17
Nsa(dp947
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp948
sg19
(lp949
F0.73408913612365723
aF1.4516170024871826
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp950
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp951
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp952
sg16
F1453752397.3839979
sS'trials.thisN'
p953
I42
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp954
sg45
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp955
sg46
g30
(g32
S'%\x06\x81\x95C\x0b\x18@'
tRp956
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp957
sg51
S'QBXNRY'
p958
sg25
g26
sg53
S'lnkmdt'
p959
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp960
sS'trials.thisIndex'
p961
g30
(g85
S'*\x00\x00\x00'
tRp962
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp963
sS'trials.thisRepN'
p964
I0
sg50
g30
(g32
S'%\x06\x81\x95C\x0b\x10@'
tRp965
sg27
g11
sS'trials.thisTrialN'
p966
I42
sg54
g30
(g32
S'\x12\x83\xc0\xca\xa1\x05*@'
tRp967
sg17
(lp968
S'8'
aS'7'
asa(dp969
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp970
sg19
(lp971
F1.1341359615325928
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp972
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp973
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp974
sg16
F1453752410.3876121
sS'trials.thisN'
p975
I43
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp976
sg45
g30
(g70
S'8\x00\x00\x00\x00\x00\x00\x00'
tRp977
sg46
g30
(g32
S'R\xb8\x1e\x85\xeb\xd1\x18@'
tRp978
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp979
sg51
S'BHNXFR'
p980
sg25
g26
sg53
S'qlkrtg'
p981
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp982
sS'trials.thisIndex'
p983
g30
(g85
S'+\x00\x00\x00'
tRp984
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp985
sS'trials.thisRepN'
p986
I0
sg50
g30
(g32
S'R\xb8\x1e\x85\xeb\xd1\x10@'
tRp987
sg27
g11
sS'trials.thisTrialN'
p988
I43
sg54
g30
(g32
S')\\\x8f\xc2\xf5h @'
tRp989
sg17
(lp990
S'7'
asa(dp991
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp992
sg45
g30
(g70
S'\x0c\x00\x00\x00\x00\x00\x00\x00'
tRp993
sg46
g30
(g32
S'\x9a\x99\x99\x99\x99\x19\x10@'
tRp994
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp995
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp996
sg51
S'HLRYMN'
p997
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp998
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp999
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1000
sS'trials.thisIndex'
p1001
g30
(g85
S',\x00\x00\x00'
tRp1002
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1003
sS'trials.thisRepN'
p1004
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1005
sg16
F1453752418.5906191
sg29
g33
sS'trials.thisN'
p1006
I44
sg50
g30
(g32
S'\x9a\x99\x99\x99\x99\x19\x10@'
tRp1007
sS'trials.thisTrialN'
p1008
I44
sg54
g30
(g32
S'\x9a\x99\x99\x99\x99\x19\x18@'
tRp1009
sg17
Nsa(dp1010
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1011
sg19
(lp1012
F0.98436808586120605
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1013
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1014
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1015
sg16
F1453752424.609318
sS'trials.thisN'
p1016
I45
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1017
sg45
g30
(g70
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp1018
sg46
g30
(g32
S'ffffff\x18@'
tRp1019
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1020
sg51
S'MKWYLR'
p1021
sg25
g26
sg53
S'ghnjqx'
p1022
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1023
sS'trials.thisIndex'
p1024
g30
(g85
S'-\x00\x00\x00'
tRp1025
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1026
sS'trials.thisRepN'
p1027
I0
sg50
g30
(g32
S'ffffff\x10@'
tRp1028
sg27
g11
sS'trials.thisTrialN'
p1029
I45
sg54
g30
(g32
S'333333*@'
tRp1030
sg17
(lp1031
S'8'
asa(dp1032
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1033
sg45
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1034
sg46
g30
(g32
S'\xd1"\xdb\xf9~\xea\x12@'
tRp1035
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1036
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1037
sg51
S'RBXYTL'
p1038
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1039
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1040
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1041
sS'trials.thisIndex'
p1042
g30
(g85
S'.\x00\x00\x00'
tRp1043
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1044
sS'trials.thisRepN'
p1045
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1046
sg16
F1453752437.713999
sg29
g33
sS'trials.thisN'
p1047
I46
sg50
g30
(g32
S'\xd1"\xdb\xf9~\xea\x12@'
tRp1048
sS'trials.thisTrialN'
p1049
I46
sg54
g30
(g32
S"i\x91\xed|?u'@"
tRp1050
sg17
Nsa(dp1051
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1052
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1053
sg46
g30
(g32
S'\x02+\x87\x16\xd9N\x10@'
tRp1054
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1055
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1056
sg51
S'QBMKWD'
p1057
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1058
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1059
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1060
sS'trials.thisIndex'
p1061
g30
(g85
S'/\x00\x00\x00'
tRp1062
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1063
sS'trials.thisRepN'
p1064
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1065
sg16
F1453752449.4350679
sg29
g33
sS'trials.thisN'
p1066
I47
sg50
g30
(g32
S'\x02+\x87\x16\xd9N\x10@'
tRp1067
sS'trials.thisTrialN'
p1068
I47
sg54
g30
(g32
S'\x03+\x87\x16\xd9N\x18@'
tRp1069
sg17
Nsa(dp1070
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1071
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1072
sg46
g30
(g32
S'\xb2\x9d\xef\xa7\xc6\xcb\x11@'
tRp1073
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1074
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1075
sg51
S'MYQJWH'
p1076
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1077
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1078
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1079
sS'trials.thisIndex'
p1080
g30
(g85
S'0\x00\x00\x00'
tRp1081
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1082
sS'trials.thisRepN'
p1083
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1084
sg16
F1453752455.503531
sg29
g33
sS'trials.thisN'
p1085
I48
sg50
g30
(g32
S'\xb2\x9d\xef\xa7\xc6\xcb\x11@'
tRp1086
sS'trials.thisTrialN'
p1087
I48
sg54
g30
(g32
S'\xb2\x9d\xef\xa7\xc6\xcb\x19@'
tRp1088
sg17
Nsa(dp1089
g23
g24
sg29
g33
sg49
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1090
sg19
(lp1091
F0.80115604400634766
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1092
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1093
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1094
sg16
F1453752461.95609
sS'trials.thisN'
p1095
I49
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1096
sg45
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1097
sg46
g30
(g32
S'\xaeG\xe1z\x14\xae\x1b@'
tRp1098
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1099
sg51
S'JKDHQN'
p1100
sg25
g26
sg53
S'gbxdtm'
p1101
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1102
sS'trials.thisIndex'
p1103
g30
(g85
S'1\x00\x00\x00'
tRp1104
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1105
sS'trials.thisRepN'
p1106
I0
sg50
g30
(g32
S'\xaeG\xe1z\x14\xae\x13@'
tRp1107
sg27
g11
sS'trials.thisTrialN'
p1108
I49
sg54
g30
(g32
S'\xd7\xa3p=\n\xd7!@'
tRp1109
sg17
(lp1110
S'7'
asa(dp1111
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1112
sg19
(lp1113
F1.0846819877624512
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1114
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1115
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1116
sg16
F1453752470.8761129
sS'trials.thisN'
p1117
I50
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1118
sg45
g30
(g70
S')\t\x00\x00\x00\x00\x00\x00'
tRp1119
sg46
g30
(g32
S'\x83\xc0\xca\xa1E6\x18@'
tRp1120
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1121
sg51
S'DTQJWX'
p1122
sg25
g26
sg53
S'fhqlrm'
p1123
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1124
sS'trials.thisIndex'
p1125
g30
(g85
S'2\x00\x00\x00'
tRp1126
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1127
sS'trials.thisRepN'
p1128
I0
sg50
g30
(g32
S'\x83\xc0\xca\xa1E6\x10@'
tRp1129
sg27
g11
sS'trials.thisTrialN'
p1130
I50
sg54
g30
(g32
S'A`\xe5\xd0"\x1b*@'
tRp1131
sg17
(lp1132
S'8'
asa(dp1133
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1134
sg19
(lp1135
F0.95095086097717285
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1136
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1137
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1138
sg16
F1453752483.9314139
sS'trials.thisN'
p1139
I51
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1140
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1141
sg46
g30
(g32
S'\xf6(\\\x8f\xc2u\x19@'
tRp1142
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1143
sg51
S'NQWRGT'
p1144
sg25
g26
sg53
S'lmjhky'
p1145
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1146
sS'trials.thisIndex'
p1147
g30
(g85
S'3\x00\x00\x00'
tRp1148
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1149
sS'trials.thisRepN'
p1150
I0
sg50
g30
(g32
S'\xf6(\\\x8f\xc2u\x11@'
tRp1151
sg27
g11
sS'trials.thisTrialN'
p1152
I51
sg54
g30
(g32
S'{\x14\xaeG\xe1\xba*@'
tRp1153
sg17
(lp1154
S'8'
asa(dp1155
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1156
sg45
g30
(g70
S'8\x00\x00\x00\x00\x00\x00\x00'
tRp1157
sg46
g30
(g32
S'\xb0rh\x91\xed|\x10@'
tRp1158
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1159
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1160
sg51
S'KLMWHB'
p1161
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1162
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1163
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1164
sS'trials.thisIndex'
p1165
g30
(g85
S'4\x00\x00\x00'
tRp1166
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1167
sS'trials.thisRepN'
p1168
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1169
sg16
F1453752497.2863181
sg29
g33
sS'trials.thisN'
p1170
I52
sg50
g30
(g32
S'\xb0rh\x91\xed|\x10@'
tRp1171
sS'trials.thisTrialN'
p1172
I52
sg54
g30
(g32
S'X9\xb4\xc8v>&@'
tRp1173
sg17
Nsa(dp1174
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1175
sg19
(lp1176
F0.88498401641845703
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1177
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1178
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1179
sg16
F1453752508.407187
sS'trials.thisN'
p1180
I53
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1181
sg45
g30
(g70
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1182
sg46
g30
(g32
S'\x18\x04V\x0e-2\x18@'
tRp1183
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1184
sg51
S'RBXYLJ'
p1185
sg25
g26
sg53
S'bqhgkm'
p1186
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1187
sS'trials.thisIndex'
p1188
g30
(g85
S'5\x00\x00\x00'
tRp1189
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1190
sS'trials.thisRepN'
p1191
I0
sg50
g30
(g32
S'\x18\x04V\x0e-2\x10@'
tRp1192
sg27
g11
sS'trials.thisTrialN'
p1193
I53
sg54
g30
(g32
S'\r\x02+\x87\x16\x19*@'
tRp1194
sg17
(lp1195
S'7'
asa(dp1196
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1197
sg19
(lp1198
F0.85138702392578125
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1199
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1200
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1201
sg16
F1453752521.460583
sS'trials.thisN'
p1202
I54
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1203
sg45
g30
(g70
S'\x0c\x00\x00\x00\x00\x00\x00\x00'
tRp1204
sg46
g30
(g32
S'X9\xb4\xc8v\xbe\x18@'
tRp1205
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1206
sg51
S'JXBMFD'
p1207
sg25
g26
sg53
S'jtngqh'
p1208
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1209
sS'trials.thisIndex'
p1210
g30
(g85
S'6\x00\x00\x00'
tRp1211
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1212
sS'trials.thisRepN'
p1213
I0
sg50
g30
(g32
S'X9\xb4\xc8v\xbe\x10@'
tRp1214
sg27
g11
sS'trials.thisTrialN'
p1215
I54
sg54
g30
(g32
S'\xac\x1cZd;_*@'
tRp1216
sg17
(lp1217
S'7'
asa(dp1218
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1219
sg45
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1220
sg46
g30
(g32
S'\x93\x18\x04V\x0e-\x11@'
tRp1221
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1222
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1223
sg51
S'WGHTRM'
p1224
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1225
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1226
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1227
sS'trials.thisIndex'
p1228
g30
(g85
S'7\x00\x00\x00'
tRp1229
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1230
sS'trials.thisRepN'
p1231
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1232
sg16
F1453752534.6487391
sg29
g33
sS'trials.thisN'
p1233
I55
sg50
g30
(g32
S'\x93\x18\x04V\x0e-\x11@'
tRp1234
sS'trials.thisTrialN'
p1235
I55
sg54
g30
(g32
S'\x93\x18\x04V\x0e-\x19@'
tRp1236
sg17
Nsa(dp1237
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1238
sg45
g30
(g70
S'90\x00\x00\x00\x00\x00\x00'
tRp1239
sg46
g30
(g32
S'/\xdd$\x06\x81\x15\x10@'
tRp1240
sg48
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1241
sg49
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1242
sg51
S'FMGYRL'
p1243
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1244
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1245
sg42
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1246
sS'trials.thisIndex'
p1247
g30
(g85
S'8\x00\x00\x00'
tRp1248
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1249
sS'trials.thisRepN'
p1250
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1251
sg16
F1453752540.934407
sg29
g33
sS'trials.thisN'
p1252
I56
sg50
g30
(g32
S'/\xdd$\x06\x81\x15\x10@'
tRp1253
sS'trials.thisTrialN'
p1254
I56
sg54
g30
(g32
S'/\xdd$\x06\x81\x15\x18@'
tRp1255
sg17
Nsa(dp1256
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1257
sg19
(lp1258
F0.81719088554382324
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1259
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1260
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1261
sg16
F1453752546.952981
sS'trials.thisN'
p1262
I57
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1263
sg45
g30
(g70
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp1264
sg46
g30
(g32
S'J\x0c\x02+\x87\x16\x1c@'
tRp1265
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1266
sg51
S'NBRLGF'
p1267
sg25
g26
sg53
S'yqrtdk'
p1268
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1269
sS'trials.thisIndex'
p1270
g30
(g85
S'9\x00\x00\x00'
tRp1271
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1272
sS'trials.thisRepN'
p1273
I0
sg50
g30
(g32
S'J\x0c\x02+\x87\x16\x14@'
tRp1274
sg27
g11
sS'trials.thisTrialN'
p1275
I57
sg54
g30
(g32
S'%\x06\x81\x95C\x0b,@'
tRp1276
sg17
(lp1277
S'7'
asa(dp1278
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1279
sg19
(lp1280
F0.71767807006835938
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1281
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1282
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1283
sg16
F1453752560.9749911
sS'trials.thisN'
p1284
I58
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1285
sg45
g30
(g70
S'\xc8\x01\x00\x00\x00\x00\x00\x00'
tRp1286
sg46
g30
(g32
S'&1\x08\xac\x1c\xda\x19@'
tRp1287
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1288
sg51
S'RLDNYJ'
p1289
sg25
g26
sg53
S'mqfkxh'
p1290
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1291
sS'trials.thisIndex'
p1292
g30
(g85
S':\x00\x00\x00'
tRp1293
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1294
sS'trials.thisRepN'
p1295
I0
sg50
g30
(g32
S"'1\x08\xac\x1c\xda\x11@"
tRp1296
sg27
g11
sS'trials.thisTrialN'
p1297
I58
sg54
g30
(g32
S'\x93\x18\x04V\x0e\xed*@'
tRp1298
sg17
(lp1299
S'8'
asa(dp1300
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1301
sg19
(lp1302
F0.86759781837463379
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1303
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1304
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1305
sg16
F1453752574.4301989
sS'trials.thisN'
p1306
I59
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1307
sg45
g30
(g70
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp1308
sg46
g30
(g32
S'\xa1E\xb6\xf3\xfdT\x1b@'
tRp1309
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1310
sg51
S'JGTWRX'
p1311
sg25
g26
sg53
S'kdwbnq'
p1312
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1313
sS'trials.thisIndex'
p1314
g30
(g85
S';\x00\x00\x00'
tRp1315
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1316
sS'trials.thisRepN'
p1317
I0
sg50
g30
(g32
S'\xa2E\xb6\xf3\xfdT\x13@'
tRp1318
sg27
g11
sS'trials.thisTrialN'
p1319
I59
sg54
g30
(g32
S'\xd1"\xdb\xf9~\xaa+@'
tRp1320
sg17
(lp1321
S'7'
asa(dp1322
g23
g24
sg27
g11
sg43
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1323
sg45
g30
(g70
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp1324
sg46
g30
(g32
S'\xfa~j\xbct\x13\x11@'
tRp1325
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1326
sg49
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1327
sg51
S'JGQFDT'
p1328
sg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1329
sg25
g26
sg53
S' '
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1330
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1331
sS'trials.thisIndex'
p1332
g30
(g85
S'<\x00\x00\x00'
tRp1333
sg18
I0
sg28
S'1'
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1334
sS'trials.thisRepN'
p1335
I0
sg47
g30
(g70
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1336
sg16
F1453752588.269206
sg29
g33
sS'trials.thisN'
p1337
I60
sg50
g30
(g32
S'\xfa~j\xbct\x13\x11@'
tRp1338
sS'trials.thisTrialN'
p1339
I60
sg54
g30
(g32
S'}?5^\xba\x89&@'
tRp1340
sg17
Nsa(dp1341
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1342
sg19
(lp1343
F0.83509206771850586
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1344
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1345
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1346
sg16
F1453752599.539432
sS'trials.thisN'
p1347
I61
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1348
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1349
sg46
g30
(g32
S'\x17\xd9\xce\xf7Sc\x18@'
tRp1350
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1351
sg51
S'RFTXJW'
p1352
sg25
g26
sg53
S'jbkygd'
p1353
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1354
sS'trials.thisIndex'
p1355
g30
(g85
S'=\x00\x00\x00'
tRp1356
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1357
sS'trials.thisRepN'
p1358
I0
sg50
g30
(g32
S'\x16\xd9\xce\xf7Sc\x10@'
tRp1359
sg27
g11
sS'trials.thisTrialN'
p1360
I61
sg54
g30
(g32
S'\x8cl\xe7\xfb\xa91*@'
tRp1361
sg17
(lp1362
S'7'
asa(dp1363
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1364
sg19
(lp1365
F1.0846738815307617
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1366
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1367
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1368
sg16
F1453752612.628089
sS'trials.thisN'
p1369
I62
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1370
sg45
g30
(g70
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1371
sg46
g30
(g32
S'\xc9v\xbe\x9f\x1a\xaf\x19@'
tRp1372
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1373
sg51
S'MHFQNW'
p1374
sg25
g26
sg53
S'bhxygr'
p1375
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1376
sS'trials.thisIndex'
p1377
g30
(g85
S'>\x00\x00\x00'
tRp1378
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1379
sS'trials.thisRepN'
p1380
I0
sg50
g30
(g32
S'\xc9v\xbe\x9f\x1a\xaf\x11@'
tRp1381
sg27
g11
sS'trials.thisTrialN'
p1382
I62
sg54
g30
(g32
S'd;\xdfO\x8d\xd7*@'
tRp1383
sg17
(lp1384
S'8'
asa(dp1385
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1386
sg19
(lp1387
F1.568195104598999
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1388
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1389
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1390
sg16
F1453752626.048466
sS'trials.thisN'
p1391
I63
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1392
sg45
g30
(g70
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp1393
sg46
g30
(g32
S'Zd;\xdfO\r\x18@'
tRp1394
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1395
sg51
S'RJQXFY'
p1396
sg25
g26
sg53
S'qhnmbw'
p1397
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1398
sS'trials.thisIndex'
p1399
g30
(g85
S'?\x00\x00\x00'
tRp1400
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1401
sS'trials.thisRepN'
p1402
I0
sg50
g30
(g32
S'Zd;\xdfO\r\x10@'
tRp1403
sg27
g11
sS'trials.thisTrialN'
p1404
I63
sg54
g30
(g32
S'-\xb2\x9d\xef\xa7\x06*@'
tRp1405
sg17
(lp1406
S'8'
asa(dp1407
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1408
sg19
(lp1409
F1.2012238502502441
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1410
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1411
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1412
sg16
F1453752639.052865
sS'trials.thisN'
p1413
I64
sg43
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1414
sg45
g30
(g70
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp1415
sg46
g30
(g32
S'\x1b/\xdd$\x06\x01\x1b@'
tRp1416
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1417
sg51
S'GBTKQH'
p1418
sg25
g26
sg53
S'dfljwy'
p1419
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1420
sS'trials.thisIndex'
p1421
g30
(g85
S'@\x00\x00\x00'
tRp1422
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1423
sS'trials.thisRepN'
p1424
I0
sg50
g30
(g32
S'\x1b/\xdd$\x06\x01\x13@'
tRp1425
sg27
g11
sS'trials.thisTrialN'
p1426
I64
sg54
g30
(g32
S'\x8d\x97n\x12\x83\x80+@'
tRp1427
sg17
(lp1428
S'8'
asa(dp1429
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1430
sg19
(lp1431
F0.86785387992858887
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1432
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1433
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1434
sg16
F1453752652.8082781
sS'trials.thisN'
p1435
I65
sg43
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1436
sg45
g30
(g70
S'"\x00\x00\x00\x00\x00\x00\x00'
tRp1437
sg46
g30
(g32
S'#\xdb\xf9~j\xbc\x18@'
tRp1438
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1439
sg51
S'BLDJFM'
p1440
sg25
g26
sg53
S'yjhtwq'
p1441
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1442
sS'trials.thisIndex'
p1443
g30
(g85
S'A\x00\x00\x00'
tRp1444
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1445
sS'trials.thisRepN'
p1446
I0
sg50
g30
(g32
S'#\xdb\xf9~j\xbc\x10@'
tRp1447
sg27
g11
sS'trials.thisTrialN'
p1448
I65
sg54
g30
(g32
S'\x92\xed|?5^*@'
tRp1449
sg17
(lp1450
S'7'
asa(dp1451
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1452
sg19
(lp1453
F1.1003570556640625
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1454
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1455
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1456
sg16
F1453752665.996278
sS'trials.thisN'
p1457
I66
sg43
g30
(g70
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1458
sg45
g30
(g70
S'90\x00\x00\x00\x00\x00\x00'
tRp1459
sg46
g30
(g32
S'\xb1rh\x91\xed|\x19@'
tRp1460
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1461
sg51
S'JRGXFB'
p1462
sg25
g26
sg53
S'htlkqm'
p1463
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1464
sS'trials.thisIndex'
p1465
g30
(g85
S'B\x00\x00\x00'
tRp1466
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1467
sS'trials.thisRepN'
p1468
I0
sg50
g30
(g32
S'\xb0rh\x91\xed|\x11@'
tRp1469
sg27
g11
sS'trials.thisTrialN'
p1470
I66
sg54
g30
(g32
S'X9\xb4\xc8v\xbe*@'
tRp1471
sg17
(lp1472
S'8'
asa(dp1473
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1474
sg19
(lp1475
F1.0009379386901855
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1476
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1477
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1478
sg16
F1453752679.3678739
sS'trials.thisN'
p1479
I67
sg43
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1480
sg45
g30
(g70
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1481
sg46
g30
(g32
S'\xf3\xfd\xd4x\xe9\xa6\x1d@'
tRp1482
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1483
sg51
S'XBRTGY'
p1484
sg25
g26
sg53
S'fkwnjd'
p1485
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1486
sS'trials.thisIndex'
p1487
g30
(g85
S'C\x00\x00\x00'
tRp1488
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1489
sS'trials.thisRepN'
p1490
I0
sg50
g30
(g32
S'\xf3\xfd\xd4x\xe9\xa6\x15@'
tRp1491
sg27
g11
sS'trials.thisTrialN'
p1492
I67
sg54
g30
(g32
S'\xfa~j\xbct\xd3,@'
tRp1493
sg17
(lp1494
S'8'
asa(dp1495
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1496
sg19
(lp1497
F0.75097894668579102
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1498
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1499
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1500
sg16
F1453752693.7738309
sS'trials.thisN'
p1501
I68
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1502
sg45
g30
(g70
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp1503
sg46
g30
(g32
S'{\x14\xaeG\xe1\xfa\x18@'
tRp1504
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1505
sg51
S'BRFTXJ'
p1506
sg25
g26
sg53
S'nhgklm'
p1507
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1508
sS'trials.thisIndex'
p1509
g30
(g85
S'D\x00\x00\x00'
tRp1510
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1511
sS'trials.thisRepN'
p1512
I0
sg50
g30
(g32
S'{\x14\xaeG\xe1\xfa\x10@'
tRp1513
sg27
g11
sS'trials.thisTrialN'
p1514
I68
sg54
g30
(g32
S'=\n\xd7\xa3p}*@'
tRp1515
sg17
(lp1516
S'8'
asa(dp1517
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1518
sg19
(lp1519
F1.2178151607513428
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1520
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1521
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1522
sg16
F1453752707.0119791
sS'trials.thisN'
p1523
I69
sg43
g30
(g70
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1524
sg45
g30
(g70
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1525
sg46
g30
(g32
S'j\xbct\x93\x18\x04\x18@'
tRp1526
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1527
sg51
S'BLNYMG'
p1528
sg25
g26
sg53
S'gqdthf'
p1529
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1530
sS'trials.thisIndex'
p1531
g30
(g85
S'E\x00\x00\x00'
tRp1532
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1533
sS'trials.thisRepN'
p1534
I0
sg50
g30
(g32
S'j\xbct\x93\x18\x04\x10@'
tRp1535
sg27
g11
sS'trials.thisTrialN'
p1536
I69
sg54
g30
(g32
S'6^\xbaI\x0c\x02*@'
tRp1537
sg17
(lp1538
S'7'
asa(dp1539
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1540
sg19
(lp1541
F0.6512138843536377
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1542
sg55
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1543
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1544
sg16
F1453752720.0151141
sS'trials.thisN'
p1545
I70
sg43
g30
(g70
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1546
sg45
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1547
sg46
g30
(g32
S'%\x06\x81\x95C\x8b\x18@'
tRp1548
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1549
sg51
S'TMLNFQ'
p1550
sg25
g26
sg53
S'dwrkxm'
p1551
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1552
sS'trials.thisIndex'
p1553
g30
(g85
S'F\x00\x00\x00'
tRp1554
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1555
sS'trials.thisRepN'
p1556
I0
sg50
g30
(g32
S'%\x06\x81\x95C\x8b\x10@'
tRp1557
sg27
g11
sS'trials.thisTrialN'
p1558
I70
sg54
g30
(g32
S'\x12\x83\xc0\xca\xa1E*@'
tRp1559
sg17
(lp1560
S'7'
asa(dp1561
g23
g24
sg29
g33
sg49
g30
(g70
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1562
sg19
(lp1563
F0.8512880802154541
asg52
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1564
sg55
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1565
sg18
I0
sg28
S'1'
sg47
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1566
sg16
F1453752733.1536901
sS'trials.thisN'
p1567
I71
sg43
g30
(g70
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1568
sg45
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1569
sg46
g30
(g32
S'\x1f\x85\xebQ\xb8\x1e\x18@'
tRp1570
sg48
g30
(g70
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1571
sg51
S'XLMQBK'
p1572
sg25
g26
sg53
S'fhgynw'
p1573
sg42
g30
(g70
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1574
sS'trials.thisIndex'
p1575
g30
(g85
S'G\x00\x00\x00'
tRp1576
sg44
g30
(g70
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1577
sS'trials.thisRepN'
p1578
I0
sg50
g30
(g32
S'\x1f\x85\xebQ\xb8\x1e\x10@'
tRp1579
sg27
g11
sS'trials.thisTrialN'
p1580
I71
sg54
g30
(g32
S'\x8f\xc2\xf5(\\\x0f*@'
tRp1581
sg17
(lp1582
S'8'
asa(dp1583
g23
g24
sg27
g11
sg28
S'1'
sg25
g26
sg29
g33
sg16
F1453752746.174325
sa(dp1584
g23
g24
sg27
g11
sg28
S'1'
sg25
g26
sg29
g33
sg16
F1453752756.1770289
sa(dp1585
g23
g24
sg27
g11
sg28
S'1'
sg25
g26
sg29
g33
sg16
F1453752756.1770871
sasS'loops'
p1586
(lp1587
g1
(cpsychopy.data
TrialHandler
p1588
g3
NtRp1589
(dp1590
S'origin'
p1591
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.01), Thu 24 Sep 2015 11:35:23 AM EDT\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a# from psychopy.hardware.emulator import launchScan\u000aimport time\u000aimport sys\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000aglobal expName\u000aglobal AllowedInputKeys\u000aAllowedInputKeys = ['1', '2','3','4','5','6','7','8','9','down','right']\u000aglobal FullScreenFlag \u000a\u000aFullScreenFlag = True\u000aScreenToUse = 'MacBookPro'\u000aexpName='PartialTrial'\u000a\u000adef TestSomething(subid=9999,visitid=0001):\u000a    expInfo = {u'Visit ID': u'9999', u'Participant ID': u'1'}\u000a    print 'subid is %s'%(subid)\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a    else:\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a    return expInfo\u000a\u000adef PartialTrial(INPUTFILE,subid=9999,visitid=9999):\u000a    #INPUTFILE = 'Optimized60trialsLoads12467_1.xlsx'\u000a    # INPUTFILE = 'TrialListLoads123466_6Repeats_121415_2.csv'\u000a    # INPUTFILE = 'TwoTrials.xlsx'\u000a    IntroTime = 10\u000a    End = 10 # This should be set so that it is at least ten seconds and so the experiment \u000a    # total duration is a multiple of two seconds.\u000a\u000a    MaxLetters = 6\u000a    if MaxLetters == 6:\u000a        SETwrapWidth = 1.5 # The wrap width of text needs to be adjusted based on how manty letters there are\u000a        SETletCycle = 13 # # Spaces are added between letters and this controls the loop which does it\u000a    elif MaxLetters == 7:\u000a        SETwrapWidth = 1.7\u000a        SETletCycle = 15\u000a    expInfo = {u'Visit ID': u'001', u'Participant ID': u''}\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a        if dlg.OK == False: win.close()  # user pressed cancel\u000a    else:\u000a        print "Subid entered is: %s"%(subid)\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a        \u000a    # Store info about the experiment session\u000a\u000a    \u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=True,\u000a        dataFileName=filename)\u000a    #save a log file for detail verbose info\u000a    logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[1366, 768], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor = ScreenToUse, color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'norm')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial"\u000a    trialClock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    \u000a    # THE AIM IS TO \u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=SETwrapWidth, ## Changed from 1.5 because of 7 letters\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=SETwrapWidth,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=SETwrapWidth,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    WaitForScanner = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Waiting for Scanner, press r to advance',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(INPUTFILE),\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a\u000a\u000a    # PRESENT THE SCREEN TO WAIT FOR THE MRI TRIGGER\u000a    #vol = launchScan(win, MR_settings,  mode='Scan')\u000a\u000a    # ########################################################\u000a    # There should be WAITING FOR SCANNER trial here\u000a    # The test2 routine has these parts in it\u000a    #------Prepare to start Routine "ScanWait"-------\u000a    t = 0\u000a    ScanWaitClock = core.Clock()\u000a    ScanWaitClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    ScannerTrigger = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    ScannerTrigger.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    ScanWaitComponents = []\u000a    ScanWaitComponents.append(WaitForScanner)\u000a    ScanWaitComponents.append(ScannerTrigger)\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "ScanWait"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = ScanWaitClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_4* updates\u000a        if t >= 0.0 and WaitForScanner.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            WaitForScanner.tStart = t  # underestimates by a little under one frame\u000a            WaitForScanner.frameNStart = frameN  # exact frame index\u000a            WaitForScanner.setAutoDraw(True)\u000a        \u000a        # *key_resp_3* updates\u000a        if t >= 0.0 and ScannerTrigger.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ScannerTrigger.tStart = t  # underestimates by a little under one frame\u000a            ScannerTrigger.frameNStart = frameN  # exact frame index\u000a            ScannerTrigger.status = STARTED\u000a            # keyboard checking is just starting\u000a            ScannerTrigger.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if ScannerTrigger.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['r','equal'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                ScannerTrigger.keys = theseKeys[-1]  # just the last key pressed\u000a                ScannerTrigger.rt = ScannerTrigger.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ScanWaitComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            \u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "ScanWait"-------\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if ScannerTrigger.keys in ['', [], None]:  # No response was made\u000a       ScannerTrigger.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('ScannerTrigger.keys',ScannerTrigger.keys)\u000a    if ScannerTrigger.keys != None:  # we had a response\u000a        thisExp.addData('ScannerTrigger.rt', ScannerTrigger.rt)\u000a    thisExp.nextEntry()\u000a    # ########################################################\u000a\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a\u000a    # Write out when the experiment begins\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    #------Prepare to start Routine "intro"-------\u000a    t = 0\u000a    introClock = core.Clock()\u000a    introClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(IntroTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    introComponents = []\u000a    introComponents.append(RestCrossHair)\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "intro"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = introClock.getTime()\u000a        \u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_3* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (0.0 + (IntroTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in introComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "intro"-------\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    # ########################################################\u000a\u000a    for thisTrial in trials:\u000a        # Write to the file the time this trial starts\u000a        trials.addData('TrialStartTime',time.time())\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        # ENCODING SET\u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempStimSet = StimSet\u000a        # Letters for space - letter - space - letter ... - space\u000a        StimSet=' '\u000a        for i in tempStimSet:\u000a            StimSet=StimSet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        UpBrackText = ''\u000a        if UpBrack > 0:\u000a            BracketList = list(str(UpBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,SETletCycle,1):   ## Changed from 13 when using 7 letters\u000a                UpBrackText = UpBrackText+' '\u000a            s = list(UpBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            UpBrackText = ''.join(s)\u000a        \u000a        # PROBE \u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempProbeLet = ProbeLet\u000a        # Letters for space - letter - space - letter ... - space\u000a        ProbeLet=' '\u000a        for i in tempProbeLet:\u000a            ProbeLet = ProbeLet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        BotBrackText = ''\u000a        if BotBrack > 0:\u000a            BracketList = list(str(BotBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,SETletCycle,1):   ## Changed from 13 when using 7 letters\u000a                BotBrackText = BotBrackText+' '\u000a            s = list(BotBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            BotBrackText = ''.join(s)\u000a            \u000a        # update component parameters for each repeat\u000a        UpperText.setText(StimSet)\u000a        UpperBrackets.setText(UpBrackText)\u000a        LowerText.setText(ProbeLet)\u000a        LowerBrackets.setText(BotBrackText)\u000a        \u000a        KeyboardResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        KeyboardResp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(TopUpperLine)\u000a        trialComponents.append(UpperText)\u000a        trialComponents.append(UpperBrackets)\u000a        trialComponents.append(BotUpperLine)\u000a        trialComponents.append(TopLowerLine)\u000a        trialComponents.append(LowerText)\u000a        trialComponents.append(LowerBrackets)\u000a        trialComponents.append(BotLowerLine)\u000a        trialComponents.append(TrialCrossHair)\u000a        trialComponents.append(RestCrossHair)\u000a        trialComponents.append(KeyboardResp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            \u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *TopUpperLine* updates\u000a            if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine.frameNStart = frameN  # exact frame index\u000a                TopUpperLine.setAutoDraw(True)\u000a            elif TopUpperLine.status == STARTED and t >= (0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine.setAutoDraw(False)\u000a            \u000a            # *UpperText* updates\u000a            if t >= 0 and UpperText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText.tStart = t  # underestimates by a little under one frame\u000a                UpperText.frameNStart = frameN  # exact frame index\u000a                UpperText.setAutoDraw(True)\u000a            elif UpperText.status == STARTED and t >= (0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets* updates\u000a            if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets.frameNStart = frameN  # exact frame index\u000a                UpperBrackets.setAutoDraw(True)\u000a            elif UpperBrackets.status == STARTED and t >= (0.0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine* updates\u000a            if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine.frameNStart = frameN  # exact frame index\u000a                BotUpperLine.setAutoDraw(True)\u000a            elif BotUpperLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine* updates\u000a            if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine.frameNStart = frameN  # exact frame index\u000a                TopLowerLine.setAutoDraw(True)\u000a            elif TopLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine.setAutoDraw(False)\u000a            \u000a            # *LowerText* updates\u000a            if t >= ProbeStart and LowerText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText.tStart = t  # underestimates by a little under one frame\u000a                LowerText.frameNStart = frameN  # exact frame index\u000a                LowerText.setAutoDraw(True)\u000a            elif LowerText.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets* updates\u000a            if t >= ProbeStart and LowerBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets.frameNStart = frameN  # exact frame index\u000a                LowerBrackets.setAutoDraw(True)\u000a            elif LowerBrackets.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine* updates\u000a            if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine.frameNStart = frameN  # exact frame index\u000a                BotLowerLine.setAutoDraw(True)\u000a            elif BotLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair* updates\u000a            if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair.setAutoDraw(True)\u000a            elif TrialCrossHair.status == STARTED and t >= (0 + (TrialDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= TrialDur and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            elif RestCrossHair.status == STARTED and t >= (TrialDur + (ITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # *KeyboardResp* updates\u000a            if t >= ProbeStart and KeyboardResp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                KeyboardResp.tStart = t  # underestimates by a little under one frame\u000a                KeyboardResp.frameNStart = frameN  # exact frame index\u000a                KeyboardResp.status = STARTED\u000a                # keyboard checking is just starting\u000a                KeyboardResp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif KeyboardResp.status == STARTED and t >= (ProbeStart + (ProbeDurITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                KeyboardResp.status = STOPPED\u000a            if KeyboardResp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    KeyboardResp.keys.extend(theseKeys)  # storing all keys\u000a                    KeyboardResp.rt.append(KeyboardResp.clock.getTime())\u000a                    # was this 'correct'?\u000a                    if (KeyboardResp.keys == str(Correct)) or (KeyboardResp.keys == Correct):\u000a                        KeyboardResp.corr = 1\u000a                    else:\u000a                        KeyboardResp.corr = 0\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(1)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if KeyboardResp.keys in ['', [], None]:  # No response was made\u000a           KeyboardResp.keys=None\u000a           # was no response the correct answer?!\u000a           if str(Correct).lower() == 'none': KeyboardResp.corr = 1  # correct non-response\u000a           else: KeyboardResp.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('KeyboardResp.keys',KeyboardResp.keys)\u000a        trials.addData('KeyboardResp.corr', KeyboardResp.corr)\u000a        if KeyboardResp.keys != None:  # we had a response\u000a            trials.addData('KeyboardResp.rt', KeyboardResp.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    EndTimeClock = core.Clock()\u000a    EndTimeClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(End)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    EndTimeComponents = []\u000a    EndTimeComponents.append(RestCrossHair)\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = EndTimeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        if RestCrossHair.status == STARTED and t >= (0.0 + (End-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in EndTimeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            #win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # ########################################################\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()    \u000a    # completed 1 repeats of 'trials'\u000a    # the Routine "trial" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    win.close()\u000a    #sys.exit()\u000a    return filename\u000a\u000adef PartialTrialFeedback(INPUTFILE,filename,subid=9999,visitid=9999):\u000a    expInfo = {u'Visit ID': u'001', u'Participant ID': u''}\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a        if dlg.OK == False: win.close()  # user pressed cancel\u000a    else:\u000a        print "Subid entered is: %s"%(subid)\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a        \u000a    # Store info about the experiment session\u000a\u000a    \u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    #filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=True,\u000a        dataFileName=filename)\u000a    #save a log file for detail verbose info\u000a    logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=u'testMonitor', color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'use preferences')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial"\u000a    trialClock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=1.7,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=1.7,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=1.5,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    WaitForScanner = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Waiting for Scanner\u005cn Or press r to advance',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    ThankYou = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Merci\u005cnThank you',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    # Initialize components for Routine "Feedback"\u000a    FeedbackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    FeedbackMsg = visual.TextStim(win=win, ori=0, name='FeedbackMsg',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(INPUTFILE),#TrialListShort1#TrialList5Loads6Repeats\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a\u000a\u000a    # PRESENT THE SCREEN TO WAIT FOR THE MRI TRIGGER\u000a    #vol = launchScan(win, MR_settings,  mode='Scan')\u000a\u000a    # ########################################################\u000a    # There should be WAITING FOR SCANNER trial here\u000a    # The test2 routine has these parts in it\u000a    #------Prepare to start Routine "ScanWait"-------\u000a    t = 0\u000a    ScanWaitClock = core.Clock()\u000a    ScanWaitClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    ScannerTrigger = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    ScannerTrigger.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    ScanWaitComponents = []\u000a    ScanWaitComponents.append(WaitForScanner)\u000a    ScanWaitComponents.append(ScannerTrigger)\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "ScanWait"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = ScanWaitClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_4* updates\u000a        if t >= 0.0 and WaitForScanner.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            WaitForScanner.tStart = t  # underestimates by a little under one frame\u000a            WaitForScanner.frameNStart = frameN  # exact frame index\u000a            WaitForScanner.setAutoDraw(True)\u000a        \u000a        # *key_resp_3* updates\u000a        if t >= 0.0 and ScannerTrigger.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ScannerTrigger.tStart = t  # underestimates by a little under one frame\u000a            ScannerTrigger.frameNStart = frameN  # exact frame index\u000a            ScannerTrigger.status = STARTED\u000a            # keyboard checking is just starting\u000a            ScannerTrigger.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if ScannerTrigger.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['5', 'r'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                ScannerTrigger.keys = theseKeys[-1]  # just the last key pressed\u000a                ScannerTrigger.rt = ScannerTrigger.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ScanWaitComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            #core.quit()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "ScanWait"-------\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if ScannerTrigger.keys in ['', [], None]:  # No response was made\u000a       ScannerTrigger.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('ScannerTrigger.keys',ScannerTrigger.keys)\u000a    if ScannerTrigger.keys != None:  # we had a response\u000a        thisExp.addData('ScannerTrigger.rt', ScannerTrigger.rt)\u000a    thisExp.nextEntry()\u000a    # ########################################################\u000a\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a    IntroTime = 5\u000a    # Write out when the experiment begins\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    #------Prepare to start Routine "intro"-------\u000a    t = 0\u000a    introClock = core.Clock()\u000a    introClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(IntroTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    introComponents = []\u000a    introComponents.append(RestCrossHair)\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "intro"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = introClock.getTime()\u000a        \u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_3* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (0.0 + (IntroTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in introComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "intro"-------\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    # ########################################################\u000a\u000a    for thisTrial in trials:\u000a        # Write to the file the time this trial starts\u000a        trials.addData('TrialStartTime',time.time())\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        # ENCODING SET\u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempStimSet = StimSet\u000a        # Letters for space - letter - space - letter ... - space\u000a        StimSet=' '\u000a        for i in tempStimSet:\u000a            StimSet=StimSet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        UpBrackText = ''\u000a        if UpBrack > 0:\u000a            BracketList = list(str(UpBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,13,1):   ## Changed from 13 when using 7 letters\u000a                UpBrackText = UpBrackText+' '\u000a            s = list(UpBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            UpBrackText = ''.join(s)\u000a        \u000a        # PROBE \u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempProbeLet = ProbeLet\u000a        print '%s'%(tempProbeLet)\u000a        # Letters for space - letter - space - letter ... - space\u000a        ProbeLet=' '\u000a        for i in tempProbeLet:\u000a            ProbeLet = ProbeLet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        BotBrackText = ''\u000a        if BotBrack > 0:\u000a            BracketList = list(str(BotBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,13,1):   ## Changed from 13 when using 7 letters\u000a                BotBrackText = BotBrackText+' '\u000a            s = list(BotBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            BotBrackText = ''.join(s)\u000a            \u000a        # update component parameters for each repeat\u000a        UpperText.setText(StimSet)\u000a        UpperBrackets.setText(UpBrackText)\u000a        LowerText.setText(ProbeLet)\u000a        LowerBrackets.setText(BotBrackText)\u000a        \u000a        KeyboardResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        KeyboardResp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(TopUpperLine)\u000a        trialComponents.append(UpperText)\u000a        trialComponents.append(UpperBrackets)\u000a        trialComponents.append(BotUpperLine)\u000a        trialComponents.append(TopLowerLine)\u000a        trialComponents.append(LowerText)\u000a        trialComponents.append(LowerBrackets)\u000a        trialComponents.append(BotLowerLine)\u000a        trialComponents.append(TrialCrossHair)\u000a        trialComponents.append(RestCrossHair)\u000a        trialComponents.append(KeyboardResp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            \u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *TopUpperLine* updates\u000a            if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine.frameNStart = frameN  # exact frame index\u000a                TopUpperLine.setAutoDraw(True)\u000a            elif TopUpperLine.status == STARTED and t >= (0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine.setAutoDraw(False)\u000a            \u000a            # *UpperText* updates\u000a            if t >= 0 and UpperText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText.tStart = t  # underestimates by a little under one frame\u000a                UpperText.frameNStart = frameN  # exact frame index\u000a                UpperText.setAutoDraw(True)\u000a            elif UpperText.status == STARTED and t >= (0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets* updates\u000a            if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets.frameNStart = frameN  # exact frame index\u000a                UpperBrackets.setAutoDraw(True)\u000a            elif UpperBrackets.status == STARTED and t >= (0.0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine* updates\u000a            if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine.frameNStart = frameN  # exact frame index\u000a                BotUpperLine.setAutoDraw(True)\u000a            elif BotUpperLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine* updates\u000a            if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine.frameNStart = frameN  # exact frame index\u000a                TopLowerLine.setAutoDraw(True)\u000a            elif TopLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine.setAutoDraw(False)\u000a            \u000a            # *LowerText* updates\u000a            if t >= ProbeStart and LowerText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText.tStart = t  # underestimates by a little under one frame\u000a                LowerText.frameNStart = frameN  # exact frame index\u000a                LowerText.setAutoDraw(True)\u000a            elif LowerText.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets* updates\u000a            if t >= ProbeStart and LowerBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets.frameNStart = frameN  # exact frame index\u000a                LowerBrackets.setAutoDraw(True)\u000a            elif LowerBrackets.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine* updates\u000a            if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine.frameNStart = frameN  # exact frame index\u000a                BotLowerLine.setAutoDraw(True)\u000a            elif BotLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair* updates\u000a            if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair.setAutoDraw(True)\u000a            elif TrialCrossHair.status == STARTED and t >= (0 + (TrialDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= TrialDur and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            elif RestCrossHair.status == STARTED and t >= (TrialDur + (ITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # *KeyboardResp* updates\u000a            if t >= ProbeStart and KeyboardResp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                KeyboardResp.tStart = t  # underestimates by a little under one frame\u000a                KeyboardResp.frameNStart = frameN  # exact frame index\u000a                KeyboardResp.status = STARTED\u000a                # keyboard checking is just starting\u000a                KeyboardResp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif KeyboardResp.status == STARTED and t >= (ProbeStart + (ProbeDurITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                KeyboardResp.status = STOPPED\u000a            if KeyboardResp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    #KeyboardResp.keys.extend(theseKeys)  # storing all keys\u000a                    KeyboardResp.keys = theseKeys[-1]  # just the last key pressed\u000a                    #KeyboardResp.rt.append(KeyboardResp.clock.getTime())\u000a                    KeyboardResp.rt = KeyboardResp.clock.getTime()\u000a                    # was this 'correct'?\u000a                    # What if the participant responded whenthey were not supposed to?\u000a                    if str(Correct).lower() == 'none':\u000a                        KeyboardResp.corr = -10 # RESPONSE WHEN NONE WAS EXPECTED\u000a                    else:\u000a                        if (KeyboardResp.keys == str(Correct)) or (KeyboardResp.keys == Correct):\u000a                            KeyboardResp.corr = 1 # CORRECT\u000a                        else:\u000a                            KeyboardResp.corr = 0 # INCORRECT\u000a                    # was this 'correct'?\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(1)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if KeyboardResp.keys in ['', [], None]:  # No response was made\u000a           KeyboardResp.keys=None\u000a           # was no response the correct answer?!\u000a           if str(Correct).lower() == 'none': KeyboardResp.corr = 10  # correct non-response\u000a           else: KeyboardResp.corr = -1  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('KeyboardResp.keys',KeyboardResp.keys)\u000a        trials.addData('KeyboardResp.corr', KeyboardResp.corr)\u000a        if KeyboardResp.keys != None:  # we had a response\u000a            trials.addData('KeyboardResp.rt', KeyboardResp.rt)\u000a        thisExp.nextEntry()\u000a        \u000a        \u000a    # ########################################################    \u000a        #------Prepare to start Routine "Feedback"-------\u000a        FeedbackDur = 1.5\u000a        t = 0\u000a        FeedbackClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(FeedbackDur)\u000a        # update component parameters for each repeat\u000a        if KeyboardResp.corr == 1:#stored on last run routine\u000a          msg="Correct! RT=%.3f" %(KeyboardResp.rt)\u000a        elif KeyboardResp.corr == 0:\u000a          msg="Oops! That was wrong"\u000a        elif KeyboardResp.corr == -1:\u000a          msg="No response...miss"\u000a        elif KeyboardResp.corr == 10:\u000a          msg="No response, good!"\u000a        FeedbackMsg.setText(msg)\u000a        # keep track of which components have finished\u000a        FeedbackComponents = []\u000a        FeedbackComponents.append(FeedbackMsg)\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = FeedbackClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *FeedbackMsg* updates\u000a            if t >= 0.0 and FeedbackMsg.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                FeedbackMsg.tStart = t  # underestimates by a little under one frame\u000a                FeedbackMsg.frameNStart = frameN  # exact frame index\u000a                FeedbackMsg.setAutoDraw(True)\u000a            if FeedbackMsg.status == STARTED and t >= (0.0 + (FeedbackDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                FeedbackMsg.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in FeedbackComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback"-------\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a        #------Prepare to start Routine "REST"-------\u000a        t = 0\u000a        RESTClock = core.Clock()\u000a        RESTClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(1.000000)\u000a        # update component parameters for each repeat\u000a        # keep track of which components have finished\u000a        RESTComponents = []\u000a        RESTComponents.append(RestCrossHair)\u000a        for thisComponent in RESTComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "REST"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = RESTClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            if RestCrossHair.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in RESTComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "REST"-------\u000a        for thisComponent in RESTComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        thisExp.nextEntry()\u000a\u000a\u000a    win.flip()\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a    EndTime = 10\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    EndTimeClock = core.Clock()\u000a    EndTimeClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(EndTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    EndTimeComponents = []\u000a    EndTimeComponents.append(RestCrossHair)\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = EndTimeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        if RestCrossHair.status == STARTED and t >= (0.0 + (EndTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in EndTimeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "EndTime"-------\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a            \u000a    # ########################################################        \u000a    # There should be an intro off trial here also\u000a    ThankYouTime = 3\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    ThankYouClock = core.Clock()\u000a    ThankYouClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(ThankYouTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    ThankYouComponents = []\u000a    ThankYouComponents.append(ThankYou)\u000a    for thisComponent in ThankYouComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = ThankYouClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and ThankYou.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ThankYou.tStart = t  # underestimates by a little under one frame\u000a            ThankYou.frameNStart = frameN  # exact frame index\u000a            ThankYou.setAutoDraw(True)\u000a        if ThankYou.status == STARTED and t >= (0.0 + (ThankYouTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            ThankYou.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ThankYouComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "Thank you"-------\u000a    for thisComponent in ThankYouComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)       \u000a    # ########################################################\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()    \u000a    # completed 1 repeats of 'trials'\u000a    win.close()\u000a#    win.close()\u000a\u000adef Instructions():\u000a    # Store info about the experiment session\u000a    expName = u'Instructions'  # from the Builder filename that created this script\u000a    expInfo = {u'session': u'001', u'participant': u''}\u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=False,\u000a        dataFileName=filename)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=u'UbuntuMon', color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'norm')\u000a\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "ButtonPractice"\u000a    ButtonPracticeClock = core.Clock()\u000a    text_28 = visual.TextStim(win=win, ori=0, name='text_28',\u000a        text="First ...\u005cnLet's make sure the buttons work.\u005cnPress the RIGHT INDEX Finger button.",    font='Courier',\u000a        pos=[0,0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    ISI_14 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_14')\u000a    TopUpperLine_14 = visual.Line(win=win, name='TopUpperLine_14',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_14 = visual.TextStim(win=win, ori=0, name='UpperText_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    UpperBrackets_14 = visual.TextStim(win=win, ori=0, name='UpperBrackets_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    BotUpperLine_14 = visual.Line(win=win, name='BotUpperLine_14',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_14 = visual.Line(win=win, name='TopLowerLine_14',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_14 = visual.TextStim(win=win, ori=0, name='LowerText_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    LowerBrackets_14 = visual.TextStim(win=win, ori=0, name='LowerBrackets_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    BotLowerLine_14 = visual.Line(win=win, name='BotLowerLine_14',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_14 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_14',\u000a        text='\u005cn',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    RestCrossHair_14 = visual.TextStim(win=win, ori=0, name='RestCrossHair_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a\u000a    # Initialize components for Routine "Feedback"\u000a    FeedbackClock = core.Clock()\u000a    msg='?????'\u000a    text_25 = visual.TextStim(win=win, ori=0, name='text_25',\u000a        text='default text',    font='Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Initialize components for Routine "ButtonPractice_MIDDLE"\u000a    ButtonPractice_MIDDLEClock = core.Clock()\u000a    text_29 = visual.TextStim(win=win, ori=0, name='text_29',\u000a        text='Press the RIGHT MIDDLE Finger button.',    font='Courier',\u000a        pos=[0,0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    ISI_15 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_15')\u000a    TopUpperLine_15 = visual.Line(win=win, name='TopUpperLine_15',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_15 = visual.TextStim(win=win, ori=0, name='UpperText_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    UpperBrackets_15 = visual.TextStim(win=win, ori=0, name='UpperBrackets_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    BotUpperLine_15 = visual.Line(win=win, name='BotUpperLine_15',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_15 = visual.Line(win=win, name='TopLowerLine_15',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_15 = visual.TextStim(win=win, ori=0, name='LowerText_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    LowerBrackets_15 = visual.TextStim(win=win, ori=0, name='LowerBrackets_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    BotLowerLine_15 = visual.Line(win=win, name='BotLowerLine_15',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_15 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_15',\u000a        text='\u005cn',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    RestCrossHair_15 = visual.TextStim(win=win, ori=0, name='RestCrossHair_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a\u000a    # Initialize components for Routine "Feedback_MIDDLE"\u000a    Feedback_MIDDLEClock = core.Clock()\u000a    msg='?????'\u000a    text_26 = visual.TextStim(win=win, ori=0, name='text_26',\u000a        text='default text',    font=u'Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_2"\u000a    var_6Letters_2Clock = core.Clock()\u000a    text_13 = visual.TextStim(win=win, ori=0, name='text_13',\u000a        text='This is the screen you will see for each trial',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text_16 = visual.TextStim(win=win, ori=0, name='text_16',\u000a        text='With an UPPER Part',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_18 = visual.TextStim(win=win, ori=0, name='text_18',\u000a        text='And a LOWER part',    font='Courier',\u000a        pos=[0,-0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_21 = visual.TextStim(win=win, ori=0, name='text_21',\u000a        text=None,    font='Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_13 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_13')\u000a    TopUpperLine_13 = visual.Line(win=win, name='TopUpperLine_13',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_13 = visual.TextStim(win=win, ori=0, name='UpperText_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_13 = visual.TextStim(win=win, ori=0, name='UpperBrackets_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_13 = visual.Line(win=win, name='BotUpperLine_13',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_13 = visual.Line(win=win, name='TopLowerLine_13',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_13 = visual.TextStim(win=win, ori=0, name='LowerText_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_13 = visual.TextStim(win=win, ori=0, name='LowerBrackets_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_13 = visual.Line(win=win, name='BotLowerLine_13',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_13 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_13',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_13 = visual.TextStim(win=win, ori=0, name='RestCrossHair_13',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_22 = visual.TextStim(win=win, ori=0, name='text_22',\u000a        text='You will also see a cross hair on the screen',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_23 = visual.TextStim(win=win, ori=0, name='text_23',\u000a        text='Either Green',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_24 = visual.TextStim(win=win, ori=0, name='text_24',\u000a        text='Or RED',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_0"\u000a    var_6Letters_0Clock = core.Clock()\u000a    text_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a        text='For this experiment you will see letters at the top of the screen.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.1,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text = visual.TextStim(win=win, ori=0, name='text',\u000a        text='Some of the letters will be enclosed by brackets.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_6 = visual.TextStim(win=win, ori=0, name='text_6',\u000a        text=u'These are the letters to remember.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a        text='The letters will be removed, focus on the green cross hair.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_11 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_11')\u000a    TopUpperLine_11 = visual.Line(win=win, name='TopUpperLine_11',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_11 = visual.TextStim(win=win, ori=0, name='UpperText_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_11 = visual.TextStim(win=win, ori=0, name='UpperBrackets_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_11 = visual.Line(win=win, name='BotUpperLine_11',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_11 = visual.Line(win=win, name='TopLowerLine_11',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_11 = visual.TextStim(win=win, ori=0, name='LowerText_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_11 = visual.TextStim(win=win, ori=0, name='LowerBrackets_11',\u000a        text='  { }        ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_11 = visual.Line(win=win, name='BotLowerLine_11',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_11 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_11',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_11 = visual.TextStim(win=win, ori=0, name='RestCrossHair_11',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_5 = visual.TextStim(win=win, ori=0, name='text_5',\u000a        text='You will then see letters at the bottom.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.1,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a        text='Only one letter will be in brackets.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a    text_8 = visual.TextStim(win=win, ori=0, name='text_8',\u000a        text='You need to decide whether this letter was one that you had to remember.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-18.0)\u000a    text_9 = visual.TextStim(win=win, ori=0, name='text_9',\u000a        text='YES = INDEX finger button\u005cnNO  = MIDDLE finger button',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-19.0)\u000a    text_10 = visual.TextStim(win=win, ori=0, name='text_10',\u000a        text='The trial is then over and the cross hair turns RED.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-20.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_1"\u000a    var_6Letters_1Clock = core.Clock()\u000a    text_11 = visual.TextStim(win=win, ori=0, name='text_11',\u000a        text=u"Let's Repeat",    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_12 = visual.TextStim(win=win, ori=0, name='text_12',\u000a        text='Remember the letters B and C',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_14 = visual.TextStim(win=win, ori=0, name='text_14',\u000a        text=u'Letters are removed',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    ISI_12 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_12')\u000a    TopUpperLine_12 = visual.Line(win=win, name='TopUpperLine_12',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_12 = visual.TextStim(win=win, ori=0, name='UpperText_12',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-5.0)\u000a    UpperBrackets_12 = visual.TextStim(win=win, ori=0, name='UpperBrackets_12',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    BotUpperLine_12 = visual.Line(win=win, name='BotUpperLine_12',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_12 = visual.Line(win=win, name='TopLowerLine_12',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_12 = visual.TextStim(win=win, ori=0, name='LowerText_12',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    LowerBrackets_12 = visual.TextStim(win=win, ori=0, name='LowerBrackets_12',\u000a        text='  { }        ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    BotLowerLine_12 = visual.Line(win=win, name='BotLowerLine_12',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_12 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_12',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-12.0)\u000a    RestCrossHair_12 = visual.TextStim(win=win, ori=0, name='RestCrossHair_12',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    text_17 = visual.TextStim(win=win, ori=0, name='text_17',\u000a        text=u'Are you trying to remember the letter b?',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_19 = visual.TextStim(win=win, ori=0, name='text_19',\u000a        text=u'Yes you are. You would press the INDEX finger button as quickly as possible.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_20 = visual.TextStim(win=win, ori=0, name='text_20',\u000a        text=u'The trial is over and the cross hair turns RED.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "DemoTrialRealTimes"\u000a    DemoTrialRealTimesClock = core.Clock()\u000a    text_44 = visual.TextStim(win=win, ori=0, name='text_44',\u000a        text=u"Let's repeat at the true pace",    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_45 = visual.TextStim(win=win, ori=0, name='text_45',\u000a        text=u'Remember the letters B and C',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_46 = visual.TextStim(win=win, ori=0, name='text_46',\u000a        text=u'Letters are removed',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    ISI_18 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_18')\u000a    TopUpperLine_18 = visual.Line(win=win, name='TopUpperLine_18',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_18 = visual.TextStim(win=win, ori=0, name='UpperText_18',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-5.0)\u000a    UpperBrackets_18 = visual.TextStim(win=win, ori=0, name='UpperBrackets_18',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    BotUpperLine_18 = visual.Line(win=win, name='BotUpperLine_18',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_18 = visual.Line(win=win, name='TopLowerLine_18',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_17 = visual.TextStim(win=win, ori=0, name='LowerText_17',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    LowerBrackets_17 = visual.TextStim(win=win, ori=0, name='LowerBrackets_17',\u000a        text=u'  { }        ',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    BotLowerLine_18 = visual.Line(win=win, name='BotLowerLine_18',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_18 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_18',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-12.0)\u000a    RestCrossHair_18 = visual.TextStim(win=win, ori=0, name='RestCrossHair_18',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-13.0)\u000a    text_48 = visual.TextStim(win=win, ori=0, name='text_48',\u000a        text=u'Respond as quickly as possible',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_49 = visual.TextStim(win=win, ori=0, name='text_49',\u000a        text=u'The trial is over and the cross hair turns RED.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-16.0)\u000a\u000a    # Initialize components for Routine "NumLettersToRem"\u000a    NumLettersToRemClock = core.Clock()\u000a    text_15 = visual.TextStim(win=win, ori=0, name='text_15',\u000a        text='The number of letters to remember',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text_33 = visual.TextStim(win=win, ori=0, name='text_33',\u000a        text='Varies between 1 and 6',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_34 = visual.TextStim(win=win, ori=0, name='text_34',\u000a        text='There will always be six letters presented',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a        text='It is the brackets that indicate which letters to remember.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    text_35 = visual.TextStim(win=win, ori=0, name='text_35',\u000a        text='Here are some examples',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    UpBrack1 = visual.TextStim(win=win, ori=0, name='UpBrack1',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-5.0)\u000a    ISI_17 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_17')\u000a    TopUpperLine_17 = visual.Line(win=win, name='TopUpperLine_17',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_17 = visual.TextStim(win=win, ori=0, name='UpperText_17',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    UpperBrackets_17 = visual.TextStim(win=win, ori=0, name='UpperBrackets_17',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    BotUpperLine_17 = visual.Line(win=win, name='BotUpperLine_17',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_17 = visual.Line(win=win, name='TopLowerLine_17',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    BotLowerLine_17 = visual.Line(win=win, name='BotLowerLine_17',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_17 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_17',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_17 = visual.TextStim(win=win, ori=0, name='RestCrossHair_17',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    UpBrack2 = visual.TextStim(win=win, ori=0, name='UpBrack2',\u000a        text='{   }        ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    UpBrack3 = visual.TextStim(win=win, ori=0, name='UpBrack3',\u000a        text='      {     }',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='Yellow', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    UpBrack4 = visual.TextStim(win=win, ori=0, name='UpBrack4',\u000a        text='  {       }  ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a    UpBrack5 = visual.TextStim(win=win, ori=0, name='UpBrack5',\u000a        text='{         }  ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-18.0)\u000a    UpBrack6 = visual.TextStim(win=win, ori=0, name='UpBrack6',\u000a        text=u'{           }',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-19.0)\u000a    text_38 = visual.TextStim(win=win, ori=0, name='text_38',\u000a        text=u'One letter',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-20.0)\u000a    text_39 = visual.TextStim(win=win, ori=0, name='text_39',\u000a        text=u'Two letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-21.0)\u000a    text_40 = visual.TextStim(win=win, ori=0, name='text_40',\u000a        text=u'Three letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-22.0)\u000a    text_41 = visual.TextStim(win=win, ori=0, name='text_41',\u000a        text=u'Four letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-23.0)\u000a    text_42 = visual.TextStim(win=win, ori=0, name='text_42',\u000a        text=u'Five letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-24.0)\u000a    text_43 = visual.TextStim(win=win, ori=0, name='text_43',\u000a        text=u'Six letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-25.0)\u000a\u000a    # Initialize components for Routine "TrialParts_1"\u000a    TrialParts_1Clock = core.Clock()\u000a    text_27 = visual.TextStim(win=win, ori=0, name='text_27',\u000a        text=u'To help with the analysis of the brain data.\u005cnSome trials are PARTIAL.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_30 = visual.TextStim(win=win, ori=0, name='text_30',\u000a        text='All trials will have a set of letters to study.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_31 = visual.TextStim(win=win, ori=0, name='text_31',\u000a        text='Some will not require a response',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_32 = visual.TextStim(win=win, ori=0, name='text_32',\u000a        text='Some will have no delay between the letters to study and the response.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_16 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_16')\u000a    TopUpperLine_16 = visual.Line(win=win, name='TopUpperLine_16',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_16 = visual.TextStim(win=win, ori=0, name='UpperText_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_16 = visual.TextStim(win=win, ori=0, name='UpperBrackets_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_16 = visual.Line(win=win, name='BotUpperLine_16',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_16 = visual.Line(win=win, name='TopLowerLine_16',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_16 = visual.TextStim(win=win, ori=0, name='LowerText_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_16 = visual.TextStim(win=win, ori=0, name='LowerBrackets_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_16 = visual.Line(win=win, name='BotLowerLine_16',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_16 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_16 = visual.TextStim(win=win, ori=0, name='RestCrossHair_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_36 = visual.TextStim(win=win, ori=0, name='text_36',\u000a        text='What is important is that when the crosshair turns RED. The trial is over.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_37 = visual.TextStim(win=win, ori=0, name='text_37',\u000a        text='Try to forget any of the studied letters and wait for the next trial',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_50 = visual.TextStim(win=win, ori=0, name='text_50',\u000a        text=u'Here is an example trial with feedback.\u005cnRemember respond as quickly as possible.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "trial5_2"\u000a    trial5_2Clock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'      { }    ',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Initialize components for Routine "TrialFeedBack"\u000a    TrialFeedBackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    text_47 = visual.TextStim(win=win, ori=0, name='text_47',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=10, method='sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a    for thisTrial in trials:\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "ButtonPractice"-------\u000a        t = 0\u000a        ButtonPracticeClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(120.000000)\u000a        # update component parameters for each repeat\u000a        UpperText_14.setText('')\u000a        UpperBrackets_14.setText('')\u000a        LowerText_14.setText('')\u000a        key_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        ButtonPracticeComponents = []\u000a        ButtonPracticeComponents.append(text_28)\u000a        ButtonPracticeComponents.append(ISI_14)\u000a        ButtonPracticeComponents.append(TopUpperLine_14)\u000a        ButtonPracticeComponents.append(UpperText_14)\u000a        ButtonPracticeComponents.append(UpperBrackets_14)\u000a        ButtonPracticeComponents.append(BotUpperLine_14)\u000a        ButtonPracticeComponents.append(TopLowerLine_14)\u000a        ButtonPracticeComponents.append(LowerText_14)\u000a        ButtonPracticeComponents.append(LowerBrackets_14)\u000a        ButtonPracticeComponents.append(BotLowerLine_14)\u000a        ButtonPracticeComponents.append(TrialCrossHair_14)\u000a        ButtonPracticeComponents.append(RestCrossHair_14)\u000a        ButtonPracticeComponents.append(key_resp_2)\u000a        for thisComponent in ButtonPracticeComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "ButtonPractice"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = ButtonPracticeClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_28* updates\u000a            if t >= 0 and text_28.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_28.tStart = t  # underestimates by a little under one frame\u000a                text_28.frameNStart = frameN  # exact frame index\u000a                text_28.setAutoDraw(True)\u000a            elif text_28.status == STARTED and t >= (0 + (60-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_28.setAutoDraw(False)\u000a            \u000a            # *TopUpperLine_14* updates\u000a            if t >= 0 and TopUpperLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine_14.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine_14.frameNStart = frameN  # exact frame index\u000a                TopUpperLine_14.setAutoDraw(True)\u000a            elif TopUpperLine_14.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine_14.setAutoDraw(False)\u000a            \u000a            # *UpperText_14* updates\u000a            if t >= 0 and UpperText_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText_14.tStart = t  # underestimates by a little under one frame\u000a                UpperText_14.frameNStart = frameN  # exact frame index\u000a                UpperText_14.setAutoDraw(True)\u000a            elif UpperText_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText_14.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets_14* updates\u000a            if t >= 0 and UpperBrackets_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets_14.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets_14.frameNStart = frameN  # exact frame index\u000a                UpperBrackets_14.setAutoDraw(True)\u000a            elif UpperBrackets_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets_14.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine_14* updates\u000a            if t >= 0.0 and BotUpperLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine_14.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine_14.frameNStart = frameN  # exact frame index\u000a                BotUpperLine_14.setAutoDraw(True)\u000a            elif BotUpperLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine_14.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine_14* updates\u000a            if t >= 0.0 and TopLowerLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine_14.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine_14.frameNStart = frameN  # exact frame index\u000a                TopLowerLine_14.setAutoDraw(True)\u000a            elif TopLowerLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine_14.setAutoDraw(False)\u000a            \u000a            # *LowerText_14* updates\u000a            if t >= 0 and LowerText_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText_14.tStart = t  # underestimates by a little under one frame\u000a                LowerText_14.frameNStart = frameN  # exact frame index\u000a                LowerText_14.setAutoDraw(True)\u000a            elif LowerText_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText_14.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets_14* updates\u000a            if t >= 0 and LowerBrackets_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets_14.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets_14.frameNStart = frameN  # exact frame index\u000a                LowerBrackets_14.setAutoDraw(True)\u000a            elif LowerBrackets_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets_14.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine_14* updates\u000a            if t >= 0.0 and BotLowerLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine_14.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine_14.frameNStart = frameN  # exact frame index\u000a                BotLowerLine_14.setAutoDraw(True)\u000a            elif BotLowerLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine_14.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair_14* updates\u000a            if t >= 0 and TrialCrossHair_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair_14.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair_14.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair_14.setAutoDraw(True)\u000a            elif TrialCrossHair_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair_14.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair_14* updates\u000a            if t >= 0 and RestCrossHair_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair_14.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair_14.frameNStart = frameN  # exact frame index\u000a                RestCrossHair_14.setAutoDraw(True)\u000a            elif RestCrossHair_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair_14.setAutoDraw(False)\u000a            \u000a            # *key_resp_2* updates\u000a            if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_2.tStart = t  # underestimates by a little under one frame\u000a                key_resp_2.frameNStart = frameN  # exact frame index\u000a                key_resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif key_resp_2.status == STARTED and t >= (0.0 + (60-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_2.status = STOPPED\u000a            if key_resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8', '9','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_2.rt = key_resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_2.keys == str('6')) or (key_resp_2.keys == 'down'):\u000a                        key_resp_2.corr = 1\u000a                    else:\u000a                        key_resp_2.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            # *ISI_14* period\u000a            if t >= 0.0 and ISI_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI_14.tStart = t  # underestimates by a little under one frame\u000a                ISI_14.frameNStart = frameN  # exact frame index\u000a                ISI_14.start(1)\u000a            elif ISI_14.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI_14.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in ButtonPracticeComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                #win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "ButtonPractice"-------\u000a        for thisComponent in ButtonPracticeComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_2.keys in ['', [], None]:  # No response was made\u000a           key_resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str('6').lower() == 'none': key_resp_2.corr = 1  # correct non-response\u000a           else: key_resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('key_resp_2.keys',key_resp_2.keys)\u000a        trials.addData('key_resp_2.corr', key_resp_2.corr)\u000a        if key_resp_2.keys != None:  # we had a response\u000a            trials.addData('key_resp_2.rt', key_resp_2.rt)\u000a        \u000a        #------Prepare to start Routine "Feedback"-------\u000a        t = 0\u000a        FeedbackClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        if len(key_resp_2.keys)<1:\u000a            msg="Please press the RIGHT INDEX Finger button"\u000a            trials.finished = Falses\u000a        elif key_resp_2.corr:#stored on last run routine\u000a            msg="Correct! That button indicates a YES response." \u000a            trials.finished = True\u000a        else:\u000a            msg="Oops! Wrong button, please try again."\u000a            trials.finished = False\u000a        text_25.setText(msg)\u000a        # keep track of which components have finished\u000a        FeedbackComponents = []\u000a        FeedbackComponents.append(text_25)\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = FeedbackClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_25* updates\u000a            if t >= 0.0 and text_25.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_25.tStart = t  # underestimates by a little under one frame\u000a                text_25.frameNStart = frameN  # exact frame index\u000a                text_25.setAutoDraw(True)\u000a            elif text_25.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_25.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in FeedbackComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                \u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback"-------\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 10 repeats of 'trials'\u000a\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials_2 = data.TrialHandler(nReps=10, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='trials_2')\u000a    thisExp.addLoop(trials_2)  # add the loop to the experiment\u000a    thisTrial_2 = trials_2.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_2.rgb)\u000a    if thisTrial_2 != None:\u000a        for paramName in thisTrial_2.keys():\u000a            exec(paramName + '= thisTrial_2.' + paramName)\u000a\u000a    for thisTrial_2 in trials_2:\u000a        currentLoop = trials_2\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_2.rgb)\u000a        if thisTrial_2 != None:\u000a            for paramName in thisTrial_2.keys():\u000a                exec(paramName + '= thisTrial_2.' + paramName)\u000a        \u000a        #------Prepare to start Routine "ButtonPractice_MIDDLE"-------\u000a        t = 0\u000a        ButtonPractice_MIDDLEClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(20.000000)\u000a        # update component parameters for each repeat\u000a        UpperText_15.setText('')\u000a        UpperBrackets_15.setText('')\u000a        LowerText_15.setText('')\u000a        key_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_3.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        ButtonPractice_MIDDLEComponents = []\u000a        ButtonPractice_MIDDLEComponents.append(text_29)\u000a        ButtonPractice_MIDDLEComponents.append(ISI_15)\u000a        ButtonPractice_MIDDLEComponents.append(TopUpperLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(UpperText_15)\u000a        ButtonPractice_MIDDLEComponents.append(UpperBrackets_15)\u000a        ButtonPractice_MIDDLEComponents.append(BotUpperLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(TopLowerLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(LowerText_15)\u000a        ButtonPractice_MIDDLEComponents.append(LowerBrackets_15)\u000a        ButtonPractice_MIDDLEComponents.append(BotLowerLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(TrialCrossHair_15)\u000a        ButtonPractice_MIDDLEComponents.append(RestCrossHair_15)\u000a        ButtonPractice_MIDDLEComponents.append(key_resp_3)\u000a        for thisComponent in ButtonPractice_MIDDLEComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "ButtonPractice_MIDDLE"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = ButtonPractice_MIDDLEClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_29* updates\u000a            if t >= 0 and text_29.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_29.tStart = t  # underestimates by a little under one frame\u000a                text_29.frameNStart = frameN  # exact frame index\u000a                text_29.setAutoDraw(True)\u000a            elif text_29.status == STARTED and t >= (0 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_29.setAutoDraw(False)\u000a            \u000a            # *TopUpperLine_15* updates\u000a            if t >= 0 and TopUpperLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine_15.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine_15.frameNStart = frameN  # exact frame index\u000a                TopUpperLine_15.setAutoDraw(True)\u000a            elif TopUpperLine_15.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine_15.setAutoDraw(False)\u000a            \u000a            # *UpperText_15* updates\u000a            if t >= 0 and UpperText_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText_15.tStart = t  # underestimates by a little under one frame\u000a                UpperText_15.frameNStart = frameN  # exact frame index\u000a                UpperText_15.setAutoDraw(True)\u000a            elif UpperText_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText_15.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets_15* updates\u000a            if t >= 0 and UpperBrackets_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets_15.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets_15.frameNStart = frameN  # exact frame index\u000a                UpperBrackets_15.setAutoDraw(True)\u000a            elif UpperBrackets_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets_15.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine_15* updates\u000a            if t >= 0.0 and BotUpperLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine_15.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine_15.frameNStart = frameN  # exact frame index\u000a                BotUpperLine_15.setAutoDraw(True)\u000a            elif BotUpperLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine_15.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine_15* updates\u000a            if t >= 0.0 and TopLowerLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine_15.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine_15.frameNStart = frameN  # exact frame index\u000a                TopLowerLine_15.setAutoDraw(True)\u000a            elif TopLowerLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine_15.setAutoDraw(False)\u000a            \u000a            # *LowerText_15* updates\u000a            if t >= 0 and LowerText_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText_15.tStart = t  # underestimates by a little under one frame\u000a                LowerText_15.frameNStart = frameN  # exact frame index\u000a                LowerText_15.setAutoDraw(True)\u000a            elif LowerText_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText_15.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets_15* updates\u000a            if t >= 0 and LowerBrackets_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets_15.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets_15.frameNStart = frameN  # exact frame index\u000a                LowerBrackets_15.setAutoDraw(True)\u000a            elif LowerBrackets_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets_15.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine_15* updates\u000a            if t >= 0.0 and BotLowerLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine_15.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine_15.frameNStart = frameN  # exact frame index\u000a                BotLowerLine_15.setAutoDraw(True)\u000a            elif BotLowerLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine_15.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair_15* updates\u000a            if t >= 0 and TrialCrossHair_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair_15.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair_15.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair_15.setAutoDraw(True)\u000a            elif TrialCrossHair_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair_15.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair_15* updates\u000a            if t >= 0 and RestCrossHair_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair_15.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair_15.frameNStart = frameN  # exact frame index\u000a                RestCrossHair_15.setAutoDraw(True)\u000a            elif RestCrossHair_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair_15.setAutoDraw(False)\u000a            \u000a            # *key_resp_3* updates\u000a            if t >= 0.0 and key_resp_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_3.tStart = t  # underestimates by a little under one frame\u000a                key_resp_3.frameNStart = frameN  # exact frame index\u000a                key_resp_3.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_3.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif key_resp_3.status == STARTED and t >= (0.0 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_3.status = STOPPED\u000a            if key_resp_3.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8', '9','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_3.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_3.rt = key_resp_3.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_3.keys == str('7')) or (key_resp_3.keys == 'right'):\u000a                        key_resp_3.corr = 1\u000a                    else:\u000a                        key_resp_3.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            # *ISI_15* period\u000a            if t >= 0.0 and ISI_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI_15.tStart = t  # underestimates by a little under one frame\u000a                ISI_15.frameNStart = frameN  # exact frame index\u000a                ISI_15.start(1)\u000a            elif ISI_15.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI_15.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in ButtonPractice_MIDDLEComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "ButtonPractice_MIDDLE"-------\u000a        for thisComponent in ButtonPractice_MIDDLEComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_3.keys in ['', [], None]:  # No response was made\u000a           key_resp_3.keys=None\u000a           # was no response the correct answer?!\u000a           if str('7').lower() == 'none': key_resp_3.corr = 1  # correct non-response\u000a           else: key_resp_3.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials_2 (TrialHandler)\u000a        trials_2.addData('key_resp_3.keys',key_resp_3.keys)\u000a        trials_2.addData('key_resp_3.corr', key_resp_3.corr)\u000a        if key_resp_3.keys != None:  # we had a response\u000a            trials_2.addData('key_resp_3.rt', key_resp_3.rt)\u000a        \u000a        #------Prepare to start Routine "Feedback_MIDDLE"-------\u000a        t = 0\u000a        Feedback_MIDDLEClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        if len(key_resp_3.keys)<1:\u000a            msg="Please press the RIGHT MIDDLE Finger button"\u000a            trials_2.finished = Falses\u000a        elif key_resp_3.corr:#stored on last run routine\u000a            msg="Good! That button indicates a NO response." \u000a            trials_2.finished = True\u000a        else:\u000a            msg="Oops! Wrong button, please try again."\u000a            trials_2.finished = False\u000a        text_26.setText(msg)\u000a        # keep track of which components have finished\u000a        Feedback_MIDDLEComponents = []\u000a        Feedback_MIDDLEComponents.append(text_26)\u000a        for thisComponent in Feedback_MIDDLEComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback_MIDDLE"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = Feedback_MIDDLEClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_26* updates\u000a            if t >= 0.0 and text_26.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_26.tStart = t  # underestimates by a little under one frame\u000a                text_26.frameNStart = frameN  # exact frame index\u000a                text_26.setAutoDraw(True)\u000a            elif text_26.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_26.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Feedback_MIDDLEComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback_MIDDLE"-------\u000a        for thisComponent in Feedback_MIDDLEComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 10 repeats of 'trials_2'\u000a\u000a\u000a    #------Prepare to start Routine "var_6Letters_2"-------\u000a    t = 0\u000a    var_6Letters_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(20.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_13.setText('')\u000a    UpperBrackets_13.setText('')\u000a    LowerText_13.setText('')\u000a    # keep track of which components have finished\u000a    var_6Letters_2Components = []\u000a    var_6Letters_2Components.append(text_13)\u000a    var_6Letters_2Components.append(text_16)\u000a    var_6Letters_2Components.append(text_18)\u000a    var_6Letters_2Components.append(text_21)\u000a    var_6Letters_2Components.append(ISI_13)\u000a    var_6Letters_2Components.append(TopUpperLine_13)\u000a    var_6Letters_2Components.append(UpperText_13)\u000a    var_6Letters_2Components.append(UpperBrackets_13)\u000a    var_6Letters_2Components.append(BotUpperLine_13)\u000a    var_6Letters_2Components.append(TopLowerLine_13)\u000a    var_6Letters_2Components.append(LowerText_13)\u000a    var_6Letters_2Components.append(LowerBrackets_13)\u000a    var_6Letters_2Components.append(BotLowerLine_13)\u000a    var_6Letters_2Components.append(TrialCrossHair_13)\u000a    var_6Letters_2Components.append(RestCrossHair_13)\u000a    var_6Letters_2Components.append(text_22)\u000a    var_6Letters_2Components.append(text_23)\u000a    var_6Letters_2Components.append(text_24)\u000a    for thisComponent in var_6Letters_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_13* updates\u000a        if t >= 0.0 and text_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_13.tStart = t  # underestimates by a little under one frame\u000a            text_13.frameNStart = frameN  # exact frame index\u000a            text_13.setAutoDraw(True)\u000a        elif text_13.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_13.setAutoDraw(False)\u000a        \u000a        # *text_16* updates\u000a        if t >= 3 and text_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_16.tStart = t  # underestimates by a little under one frame\u000a            text_16.frameNStart = frameN  # exact frame index\u000a            text_16.setAutoDraw(True)\u000a        elif text_16.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_16.setAutoDraw(False)\u000a        \u000a        # *text_18* updates\u000a        if t >= 6 and text_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_18.tStart = t  # underestimates by a little under one frame\u000a            text_18.frameNStart = frameN  # exact frame index\u000a            text_18.setAutoDraw(True)\u000a        elif text_18.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_18.setAutoDraw(False)\u000a        \u000a        # *text_21* updates\u000a        if t >= 0 and text_21.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_21.tStart = t  # underestimates by a little under one frame\u000a            text_21.frameNStart = frameN  # exact frame index\u000a            text_21.setAutoDraw(True)\u000a        elif text_21.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_21.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_13* updates\u000a        if t >= 0 and TopUpperLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_13.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_13.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_13.setAutoDraw(True)\u000a        elif TopUpperLine_13.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_13.setAutoDraw(False)\u000a        \u000a        # *UpperText_13* updates\u000a        if t >= 0 and UpperText_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_13.tStart = t  # underestimates by a little under one frame\u000a            UpperText_13.frameNStart = frameN  # exact frame index\u000a            UpperText_13.setAutoDraw(True)\u000a        elif UpperText_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_13.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_13* updates\u000a        if t >= 0 and UpperBrackets_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_13.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_13.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_13.setAutoDraw(True)\u000a        elif UpperBrackets_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_13.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_13* updates\u000a        if t >= 0.0 and BotUpperLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_13.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_13.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_13.setAutoDraw(True)\u000a        elif BotUpperLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_13.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_13* updates\u000a        if t >= 0.0 and TopLowerLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_13.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_13.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_13.setAutoDraw(True)\u000a        elif TopLowerLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_13.setAutoDraw(False)\u000a        \u000a        # *LowerText_13* updates\u000a        if t >= 0 and LowerText_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_13.tStart = t  # underestimates by a little under one frame\u000a            LowerText_13.frameNStart = frameN  # exact frame index\u000a            LowerText_13.setAutoDraw(True)\u000a        elif LowerText_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_13.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_13* updates\u000a        if t >= 0 and LowerBrackets_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_13.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_13.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_13.setAutoDraw(True)\u000a        elif LowerBrackets_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_13.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_13* updates\u000a        if t >= 0.0 and BotLowerLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_13.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_13.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_13.setAutoDraw(True)\u000a        elif BotLowerLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_13.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_13* updates\u000a        if t >= 12 and TrialCrossHair_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_13.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_13.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_13.setAutoDraw(True)\u000a        elif TrialCrossHair_13.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_13.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_13* updates\u000a        if t >= 15 and RestCrossHair_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_13.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_13.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_13.setAutoDraw(True)\u000a        elif RestCrossHair_13.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_13.setAutoDraw(False)\u000a        \u000a        # *text_22* updates\u000a        if t >= 9 and text_22.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_22.tStart = t  # underestimates by a little under one frame\u000a            text_22.frameNStart = frameN  # exact frame index\u000a            text_22.setAutoDraw(True)\u000a        elif text_22.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_22.setAutoDraw(False)\u000a        \u000a        # *text_23* updates\u000a        if t >= 12 and text_23.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_23.tStart = t  # underestimates by a little under one frame\u000a            text_23.frameNStart = frameN  # exact frame index\u000a            text_23.setAutoDraw(True)\u000a        elif text_23.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_23.setAutoDraw(False)\u000a        \u000a        # *text_24* updates\u000a        if t >= 15 and text_24.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_24.tStart = t  # underestimates by a little under one frame\u000a            text_24.frameNStart = frameN  # exact frame index\u000a            text_24.setAutoDraw(True)\u000a        elif text_24.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_24.setAutoDraw(False)\u000a        # *ISI_13* period\u000a        if t >= 0.0 and ISI_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_13.tStart = t  # underestimates by a little under one frame\u000a            ISI_13.frameNStart = frameN  # exact frame index\u000a            ISI_13.start(1)\u000a        elif ISI_13.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_13.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_2"-------\u000a    for thisComponent in var_6Letters_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "var_6Letters_0"-------\u000a    t = 0\u000a    var_6Letters_0Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(30.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_11.setText(' A B C D E F ')\u000a    UpperBrackets_11.setText('  {   }      ')\u000a    LowerText_11.setText(' a b c d e f ')\u000a    KeyboardResp_11 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_11.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    var_6Letters_0Components = []\u000a    var_6Letters_0Components.append(text_2)\u000a    var_6Letters_0Components.append(text)\u000a    var_6Letters_0Components.append(text_6)\u000a    var_6Letters_0Components.append(text_4)\u000a    var_6Letters_0Components.append(ISI_11)\u000a    var_6Letters_0Components.append(TopUpperLine_11)\u000a    var_6Letters_0Components.append(UpperText_11)\u000a    var_6Letters_0Components.append(UpperBrackets_11)\u000a    var_6Letters_0Components.append(BotUpperLine_11)\u000a    var_6Letters_0Components.append(TopLowerLine_11)\u000a    var_6Letters_0Components.append(LowerText_11)\u000a    var_6Letters_0Components.append(LowerBrackets_11)\u000a    var_6Letters_0Components.append(BotLowerLine_11)\u000a    var_6Letters_0Components.append(TrialCrossHair_11)\u000a    var_6Letters_0Components.append(RestCrossHair_11)\u000a    var_6Letters_0Components.append(KeyboardResp_11)\u000a    var_6Letters_0Components.append(text_5)\u000a    var_6Letters_0Components.append(text_7)\u000a    var_6Letters_0Components.append(text_8)\u000a    var_6Letters_0Components.append(text_9)\u000a    var_6Letters_0Components.append(text_10)\u000a    for thisComponent in var_6Letters_0Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_0"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_0Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_2* updates\u000a        if t >= 0.0 and text_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_2.tStart = t  # underestimates by a little under one frame\u000a            text_2.frameNStart = frameN  # exact frame index\u000a            text_2.setAutoDraw(True)\u000a        elif text_2.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_2.setAutoDraw(False)\u000a        \u000a        # *text* updates\u000a        if t >= 3 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        elif text.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # *text_6* updates\u000a        if t >= 6 and text_6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_6.tStart = t  # underestimates by a little under one frame\u000a            text_6.frameNStart = frameN  # exact frame index\u000a            text_6.setAutoDraw(True)\u000a        elif text_6.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_6.setAutoDraw(False)\u000a        \u000a        # *text_4* updates\u000a        if t >= 9 and text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_4.tStart = t  # underestimates by a little under one frame\u000a            text_4.frameNStart = frameN  # exact frame index\u000a            text_4.setAutoDraw(True)\u000a        elif text_4.status == STARTED and t >= (9 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_4.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_11* updates\u000a        if t >= 0 and TopUpperLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_11.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_11.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_11.setAutoDraw(True)\u000a        elif TopUpperLine_11.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_11.setAutoDraw(False)\u000a        \u000a        # *UpperText_11* updates\u000a        if t >= 0 and UpperText_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_11.tStart = t  # underestimates by a little under one frame\u000a            UpperText_11.frameNStart = frameN  # exact frame index\u000a            UpperText_11.setAutoDraw(True)\u000a        elif UpperText_11.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_11.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_11* updates\u000a        if t >= 3 and UpperBrackets_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_11.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_11.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_11.setAutoDraw(True)\u000a        elif UpperBrackets_11.status == STARTED and t >= (3 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_11.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_11* updates\u000a        if t >= 0.0 and BotUpperLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_11.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_11.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_11.setAutoDraw(True)\u000a        elif BotUpperLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_11.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_11* updates\u000a        if t >= 0.0 and TopLowerLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_11.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_11.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_11.setAutoDraw(True)\u000a        elif TopLowerLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_11.setAutoDraw(False)\u000a        \u000a        # *LowerText_11* updates\u000a        if t >= 14 and LowerText_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_11.tStart = t  # underestimates by a little under one frame\u000a            LowerText_11.frameNStart = frameN  # exact frame index\u000a            LowerText_11.setAutoDraw(True)\u000a        elif LowerText_11.status == STARTED and t >= (14 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_11.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_11* updates\u000a        if t >= 17 and LowerBrackets_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_11.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_11.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_11.setAutoDraw(True)\u000a        elif LowerBrackets_11.status == STARTED and t >= (17 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_11.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_11* updates\u000a        if t >= 0.0 and BotLowerLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_11.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_11.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_11.setAutoDraw(True)\u000a        elif BotLowerLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_11.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_11* updates\u000a        if t >= 0 and TrialCrossHair_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_11.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_11.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_11.setAutoDraw(True)\u000a        elif TrialCrossHair_11.status == STARTED and t >= (0 + (26-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_11.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_11* updates\u000a        if t >= 26 and RestCrossHair_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_11.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_11.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_11.setAutoDraw(True)\u000a        elif RestCrossHair_11.status == STARTED and t >= (26 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_11.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_11* updates\u000a        if t >= 0 and KeyboardResp_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_11.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_11.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_11.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_11.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_11.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_11.status = STOPPED\u000a        if KeyboardResp_11.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_11.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_11.rt.append(KeyboardResp_11.clock.getTime())\u000a        \u000a        # *text_5* updates\u000a        if t >= 14 and text_5.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_5.tStart = t  # underestimates by a little under one frame\u000a            text_5.frameNStart = frameN  # exact frame index\u000a            text_5.setAutoDraw(True)\u000a        elif text_5.status == STARTED and t >= (14 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_5.setAutoDraw(False)\u000a        \u000a        # *text_7* updates\u000a        if t >= 17 and text_7.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_7.tStart = t  # underestimates by a little under one frame\u000a            text_7.frameNStart = frameN  # exact frame index\u000a            text_7.setAutoDraw(True)\u000a        elif text_7.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_7.setAutoDraw(False)\u000a        \u000a        # *text_8* updates\u000a        if t >= 20 and text_8.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_8.tStart = t  # underestimates by a little under one frame\u000a            text_8.frameNStart = frameN  # exact frame index\u000a            text_8.setAutoDraw(True)\u000a        elif text_8.status == STARTED and t >= (20 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_8.setAutoDraw(False)\u000a        \u000a        # *text_9* updates\u000a        if t >= 23 and text_9.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_9.tStart = t  # underestimates by a little under one frame\u000a            text_9.frameNStart = frameN  # exact frame index\u000a            text_9.setAutoDraw(True)\u000a        elif text_9.status == STARTED and t >= (23 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_9.setAutoDraw(False)\u000a        \u000a        # *text_10* updates\u000a        if t >= 26 and text_10.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_10.tStart = t  # underestimates by a little under one frame\u000a            text_10.frameNStart = frameN  # exact frame index\u000a            text_10.setAutoDraw(True)\u000a        elif text_10.status == STARTED and t >= (26 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_10.setAutoDraw(False)\u000a        # *ISI_11* period\u000a        if t >= 0.0 and ISI_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_11.tStart = t  # underestimates by a little under one frame\u000a            ISI_11.frameNStart = frameN  # exact frame index\u000a            ISI_11.start(1)\u000a        elif ISI_11.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_11.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_0Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_0"-------\u000a    for thisComponent in var_6Letters_0Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_11.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_11.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_11.keys',KeyboardResp_11.keys)\u000a    if KeyboardResp_11.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_11.rt', KeyboardResp_11.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "var_6Letters_1"-------\u000a    t = 0\u000a    var_6Letters_1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(22.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_12.setText(' A B C D E F ')\u000a    UpperBrackets_12.setText('  {   }      ')\u000a    LowerText_12.setText(u' a b c d e f ')\u000a    KeyboardResp_12 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_12.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    var_6Letters_1Components = []\u000a    var_6Letters_1Components.append(text_11)\u000a    var_6Letters_1Components.append(text_12)\u000a    var_6Letters_1Components.append(text_14)\u000a    var_6Letters_1Components.append(ISI_12)\u000a    var_6Letters_1Components.append(TopUpperLine_12)\u000a    var_6Letters_1Components.append(UpperText_12)\u000a    var_6Letters_1Components.append(UpperBrackets_12)\u000a    var_6Letters_1Components.append(BotUpperLine_12)\u000a    var_6Letters_1Components.append(TopLowerLine_12)\u000a    var_6Letters_1Components.append(LowerText_12)\u000a    var_6Letters_1Components.append(LowerBrackets_12)\u000a    var_6Letters_1Components.append(BotLowerLine_12)\u000a    var_6Letters_1Components.append(TrialCrossHair_12)\u000a    var_6Letters_1Components.append(RestCrossHair_12)\u000a    var_6Letters_1Components.append(KeyboardResp_12)\u000a    var_6Letters_1Components.append(text_17)\u000a    var_6Letters_1Components.append(text_19)\u000a    var_6Letters_1Components.append(text_20)\u000a    for thisComponent in var_6Letters_1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_11* updates\u000a        if t >= 0.0 and text_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_11.tStart = t  # underestimates by a little under one frame\u000a            text_11.frameNStart = frameN  # exact frame index\u000a            text_11.setAutoDraw(True)\u000a        elif text_11.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_11.setAutoDraw(False)\u000a        \u000a        # *text_12* updates\u000a        if t >= 3 and text_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_12.tStart = t  # underestimates by a little under one frame\u000a            text_12.frameNStart = frameN  # exact frame index\u000a            text_12.setAutoDraw(True)\u000a        elif text_12.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_12.setAutoDraw(False)\u000a        \u000a        # *text_14* updates\u000a        if t >= 6 and text_14.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_14.tStart = t  # underestimates by a little under one frame\u000a            text_14.frameNStart = frameN  # exact frame index\u000a            text_14.setAutoDraw(True)\u000a        elif text_14.status == STARTED and t >= (6 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_14.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_12* updates\u000a        if t >= 0 and TopUpperLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_12.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_12.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_12.setAutoDraw(True)\u000a        elif TopUpperLine_12.status == STARTED and t >= (0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_12.setAutoDraw(False)\u000a        \u000a        # *UpperText_12* updates\u000a        if t >= 0 and UpperText_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_12.tStart = t  # underestimates by a little under one frame\u000a            UpperText_12.frameNStart = frameN  # exact frame index\u000a            UpperText_12.setAutoDraw(True)\u000a        elif UpperText_12.status == STARTED and t >= (0 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_12.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_12* updates\u000a        if t >= 3 and UpperBrackets_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_12.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_12.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_12.setAutoDraw(True)\u000a        elif UpperBrackets_12.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_12.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_12* updates\u000a        if t >= 0.0 and BotUpperLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_12.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_12.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_12.setAutoDraw(True)\u000a        elif BotUpperLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_12.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_12* updates\u000a        if t >= 0.0 and TopLowerLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_12.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_12.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_12.setAutoDraw(True)\u000a        elif TopLowerLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_12.setAutoDraw(False)\u000a        \u000a        # *LowerText_12* updates\u000a        if t >= 11 and LowerText_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_12.tStart = t  # underestimates by a little under one frame\u000a            LowerText_12.frameNStart = frameN  # exact frame index\u000a            LowerText_12.setAutoDraw(True)\u000a        elif LowerText_12.status == STARTED and t >= (11 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_12.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_12* updates\u000a        if t >= 11 and LowerBrackets_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_12.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_12.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_12.setAutoDraw(True)\u000a        elif LowerBrackets_12.status == STARTED and t >= (11 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_12.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_12* updates\u000a        if t >= 0.0 and BotLowerLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_12.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_12.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_12.setAutoDraw(True)\u000a        elif BotLowerLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_12.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_12* updates\u000a        if t >= 0 and TrialCrossHair_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_12.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_12.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_12.setAutoDraw(True)\u000a        elif TrialCrossHair_12.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_12.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_12* updates\u000a        if t >= 17 and RestCrossHair_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_12.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_12.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_12.setAutoDraw(True)\u000a        elif RestCrossHair_12.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_12.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_12* updates\u000a        if t >= 0 and KeyboardResp_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_12.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_12.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_12.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_12.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_12.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_12.status = STOPPED\u000a        if KeyboardResp_12.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_12.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_12.rt.append(KeyboardResp_12.clock.getTime())\u000a        \u000a        # *text_17* updates\u000a        if t >= 11 and text_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_17.tStart = t  # underestimates by a little under one frame\u000a            text_17.frameNStart = frameN  # exact frame index\u000a            text_17.setAutoDraw(True)\u000a        elif text_17.status == STARTED and t >= (11 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_17.setAutoDraw(False)\u000a        \u000a        # *text_19* updates\u000a        if t >= 14 and text_19.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_19.tStart = t  # underestimates by a little under one frame\u000a            text_19.frameNStart = frameN  # exact frame index\u000a            text_19.setAutoDraw(True)\u000a        elif text_19.status == STARTED and t >= (14 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_19.setAutoDraw(False)\u000a        \u000a        # *text_20* updates\u000a        if t >= 17 and text_20.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_20.tStart = t  # underestimates by a little under one frame\u000a            text_20.frameNStart = frameN  # exact frame index\u000a            text_20.setAutoDraw(True)\u000a        elif text_20.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_20.setAutoDraw(False)\u000a        # *ISI_12* period\u000a        if t >= 0.0 and ISI_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_12.tStart = t  # underestimates by a little under one frame\u000a            ISI_12.frameNStart = frameN  # exact frame index\u000a            ISI_12.start(1)\u000a        elif ISI_12.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_12.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_1"-------\u000a    for thisComponent in var_6Letters_1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_12.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_12.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_12.keys',KeyboardResp_12.keys)\u000a    if KeyboardResp_12.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_12.rt', KeyboardResp_12.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "DemoTrialRealTimes"-------\u000a    t = 0\u000a    DemoTrialRealTimesClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(17.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_18.setText(u' A B C D E F ')\u000a    UpperBrackets_18.setText(u'  {   }      ')\u000a    LowerText_17.setText(u' a b c d e f ')\u000a    KeyboardResp_13 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_13.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    DemoTrialRealTimesComponents = []\u000a    DemoTrialRealTimesComponents.append(text_44)\u000a    DemoTrialRealTimesComponents.append(text_45)\u000a    DemoTrialRealTimesComponents.append(text_46)\u000a    DemoTrialRealTimesComponents.append(ISI_18)\u000a    DemoTrialRealTimesComponents.append(TopUpperLine_18)\u000a    DemoTrialRealTimesComponents.append(UpperText_18)\u000a    DemoTrialRealTimesComponents.append(UpperBrackets_18)\u000a    DemoTrialRealTimesComponents.append(BotUpperLine_18)\u000a    DemoTrialRealTimesComponents.append(TopLowerLine_18)\u000a    DemoTrialRealTimesComponents.append(LowerText_17)\u000a    DemoTrialRealTimesComponents.append(LowerBrackets_17)\u000a    DemoTrialRealTimesComponents.append(BotLowerLine_18)\u000a    DemoTrialRealTimesComponents.append(TrialCrossHair_18)\u000a    DemoTrialRealTimesComponents.append(RestCrossHair_18)\u000a    DemoTrialRealTimesComponents.append(KeyboardResp_13)\u000a    DemoTrialRealTimesComponents.append(text_48)\u000a    DemoTrialRealTimesComponents.append(text_49)\u000a    for thisComponent in DemoTrialRealTimesComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "DemoTrialRealTimes"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = DemoTrialRealTimesClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_44* updates\u000a        if t >= 0.0 and text_44.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_44.tStart = t  # underestimates by a little under one frame\u000a            text_44.frameNStart = frameN  # exact frame index\u000a            text_44.setAutoDraw(True)\u000a        elif text_44.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_44.setAutoDraw(False)\u000a        \u000a        # *text_45* updates\u000a        if t >= 3 and text_45.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_45.tStart = t  # underestimates by a little under one frame\u000a            text_45.frameNStart = frameN  # exact frame index\u000a            text_45.setAutoDraw(True)\u000a        elif text_45.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_45.setAutoDraw(False)\u000a        \u000a        # *text_46* updates\u000a        if t >= 5 and text_46.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_46.tStart = t  # underestimates by a little under one frame\u000a            text_46.frameNStart = frameN  # exact frame index\u000a            text_46.setAutoDraw(True)\u000a        elif text_46.status == STARTED and t >= (5 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_46.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_18* updates\u000a        if t >= 0 and TopUpperLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_18.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_18.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_18.setAutoDraw(True)\u000a        elif TopUpperLine_18.status == STARTED and t >= (0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_18.setAutoDraw(False)\u000a        \u000a        # *UpperText_18* updates\u000a        if t >= 3 and UpperText_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_18.tStart = t  # underestimates by a little under one frame\u000a            UpperText_18.frameNStart = frameN  # exact frame index\u000a            UpperText_18.setAutoDraw(True)\u000a        elif UpperText_18.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_18.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_18* updates\u000a        if t >= 3 and UpperBrackets_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_18.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_18.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_18.setAutoDraw(True)\u000a        elif UpperBrackets_18.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_18.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_18* updates\u000a        if t >= 0.0 and BotUpperLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_18.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_18.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_18.setAutoDraw(True)\u000a        elif BotUpperLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_18.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_18* updates\u000a        if t >= 0.0 and TopLowerLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_18.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_18.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_18.setAutoDraw(True)\u000a        elif TopLowerLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_18.setAutoDraw(False)\u000a        \u000a        # *LowerText_17* updates\u000a        if t >= 10 and LowerText_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_17.tStart = t  # underestimates by a little under one frame\u000a            LowerText_17.frameNStart = frameN  # exact frame index\u000a            LowerText_17.setAutoDraw(True)\u000a        elif LowerText_17.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_17.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_17* updates\u000a        if t >= 10 and LowerBrackets_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_17.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_17.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_17.setAutoDraw(True)\u000a        elif LowerBrackets_17.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_17.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_18* updates\u000a        if t >= 0.0 and BotLowerLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_18.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_18.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_18.setAutoDraw(True)\u000a        elif BotLowerLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_18.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_18* updates\u000a        if t >= 0 and TrialCrossHair_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_18.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_18.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_18.setAutoDraw(True)\u000a        elif TrialCrossHair_18.status == STARTED and t >= (0 + (12-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_18.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_18* updates\u000a        if t >= 12 and RestCrossHair_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_18.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_18.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_18.setAutoDraw(True)\u000a        elif RestCrossHair_18.status == STARTED and t >= (12 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_18.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_13* updates\u000a        if t >= 0 and KeyboardResp_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_13.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_13.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_13.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_13.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_13.status = STOPPED\u000a        if KeyboardResp_13.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_13.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_13.rt.append(KeyboardResp_13.clock.getTime())\u000a        \u000a        # *text_48* updates\u000a        if t >= 10 and text_48.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_48.tStart = t  # underestimates by a little under one frame\u000a            text_48.frameNStart = frameN  # exact frame index\u000a            text_48.setAutoDraw(True)\u000a        elif text_48.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_48.setAutoDraw(False)\u000a        \u000a        # *text_49* updates\u000a        if t >= 12 and text_49.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_49.tStart = t  # underestimates by a little under one frame\u000a            text_49.frameNStart = frameN  # exact frame index\u000a            text_49.setAutoDraw(True)\u000a        elif text_49.status == STARTED and t >= (12 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_49.setAutoDraw(False)\u000a        # *ISI_18* period\u000a        if t >= 0.0 and ISI_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_18.tStart = t  # underestimates by a little under one frame\u000a            ISI_18.frameNStart = frameN  # exact frame index\u000a            ISI_18.start(1)\u000a        elif ISI_18.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_18.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in DemoTrialRealTimesComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "DemoTrialRealTimes"-------\u000a    for thisComponent in DemoTrialRealTimesComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_13.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_13.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_13.keys',KeyboardResp_13.keys)\u000a    if KeyboardResp_13.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_13.rt', KeyboardResp_13.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "NumLettersToRem"-------\u000a    t = 0\u000a    NumLettersToRemClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(30.000000)\u000a    # update component parameters for each repeat\u000a    UpBrack1.setText('        { }  ')\u000a    UpperText_17.setText(' A B C D E F ')\u000a    UpperBrackets_17.setText('')\u000a    # keep track of which components have finished\u000a    NumLettersToRemComponents = []\u000a    NumLettersToRemComponents.append(text_15)\u000a    NumLettersToRemComponents.append(text_33)\u000a    NumLettersToRemComponents.append(text_34)\u000a    NumLettersToRemComponents.append(text_3)\u000a    NumLettersToRemComponents.append(text_35)\u000a    NumLettersToRemComponents.append(UpBrack1)\u000a    NumLettersToRemComponents.append(ISI_17)\u000a    NumLettersToRemComponents.append(TopUpperLine_17)\u000a    NumLettersToRemComponents.append(UpperText_17)\u000a    NumLettersToRemComponents.append(UpperBrackets_17)\u000a    NumLettersToRemComponents.append(BotUpperLine_17)\u000a    NumLettersToRemComponents.append(TopLowerLine_17)\u000a    NumLettersToRemComponents.append(BotLowerLine_17)\u000a    NumLettersToRemComponents.append(TrialCrossHair_17)\u000a    NumLettersToRemComponents.append(RestCrossHair_17)\u000a    NumLettersToRemComponents.append(UpBrack2)\u000a    NumLettersToRemComponents.append(UpBrack3)\u000a    NumLettersToRemComponents.append(UpBrack4)\u000a    NumLettersToRemComponents.append(UpBrack5)\u000a    NumLettersToRemComponents.append(UpBrack6)\u000a    NumLettersToRemComponents.append(text_38)\u000a    NumLettersToRemComponents.append(text_39)\u000a    NumLettersToRemComponents.append(text_40)\u000a    NumLettersToRemComponents.append(text_41)\u000a    NumLettersToRemComponents.append(text_42)\u000a    NumLettersToRemComponents.append(text_43)\u000a    for thisComponent in NumLettersToRemComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "NumLettersToRem"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = NumLettersToRemClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_15* updates\u000a        if t >= 0.0 and text_15.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_15.tStart = t  # underestimates by a little under one frame\u000a            text_15.frameNStart = frameN  # exact frame index\u000a            text_15.setAutoDraw(True)\u000a        elif text_15.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_15.setAutoDraw(False)\u000a        \u000a        # *text_33* updates\u000a        if t >= 3 and text_33.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_33.tStart = t  # underestimates by a little under one frame\u000a            text_33.frameNStart = frameN  # exact frame index\u000a            text_33.setAutoDraw(True)\u000a        elif text_33.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_33.setAutoDraw(False)\u000a        \u000a        # *text_34* updates\u000a        if t >= 6 and text_34.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_34.tStart = t  # underestimates by a little under one frame\u000a            text_34.frameNStart = frameN  # exact frame index\u000a            text_34.setAutoDraw(True)\u000a        elif text_34.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_34.setAutoDraw(False)\u000a        \u000a        # *text_3* updates\u000a        if t >= 9 and text_3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_3.tStart = t  # underestimates by a little under one frame\u000a            text_3.frameNStart = frameN  # exact frame index\u000a            text_3.setAutoDraw(True)\u000a        elif text_3.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_3.setAutoDraw(False)\u000a        \u000a        # *text_35* updates\u000a        if t >= 12 and text_35.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_35.tStart = t  # underestimates by a little under one frame\u000a            text_35.frameNStart = frameN  # exact frame index\u000a            text_35.setAutoDraw(True)\u000a        elif text_35.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_35.setAutoDraw(False)\u000a        \u000a        # *UpBrack1* updates\u000a        if t >= 15 and UpBrack1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack1.tStart = t  # underestimates by a little under one frame\u000a            UpBrack1.frameNStart = frameN  # exact frame index\u000a            UpBrack1.setAutoDraw(True)\u000a        elif UpBrack1.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack1.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_17* updates\u000a        if t >= 0 and TopUpperLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_17.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_17.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_17.setAutoDraw(True)\u000a        elif TopUpperLine_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_17.setAutoDraw(False)\u000a        \u000a        # *UpperText_17* updates\u000a        if t >= 0 and UpperText_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_17.tStart = t  # underestimates by a little under one frame\u000a            UpperText_17.frameNStart = frameN  # exact frame index\u000a            UpperText_17.setAutoDraw(True)\u000a        elif UpperText_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_17.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_17* updates\u000a        if t >= 0.0 and UpperBrackets_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_17.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_17.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_17.setAutoDraw(True)\u000a        elif UpperBrackets_17.status == STARTED and t >= (0.0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_17.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_17* updates\u000a        if t >= 0.0 and BotUpperLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_17.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_17.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_17.setAutoDraw(True)\u000a        elif BotUpperLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_17.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_17* updates\u000a        if t >= 0.0 and TopLowerLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_17.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_17.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_17.setAutoDraw(True)\u000a        elif TopLowerLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_17.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_17* updates\u000a        if t >= 0.0 and BotLowerLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_17.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_17.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_17.setAutoDraw(True)\u000a        elif BotLowerLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_17.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_17* updates\u000a        if t >= 0 and TrialCrossHair_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_17.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_17.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_17.setAutoDraw(True)\u000a        elif TrialCrossHair_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_17.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_17* updates\u000a        if t >= 0.0 and RestCrossHair_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_17.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_17.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_17.setAutoDraw(True)\u000a        elif RestCrossHair_17.status == STARTED and t >= (0.0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_17.setAutoDraw(False)\u000a        \u000a        # *UpBrack2* updates\u000a        if t >= 18 and UpBrack2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack2.tStart = t  # underestimates by a little under one frame\u000a            UpBrack2.frameNStart = frameN  # exact frame index\u000a            UpBrack2.setAutoDraw(True)\u000a        elif UpBrack2.status == STARTED and t >= (18 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack2.setAutoDraw(False)\u000a        \u000a        # *UpBrack3* updates\u000a        if t >= 20 and UpBrack3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack3.tStart = t  # underestimates by a little under one frame\u000a            UpBrack3.frameNStart = frameN  # exact frame index\u000a            UpBrack3.setAutoDraw(True)\u000a        elif UpBrack3.status == STARTED and t >= (20 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack3.setAutoDraw(False)\u000a        \u000a        # *UpBrack4* updates\u000a        if t >= 22 and UpBrack4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack4.tStart = t  # underestimates by a little under one frame\u000a            UpBrack4.frameNStart = frameN  # exact frame index\u000a            UpBrack4.setAutoDraw(True)\u000a        elif UpBrack4.status == STARTED and t >= (22 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack4.setAutoDraw(False)\u000a        \u000a        # *UpBrack5* updates\u000a        if t >= 24 and UpBrack5.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack5.tStart = t  # underestimates by a little under one frame\u000a            UpBrack5.frameNStart = frameN  # exact frame index\u000a            UpBrack5.setAutoDraw(True)\u000a        elif UpBrack5.status == STARTED and t >= (24 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack5.setAutoDraw(False)\u000a        \u000a        # *UpBrack6* updates\u000a        if t >= 26 and UpBrack6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack6.tStart = t  # underestimates by a little under one frame\u000a            UpBrack6.frameNStart = frameN  # exact frame index\u000a            UpBrack6.setAutoDraw(True)\u000a        elif UpBrack6.status == STARTED and t >= (26 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack6.setAutoDraw(False)\u000a        \u000a        # *text_38* updates\u000a        if t >= 15 and text_38.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_38.tStart = t  # underestimates by a little under one frame\u000a            text_38.frameNStart = frameN  # exact frame index\u000a            text_38.setAutoDraw(True)\u000a        elif text_38.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_38.setAutoDraw(False)\u000a        \u000a        # *text_39* updates\u000a        if t >= 18 and text_39.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_39.tStart = t  # underestimates by a little under one frame\u000a            text_39.frameNStart = frameN  # exact frame index\u000a            text_39.setAutoDraw(True)\u000a        elif text_39.status == STARTED and t >= (18 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_39.setAutoDraw(False)\u000a        \u000a        # *text_40* updates\u000a        if t >= 20 and text_40.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_40.tStart = t  # underestimates by a little under one frame\u000a            text_40.frameNStart = frameN  # exact frame index\u000a            text_40.setAutoDraw(True)\u000a        elif text_40.status == STARTED and t >= (20 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_40.setAutoDraw(False)\u000a        \u000a        # *text_41* updates\u000a        if t >= 22 and text_41.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_41.tStart = t  # underestimates by a little under one frame\u000a            text_41.frameNStart = frameN  # exact frame index\u000a            text_41.setAutoDraw(True)\u000a        elif text_41.status == STARTED and t >= (22 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_41.setAutoDraw(False)\u000a        \u000a        # *text_42* updates\u000a        if t >= 24 and text_42.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_42.tStart = t  # underestimates by a little under one frame\u000a            text_42.frameNStart = frameN  # exact frame index\u000a            text_42.setAutoDraw(True)\u000a        elif text_42.status == STARTED and t >= (24 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_42.setAutoDraw(False)\u000a        \u000a        # *text_43* updates\u000a        if t >= 26 and text_43.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_43.tStart = t  # underestimates by a little under one frame\u000a            text_43.frameNStart = frameN  # exact frame index\u000a            text_43.setAutoDraw(True)\u000a        elif text_43.status == STARTED and t >= (26 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_43.setAutoDraw(False)\u000a        # *ISI_17* period\u000a        if t >= 0.0 and ISI_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_17.tStart = t  # underestimates by a little under one frame\u000a            ISI_17.frameNStart = frameN  # exact frame index\u000a            ISI_17.start(1)\u000a        elif ISI_17.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_17.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in NumLettersToRemComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "NumLettersToRem"-------\u000a    for thisComponent in NumLettersToRemComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "TrialParts_1"-------\u000a    t = 0\u000a    TrialParts_1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(25.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_16.setText('')\u000a    UpperBrackets_16.setText('')\u000a    LowerText_16.setText('')\u000a    # keep track of which components have finished\u000a    TrialParts_1Components = []\u000a    TrialParts_1Components.append(text_27)\u000a    TrialParts_1Components.append(text_30)\u000a    TrialParts_1Components.append(text_31)\u000a    TrialParts_1Components.append(text_32)\u000a    TrialParts_1Components.append(ISI_16)\u000a    TrialParts_1Components.append(TopUpperLine_16)\u000a    TrialParts_1Components.append(UpperText_16)\u000a    TrialParts_1Components.append(UpperBrackets_16)\u000a    TrialParts_1Components.append(BotUpperLine_16)\u000a    TrialParts_1Components.append(TopLowerLine_16)\u000a    TrialParts_1Components.append(LowerText_16)\u000a    TrialParts_1Components.append(LowerBrackets_16)\u000a    TrialParts_1Components.append(BotLowerLine_16)\u000a    TrialParts_1Components.append(TrialCrossHair_16)\u000a    TrialParts_1Components.append(RestCrossHair_16)\u000a    TrialParts_1Components.append(text_36)\u000a    TrialParts_1Components.append(text_37)\u000a    TrialParts_1Components.append(text_50)\u000a    for thisComponent in TrialParts_1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialParts_1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialParts_1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_27* updates\u000a        if t >= 0.0 and text_27.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_27.tStart = t  # underestimates by a little under one frame\u000a            text_27.frameNStart = frameN  # exact frame index\u000a            text_27.setAutoDraw(True)\u000a        elif text_27.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_27.setAutoDraw(False)\u000a        \u000a        # *text_30* updates\u000a        if t >= 3 and text_30.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_30.tStart = t  # underestimates by a little under one frame\u000a            text_30.frameNStart = frameN  # exact frame index\u000a            text_30.setAutoDraw(True)\u000a        elif text_30.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_30.setAutoDraw(False)\u000a        \u000a        # *text_31* updates\u000a        if t >= 6 and text_31.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_31.tStart = t  # underestimates by a little under one frame\u000a            text_31.frameNStart = frameN  # exact frame index\u000a            text_31.setAutoDraw(True)\u000a        elif text_31.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_31.setAutoDraw(False)\u000a        \u000a        # *text_32* updates\u000a        if t >= 9 and text_32.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_32.tStart = t  # underestimates by a little under one frame\u000a            text_32.frameNStart = frameN  # exact frame index\u000a            text_32.setAutoDraw(True)\u000a        elif text_32.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_32.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_16* updates\u000a        if t >= 0 and TopUpperLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_16.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_16.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_16.setAutoDraw(True)\u000a        elif TopUpperLine_16.status == STARTED and t >= (0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_16.setAutoDraw(False)\u000a        \u000a        # *UpperText_16* updates\u000a        if t >= 0 and UpperText_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_16.tStart = t  # underestimates by a little under one frame\u000a            UpperText_16.frameNStart = frameN  # exact frame index\u000a            UpperText_16.setAutoDraw(True)\u000a        elif UpperText_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_16.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_16* updates\u000a        if t >= 0 and UpperBrackets_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_16.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_16.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_16.setAutoDraw(True)\u000a        elif UpperBrackets_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_16.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_16* updates\u000a        if t >= 0.0 and BotUpperLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_16.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_16.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_16.setAutoDraw(True)\u000a        elif BotUpperLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_16.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_16* updates\u000a        if t >= 0.0 and TopLowerLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_16.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_16.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_16.setAutoDraw(True)\u000a        elif TopLowerLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_16.setAutoDraw(False)\u000a        \u000a        # *LowerText_16* updates\u000a        if t >= 0 and LowerText_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_16.tStart = t  # underestimates by a little under one frame\u000a            LowerText_16.frameNStart = frameN  # exact frame index\u000a            LowerText_16.setAutoDraw(True)\u000a        elif LowerText_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_16.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_16* updates\u000a        if t >= 0 and LowerBrackets_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_16.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_16.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_16.setAutoDraw(True)\u000a        elif LowerBrackets_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_16.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_16* updates\u000a        if t >= 0.0 and BotLowerLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_16.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_16.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_16.setAutoDraw(True)\u000a        elif BotLowerLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_16.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_16* updates\u000a        if t >= 0 and TrialCrossHair_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_16.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_16.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_16.setAutoDraw(True)\u000a        elif TrialCrossHair_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_16.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_16* updates\u000a        if t >= 0 and RestCrossHair_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_16.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_16.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_16.setAutoDraw(True)\u000a        elif RestCrossHair_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_16.setAutoDraw(False)\u000a        \u000a        # *text_36* updates\u000a        if t >= 12 and text_36.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_36.tStart = t  # underestimates by a little under one frame\u000a            text_36.frameNStart = frameN  # exact frame index\u000a            text_36.setAutoDraw(True)\u000a        elif text_36.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_36.setAutoDraw(False)\u000a        \u000a        # *text_37* updates\u000a        if t >= 15 and text_37.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_37.tStart = t  # underestimates by a little under one frame\u000a            text_37.frameNStart = frameN  # exact frame index\u000a            text_37.setAutoDraw(True)\u000a        elif text_37.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_37.setAutoDraw(False)\u000a        \u000a        # *text_50* updates\u000a        if t >= 20 and text_50.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_50.tStart = t  # underestimates by a little under one frame\u000a            text_50.frameNStart = frameN  # exact frame index\u000a            text_50.setAutoDraw(True)\u000a        elif text_50.status == STARTED and t >= (20 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_50.setAutoDraw(False)\u000a        # *ISI_16* period\u000a        if t >= 0.0 and ISI_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_16.tStart = t  # underestimates by a little under one frame\u000a            ISI_16.frameNStart = frameN  # exact frame index\u000a            ISI_16.start(1)\u000a        elif ISI_16.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_16.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialParts_1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialParts_1"-------\u000a    for thisComponent in TrialParts_1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "trial5_2"-------\u000a    t = 0\u000a    trial5_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    UpperText.setText(u' L K R G M X ')\u000a    UpperBrackets.setText(u'  {         }')\u000a    LowerText.setText(u' b t y g q j ')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trial5_2Components = []\u000a    trial5_2Components.append(ISI)\u000a    trial5_2Components.append(TopUpperLine)\u000a    trial5_2Components.append(UpperText)\u000a    trial5_2Components.append(UpperBrackets)\u000a    trial5_2Components.append(BotUpperLine)\u000a    trial5_2Components.append(TopLowerLine)\u000a    trial5_2Components.append(LowerText)\u000a    trial5_2Components.append(LowerBrackets)\u000a    trial5_2Components.append(BotLowerLine)\u000a    trial5_2Components.append(TrialCrossHair)\u000a    trial5_2Components.append(RestCrossHair)\u000a    trial5_2Components.append(resp)\u000a    for thisComponent in trial5_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "trial5_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial5_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *TopUpperLine* updates\u000a        if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine.frameNStart = frameN  # exact frame index\u000a            TopUpperLine.setAutoDraw(True)\u000a        elif TopUpperLine.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine.setAutoDraw(False)\u000a        \u000a        # *UpperText* updates\u000a        if t >= 0 and UpperText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText.tStart = t  # underestimates by a little under one frame\u000a            UpperText.frameNStart = frameN  # exact frame index\u000a            UpperText.setAutoDraw(True)\u000a        elif UpperText.status == STARTED and t >= (0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets* updates\u000a        if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets.frameNStart = frameN  # exact frame index\u000a            UpperBrackets.setAutoDraw(True)\u000a        elif UpperBrackets.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine* updates\u000a        if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine.frameNStart = frameN  # exact frame index\u000a            BotUpperLine.setAutoDraw(True)\u000a        elif BotUpperLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine* updates\u000a        if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine.frameNStart = frameN  # exact frame index\u000a            TopLowerLine.setAutoDraw(True)\u000a        elif TopLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine.setAutoDraw(False)\u000a        \u000a        # *LowerText* updates\u000a        if t >= 7 and LowerText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText.tStart = t  # underestimates by a little under one frame\u000a            LowerText.frameNStart = frameN  # exact frame index\u000a            LowerText.setAutoDraw(True)\u000a        elif LowerText.status == STARTED and t >= (7 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets* updates\u000a        if t >= 7 and LowerBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets.frameNStart = frameN  # exact frame index\u000a            LowerBrackets.setAutoDraw(True)\u000a        elif LowerBrackets.status == STARTED and t >= (7 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine* updates\u000a        if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine.frameNStart = frameN  # exact frame index\u000a            BotLowerLine.setAutoDraw(True)\u000a        elif BotLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair* updates\u000a        if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair.setAutoDraw(True)\u000a        elif TrialCrossHair.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair* updates\u000a        if t >= 9 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (9 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # *resp* updates\u000a        if t >= 7 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif resp.status == STARTED and t >= (7 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(u'6')) or (resp.keys == u'6'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(1)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial5_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "trial5_2"-------\u000a    for thisComponent in trial5_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(u'6').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('resp.keys',resp.keys)\u000a    thisExp.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        thisExp.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "TrialFeedBack"-------\u000a    t = 0\u000a    TrialFeedBackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.000000)\u000a    # update component parameters for each repeat\u000a    if ((resp.corr) & (resp.rt < 2.0)):#stored on last run routine\u000a      msg="Correct and on time! RT=%.3f" %(resp.rt)\u000a    elif ((resp.corr) & (resp.rt > 2.0)):#stored on last run routine\u000a      msg="Correct, but too slow!\u005cn RT=%.3f\u005cnResponse time should be less than two seconds." %(resp.rt)\u000a    else:\u000a      if resp.rt < 2.0:\u000a        msg="Oops! That was incorrect, but on time!"\u000a      else: \u000a        msg="Oops! That was incorrect and too slow!"\u000a    text_47.setText(msg)\u000a    # keep track of which components have finished\u000a    TrialFeedBackComponents = []\u000a    TrialFeedBackComponents.append(text_47)\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialFeedBack"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialFeedBackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text_47* updates\u000a        if t >= 0.0 and text_47.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_47.tStart = t  # underestimates by a little under one frame\u000a            text_47.frameNStart = frameN  # exact frame index\u000a            text_47.setAutoDraw(True)\u000a        elif text_47.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_47.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialFeedBackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialFeedBack"-------\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    msg='Ended'\u000a    win.close()\u000a#    win.close()\u000a\u000adef Test(subid,visitid):\u000a    expInfo = {u'Visit ID': u'9999', u'Participant ID': u'1'}\u000a    print 'subid is %s'%(subid)\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a    else:\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid    \u000a    # Store info about the experiment session\u000a\u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'],expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=False,\u000a        dataFileName=filename)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=ScreenToUse, color=[-1,-1,-1], colorSpace='rgb',\u000a        blendMode='average', useFBO=True,\u000a        units='cm')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial_2"\u000a    trial_2Clock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text='      { }    ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Initialize components for Routine "TrialFeedBack"\u000a    TrialFeedBackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    text = visual.TextStim(win=win, ori=0, name='text',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    #------Prepare to start Routine "trial_2"-------\u000a    t = 0\u000a    trial_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    UpperText.setText(' A B C D E F ')\u000a    UpperBrackets.setText('  {         }')\u000a    LowerText.setText(' a b c d e f ')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trial_2Components = []\u000a    trial_2Components.append(ISI)\u000a    trial_2Components.append(TopUpperLine)\u000a    trial_2Components.append(UpperText)\u000a    trial_2Components.append(UpperBrackets)\u000a    trial_2Components.append(BotUpperLine)\u000a    trial_2Components.append(TopLowerLine)\u000a    trial_2Components.append(LowerText)\u000a    trial_2Components.append(LowerBrackets)\u000a    trial_2Components.append(BotLowerLine)\u000a    trial_2Components.append(TrialCrossHair)\u000a    trial_2Components.append(RestCrossHair)\u000a    trial_2Components.append(resp)\u000a    for thisComponent in trial_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "trial_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *TopUpperLine* updates\u000a        if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine.frameNStart = frameN  # exact frame index\u000a            TopUpperLine.setAutoDraw(True)\u000a        elif TopUpperLine.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine.setAutoDraw(False)\u000a        \u000a        # *UpperText* updates\u000a        if t >= 0 and UpperText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText.tStart = t  # underestimates by a little under one frame\u000a            UpperText.frameNStart = frameN  # exact frame index\u000a            UpperText.setAutoDraw(True)\u000a        elif UpperText.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets* updates\u000a        if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets.frameNStart = frameN  # exact frame index\u000a            UpperBrackets.setAutoDraw(True)\u000a        elif UpperBrackets.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine* updates\u000a        if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine.frameNStart = frameN  # exact frame index\u000a            BotUpperLine.setAutoDraw(True)\u000a        elif BotUpperLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine* updates\u000a        if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine.frameNStart = frameN  # exact frame index\u000a            TopLowerLine.setAutoDraw(True)\u000a        elif TopLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine.setAutoDraw(False)\u000a        \u000a        # *LowerText* updates\u000a        if t >= 7 and LowerText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText.tStart = t  # underestimates by a little under one frame\u000a            LowerText.frameNStart = frameN  # exact frame index\u000a            LowerText.setAutoDraw(True)\u000a        elif LowerText.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets* updates\u000a        if t >= 7 and LowerBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets.frameNStart = frameN  # exact frame index\u000a            LowerBrackets.setAutoDraw(True)\u000a        elif LowerBrackets.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine* updates\u000a        if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine.frameNStart = frameN  # exact frame index\u000a            BotLowerLine.setAutoDraw(True)\u000a        elif BotLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair* updates\u000a        if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair.setAutoDraw(True)\u000a        elif TrialCrossHair.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair* updates\u000a        if t >= 9 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (9 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # *resp* updates\u000a        if t >= 7 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif resp.status == STARTED and t >= (7 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(u'6')) or (resp.keys == u'6'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(1)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "trial_2"-------\u000a    for thisComponent in trial_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(u'6').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('resp.keys',resp.keys)\u000a    thisExp.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        thisExp.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "TrialFeedBack"-------\u000a    t = 0\u000a    TrialFeedBackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.000000)\u000a    # update component parameters for each repeat\u000a    if ((resp.corr) & (resp.rt < 2.0)):#stored on last run routine\u000a      msg="Correct and on time! RT=%.3f" %(resp.rt)\u000a    elif ((resp.corr) & (resp.rt > 2.0)):#stored on last run routine\u000a      msg="Correct, but too slow!\u005cn RT=%.3f\u005cnResponse time should be less than two seconds." %(resp.rt)\u000a    else:\u000a      if resp.rt < 2.0:\u000a        msg="Oops! That was incorrect, but on time!"\u000a      else: \u000a        msg="Oops! That was incorrect and too slow!"\u000a    text.setText(msg)\u000a    # keep track of which components have finished\u000a    TrialFeedBackComponents = []\u000a    TrialFeedBackComponents.append(text)\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialFeedBack"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialFeedBackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        elif text.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialFeedBackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialFeedBack"-------\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    msg='Ended'\u000a\u000a    win.close()\u000a\u000a
p1592
sS'thisTrial'
p1593
(lp1594
sS'_exp'
p1595
I347637328
sg10
S'trials'
p1596
sg6
S'/Users/jason/Dropbox/SteffenerColumbia/Scripts/ExperimentalStimuli/PartialTrialDIR/Scripts/PsychoPyTask/PartialTrialFunction.py'
p1597
sS'thisRepN'
p1598
I1
sg20
I01
sg21
g22
sS'data'
p1599
g1
(cpsychopy.data
DataHandler
p1600
c__builtin__
dict
p1601
(dp1602
g18
cnumpy.ma.core
_mareconstruct
p1603
(cnumpy.ma.core
MaskedArray
p1604
cnumpy
ndarray
p1605
(I0
tp1606
S'b'
tRp1607
(I1
(I72
I1
tg31
(S'f4'
I0
I1
tRp1608
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
cnumpy.core.multiarray
_reconstruct
p1609
(g1605
(I0
tS'b'
tRp1610
(I1
(I72
I1
tg31
(S'O4'
I0
I1
tRp1611
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp1612
g72
aS'--'
p1613
aS'--'
p1614
ag133
aS'--'
p1615
ag174
ag196
aS'--'
p1616
ag237
aS'--'
p1617
aS'--'
p1618
ag297
ag319
ag341
ag363
ag385
ag407
ag429
ag451
ag473
ag495
aS'--'
p1619
ag536
ag558
aS'--'
p1620
aS'--'
p1621
aS'--'
p1622
ag637
ag659
ag681
ag703
ag725
ag747
ag769
aS'--'
p1623
aS'--'
p1624
aS'--'
p1625
ag848
aS'--'
p1626
ag889
aS'--'
p1627
aS'--'
p1628
ag949
ag971
aS'--'
p1629
ag1012
aS'--'
p1630
aS'--'
p1631
aS'--'
p1632
ag1091
ag1113
ag1135
aS'--'
p1633
ag1176
ag1198
aS'--'
p1634
aS'--'
p1635
ag1258
ag1280
ag1302
aS'--'
p1636
ag1343
ag1365
ag1387
ag1409
ag1431
ag1453
ag1475
ag1497
ag1519
ag1541
ag1563
atbsS'ran'
p1637
g1603
(g1604
g1605
g1606
S'b'
tRp1638
(I1
(I72
I1
tg1608
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
g1609
(g1605
(I0
tS'b'
tRp1639
(I1
(I72
I1
tg1611
I00
(lp1640
g92
aNaNag152
aNag193
ag215
aNag256
aNaNag316
ag338
ag360
ag382
ag404
ag426
ag448
ag470
ag492
ag514
aNag555
ag577
aNaNaNag656
ag678
ag700
ag722
ag744
ag766
ag788
aNaNaNag867
aNag908
aNaNag968
ag990
aNag1031
aNaNaNag1110
ag1132
ag1154
aNag1195
ag1217
aNaNag1277
ag1299
ag1321
aNag1362
ag1384
ag1406
ag1428
ag1450
ag1472
ag1494
ag1516
ag1538
ag1560
ag1582
atbsg16
g1603
(g1604
g1605
g1606
S'b'
tRp1641
(I1
(I72
I1
tg1608
I00
S'\xfdL\xadN\xfdL\xadN\xfdL\xadN\xfdL\xadN\xfdL\xadN\xfeL\xadN\xfeL\xadN\xfeL\xadN\xfeL\xadN\xfeL\xadN\xfeL\xadN\xfeL\xadN\xfeL\xadN\xfeL\xadN\xfeL\xadN\xfeL\xadN\xfeL\xadN\xffL\xadN\xffL\xadN\xffL\xadN\xffL\xadN\xffL\xadN\xffL\xadN\xffL\xadN\xffL\xadN\xffL\xadN\xffL\xadN\xffL\xadN\xffL\xadN\xffL\xadN\x00M\xadN\x00M\xadN\x00M\xadN\x00M\xadN\x00M\xadN\x00M\xadN\x00M\xadN\x00M\xadN\x00M\xadN\x00M\xadN\x00M\xadN\x01M\xadN\x01M\xadN\x01M\xadN\x01M\xadN\x01M\xadN\x01M\xadN\x01M\xadN\x01M\xadN\x01M\xadN\x01M\xadN\x01M\xadN\x01M\xadN\x01M\xadN\x02M\xadN\x02M\xadN\x02M\xadN\x02M\xadN\x02M\xadN\x02M\xadN\x02M\xadN\x02M\xadN\x02M\xadN\x02M\xadN\x02M\xadN\x03M\xadN\x03M\xadN\x03M\xadN\x03M\xadN\x03M\xadN\x03M\xadN\x03M\xadN'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p1642
g1603
(g1604
g1605
g1606
S'b'
tRp1643
(I1
(I72
I1
tg1608
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB\x00\x00 B\x00\x00$B\x00\x00(B\x00\x00,B\x00\x000B\x00\x004B\x00\x008B\x00\x00<B\x00\x00@B\x00\x00DB\x00\x00HB\x00\x00LB\x00\x00PB\x00\x00TB\x00\x00XB\x00\x00\\B\x00\x00`B\x00\x00dB\x00\x00hB\x00\x00lB\x00\x00pB\x00\x00tB\x00\x00xB\x00\x00|B\x00\x00\x80B\x00\x00\x82B\x00\x00\x84B\x00\x00\x86B\x00\x00\x88B\x00\x00\x8aB\x00\x00\x8cB\x00\x00\x8eB'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1644
(dp1645
S'isNumeric'
p1646
(dp1647
g18
I01
sg1637
I01
sg16
I01
sg19
I00
sg17
I00
sg1642
I01
ssg1596
g1589
sS'dataTypes'
p1648
(lp1649
g1637
ag1642
ag16
ag17
ag18
ag19
asS'dataShape'
p1650
(lp1651
I72
aI1
asbsS'method'
p1652
Vsequential
p1653
sS'sequenceIndices'
p1654
g1609
(g1605
(I0
tS'b'
tRp1655
(I1
(I72
I1
tg85
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00(\x00\x00\x00)\x00\x00\x00*\x00\x00\x00+\x00\x00\x00,\x00\x00\x00-\x00\x00\x00.\x00\x00\x00/\x00\x00\x000\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x004\x00\x00\x005\x00\x00\x006\x00\x00\x007\x00\x00\x008\x00\x00\x009\x00\x00\x00:\x00\x00\x00;\x00\x00\x00<\x00\x00\x00=\x00\x00\x00>\x00\x00\x00?\x00\x00\x00@\x00\x00\x00A\x00\x00\x00B\x00\x00\x00C\x00\x00\x00D\x00\x00\x00E\x00\x00\x00F\x00\x00\x00G\x00\x00\x00'
tbsS'finished'
p1656
I01
sS'nReps'
p1657
I1
sS'nRemaining'
p1658
I-1
sS'trialList'
p1659
(lp1660
g1
(cpsychopy.data
TrialType
p1661
g1601
(dp1662
g42
g83
sg43
g77
sg44
g87
sg45
g78
sg46
g79
sg47
g75
sg48
g80
sg49
g71
sg50
g89
sg51
g81
sg52
g73
sg53
g82
sg54
g91
sg55
g74
stRp1663
ag1
(g1661
g1601
(dp1664
g42
g102
sg43
g94
sg44
g105
sg45
g95
sg46
g96
sg47
g107
sg48
g97
sg49
g98
sg50
g109
sg51
g99
sg52
g100
sg53
S' '
sg54
g111
sg55
g101
stRp1665
ag1
(g1661
g1601
(dp1666
g42
g121
sg43
g113
sg44
g124
sg45
g114
sg46
g115
sg47
g126
sg48
g116
sg49
g117
sg50
g128
sg51
g118
sg52
g119
sg53
S' '
sg54
g130
sg55
g120
stRp1667
ag1
(g1661
g1601
(dp1668
g42
g144
sg43
g138
sg44
g147
sg45
g139
sg46
g140
sg47
g136
sg48
g141
sg49
g132
sg50
g149
sg51
g142
sg52
g134
sg53
g143
sg54
g151
sg55
g135
stRp1669
ag1
(g1661
g1601
(dp1670
g42
g162
sg43
g154
sg44
g165
sg45
g155
sg46
g156
sg47
g167
sg48
g157
sg49
g158
sg50
g169
sg51
g159
sg52
g160
sg53
S' '
sg54
g171
sg55
g161
stRp1671
ag1
(g1661
g1601
(dp1672
g42
g185
sg43
g179
sg44
g188
sg45
g180
sg46
g181
sg47
g177
sg48
g182
sg49
g173
sg50
g190
sg51
g183
sg52
g175
sg53
g184
sg54
g192
sg55
g176
stRp1673
ag1
(g1661
g1601
(dp1674
g42
g207
sg43
g201
sg44
g210
sg45
g202
sg46
g203
sg47
g199
sg48
g204
sg49
g195
sg50
g212
sg51
g205
sg52
g197
sg53
g206
sg54
g214
sg55
g198
stRp1675
ag1
(g1661
g1601
(dp1676
g42
g225
sg43
g217
sg44
g228
sg45
g218
sg46
g219
sg47
g230
sg48
g220
sg49
g221
sg50
g232
sg51
g222
sg52
g223
sg53
S' '
sg54
g234
sg55
g224
stRp1677
ag1
(g1661
g1601
(dp1678
g42
g248
sg43
g242
sg44
g251
sg45
g243
sg46
g244
sg47
g240
sg48
g245
sg49
g236
sg50
g253
sg51
g246
sg52
g238
sg53
g247
sg54
g255
sg55
g239
stRp1679
ag1
(g1661
g1601
(dp1680
g42
g266
sg43
g258
sg44
g269
sg45
g259
sg46
g260
sg47
g271
sg48
g261
sg49
g262
sg50
g273
sg51
g263
sg52
g264
sg53
S' '
sg54
g275
sg55
g265
stRp1681
ag1
(g1661
g1601
(dp1682
g42
g285
sg43
g277
sg44
g288
sg45
g278
sg46
g279
sg47
g290
sg48
g280
sg49
g281
sg50
g292
sg51
g282
sg52
g283
sg53
S' '
sg54
g294
sg55
g284
stRp1683
ag1
(g1661
g1601
(dp1684
g42
g308
sg43
g302
sg44
g311
sg45
g303
sg46
g304
sg47
g300
sg48
g305
sg49
g296
sg50
g313
sg51
g306
sg52
g298
sg53
g307
sg54
g315
sg55
g299
stRp1685
ag1
(g1661
g1601
(dp1686
g42
g330
sg43
g324
sg44
g333
sg45
g325
sg46
g326
sg47
g322
sg48
g327
sg49
g318
sg50
g335
sg51
g328
sg52
g320
sg53
g329
sg54
g337
sg55
g321
stRp1687
ag1
(g1661
g1601
(dp1688
g42
g352
sg43
g346
sg44
g355
sg45
g347
sg46
g348
sg47
g344
sg48
g349
sg49
g340
sg50
g357
sg51
g350
sg52
g342
sg53
g351
sg54
g359
sg55
g343
stRp1689
ag1
(g1661
g1601
(dp1690
g42
g374
sg43
g368
sg44
g377
sg45
g369
sg46
g370
sg47
g366
sg48
g371
sg49
g362
sg50
g379
sg51
g372
sg52
g364
sg53
g373
sg54
g381
sg55
g365
stRp1691
ag1
(g1661
g1601
(dp1692
g42
g396
sg43
g390
sg44
g399
sg45
g391
sg46
g392
sg47
g388
sg48
g393
sg49
g384
sg50
g401
sg51
g394
sg52
g386
sg53
g395
sg54
g403
sg55
g387
stRp1693
ag1
(g1661
g1601
(dp1694
g42
g418
sg43
g412
sg44
g421
sg45
g413
sg46
g414
sg47
g410
sg48
g415
sg49
g406
sg50
g423
sg51
g416
sg52
g408
sg53
g417
sg54
g425
sg55
g409
stRp1695
ag1
(g1661
g1601
(dp1696
g42
g440
sg43
g434
sg44
g443
sg45
g435
sg46
g436
sg47
g432
sg48
g437
sg49
g428
sg50
g445
sg51
g438
sg52
g430
sg53
g439
sg54
g447
sg55
g431
stRp1697
ag1
(g1661
g1601
(dp1698
g42
g462
sg43
g456
sg44
g465
sg45
g457
sg46
g458
sg47
g454
sg48
g459
sg49
g450
sg50
g467
sg51
g460
sg52
g452
sg53
g461
sg54
g469
sg55
g453
stRp1699
ag1
(g1661
g1601
(dp1700
g42
g484
sg43
g478
sg44
g487
sg45
g479
sg46
g480
sg47
g476
sg48
g481
sg49
g472
sg50
g489
sg51
g482
sg52
g474
sg53
g483
sg54
g491
sg55
g475
stRp1701
ag1
(g1661
g1601
(dp1702
g42
g506
sg43
g500
sg44
g509
sg45
g501
sg46
g502
sg47
g498
sg48
g503
sg49
g494
sg50
g511
sg51
g504
sg52
g496
sg53
g505
sg54
g513
sg55
g497
stRp1703
ag1
(g1661
g1601
(dp1704
g42
g524
sg43
g516
sg44
g527
sg45
g517
sg46
g518
sg47
g529
sg48
g519
sg49
g520
sg50
g531
sg51
g521
sg52
g522
sg53
S' '
sg54
g533
sg55
g523
stRp1705
ag1
(g1661
g1601
(dp1706
g42
g547
sg43
g541
sg44
g550
sg45
g542
sg46
g543
sg47
g539
sg48
g544
sg49
g535
sg50
g552
sg51
g545
sg52
g537
sg53
g546
sg54
g554
sg55
g538
stRp1707
ag1
(g1661
g1601
(dp1708
g42
g569
sg43
g563
sg44
g572
sg45
g564
sg46
g565
sg47
g561
sg48
g566
sg49
g557
sg50
g574
sg51
g567
sg52
g559
sg53
g568
sg54
g576
sg55
g560
stRp1709
ag1
(g1661
g1601
(dp1710
g42
g587
sg43
g579
sg44
g590
sg45
g580
sg46
g581
sg47
g592
sg48
g582
sg49
g583
sg50
g594
sg51
g584
sg52
g585
sg53
S' '
sg54
g596
sg55
g586
stRp1711
ag1
(g1661
g1601
(dp1712
g42
g606
sg43
g598
sg44
g609
sg45
g599
sg46
g600
sg47
g611
sg48
g601
sg49
g602
sg50
g613
sg51
g603
sg52
g604
sg53
S' '
sg54
g615
sg55
g605
stRp1713
ag1
(g1661
g1601
(dp1714
g42
g625
sg43
g617
sg44
g628
sg45
g618
sg46
g619
sg47
g630
sg48
g620
sg49
g621
sg50
g632
sg51
g622
sg52
g623
sg53
S' '
sg54
g634
sg55
g624
stRp1715
ag1
(g1661
g1601
(dp1716
g42
g648
sg43
g642
sg44
g651
sg45
g643
sg46
g644
sg47
g640
sg48
g645
sg49
g636
sg50
g653
sg51
g646
sg52
g638
sg53
g647
sg54
g655
sg55
g639
stRp1717
ag1
(g1661
g1601
(dp1718
g42
g670
sg43
g664
sg44
g673
sg45
g665
sg46
g666
sg47
g662
sg48
g667
sg49
g658
sg50
g675
sg51
g668
sg52
g660
sg53
g669
sg54
g677
sg55
g661
stRp1719
ag1
(g1661
g1601
(dp1720
g42
g692
sg43
g686
sg44
g695
sg45
g687
sg46
g688
sg47
g684
sg48
g689
sg49
g680
sg50
g697
sg51
g690
sg52
g682
sg53
g691
sg54
g699
sg55
g683
stRp1721
ag1
(g1661
g1601
(dp1722
g42
g714
sg43
g708
sg44
g717
sg45
g709
sg46
g710
sg47
g706
sg48
g711
sg49
g702
sg50
g719
sg51
g712
sg52
g704
sg53
g713
sg54
g721
sg55
g705
stRp1723
ag1
(g1661
g1601
(dp1724
g42
g736
sg43
g730
sg44
g739
sg45
g731
sg46
g732
sg47
g728
sg48
g733
sg49
g724
sg50
g741
sg51
g734
sg52
g726
sg53
g735
sg54
g743
sg55
g727
stRp1725
ag1
(g1661
g1601
(dp1726
g42
g758
sg43
g752
sg44
g761
sg45
g753
sg46
g754
sg47
g750
sg48
g755
sg49
g746
sg50
g763
sg51
g756
sg52
g748
sg53
g757
sg54
g765
sg55
g749
stRp1727
ag1
(g1661
g1601
(dp1728
g42
g780
sg43
g774
sg44
g783
sg45
g775
sg46
g776
sg47
g772
sg48
g777
sg49
g768
sg50
g785
sg51
g778
sg52
g770
sg53
g779
sg54
g787
sg55
g771
stRp1729
ag1
(g1661
g1601
(dp1730
g42
g798
sg43
g790
sg44
g801
sg45
g791
sg46
g792
sg47
g803
sg48
g793
sg49
g794
sg50
g805
sg51
g795
sg52
g796
sg53
S' '
sg54
g807
sg55
g797
stRp1731
ag1
(g1661
g1601
(dp1732
g42
g817
sg43
g809
sg44
g820
sg45
g810
sg46
g811
sg47
g822
sg48
g812
sg49
g813
sg50
g824
sg51
g814
sg52
g815
sg53
S' '
sg54
g826
sg55
g816
stRp1733
ag1
(g1661
g1601
(dp1734
g42
g836
sg43
g828
sg44
g839
sg45
g829
sg46
g830
sg47
g841
sg48
g831
sg49
g832
sg50
g843
sg51
g833
sg52
g834
sg53
S' '
sg54
g845
sg55
g835
stRp1735
ag1
(g1661
g1601
(dp1736
g42
g859
sg43
g853
sg44
g862
sg45
g854
sg46
g855
sg47
g851
sg48
g856
sg49
g847
sg50
g864
sg51
g857
sg52
g849
sg53
g858
sg54
g866
sg55
g850
stRp1737
ag1
(g1661
g1601
(dp1738
g42
g877
sg43
g869
sg44
g880
sg45
g870
sg46
g871
sg47
g882
sg48
g872
sg49
g873
sg50
g884
sg51
g874
sg52
g875
sg53
S' '
sg54
g886
sg55
g876
stRp1739
ag1
(g1661
g1601
(dp1740
g42
g900
sg43
g894
sg44
g903
sg45
g895
sg46
g896
sg47
g892
sg48
g897
sg49
g888
sg50
g905
sg51
g898
sg52
g890
sg53
g899
sg54
g907
sg55
g891
stRp1741
ag1
(g1661
g1601
(dp1742
g42
g918
sg43
g910
sg44
g921
sg45
g911
sg46
g912
sg47
g923
sg48
g913
sg49
g914
sg50
g925
sg51
g915
sg52
g916
sg53
S' '
sg54
g927
sg55
g917
stRp1743
ag1
(g1661
g1601
(dp1744
g42
g937
sg43
g929
sg44
g940
sg45
g930
sg46
g931
sg47
g942
sg48
g932
sg49
g933
sg50
g944
sg51
g934
sg52
g935
sg53
S' '
sg54
g946
sg55
g936
stRp1745
ag1
(g1661
g1601
(dp1746
g42
g960
sg43
g954
sg44
g963
sg45
g955
sg46
g956
sg47
g952
sg48
g957
sg49
g948
sg50
g965
sg51
g958
sg52
g950
sg53
g959
sg54
g967
sg55
g951
stRp1747
ag1
(g1661
g1601
(dp1748
g42
g982
sg43
g976
sg44
g985
sg45
g977
sg46
g978
sg47
g974
sg48
g979
sg49
g970
sg50
g987
sg51
g980
sg52
g972
sg53
g981
sg54
g989
sg55
g973
stRp1749
ag1
(g1661
g1601
(dp1750
g42
g1000
sg43
g992
sg44
g1003
sg45
g993
sg46
g994
sg47
g1005
sg48
g995
sg49
g996
sg50
g1007
sg51
g997
sg52
g998
sg53
S' '
sg54
g1009
sg55
g999
stRp1751
ag1
(g1661
g1601
(dp1752
g42
g1023
sg43
g1017
sg44
g1026
sg45
g1018
sg46
g1019
sg47
g1015
sg48
g1020
sg49
g1011
sg50
g1028
sg51
g1021
sg52
g1013
sg53
g1022
sg54
g1030
sg55
g1014
stRp1753
ag1
(g1661
g1601
(dp1754
g42
g1041
sg43
g1033
sg44
g1044
sg45
g1034
sg46
g1035
sg47
g1046
sg48
g1036
sg49
g1037
sg50
g1048
sg51
g1038
sg52
g1039
sg53
S' '
sg54
g1050
sg55
g1040
stRp1755
ag1
(g1661
g1601
(dp1756
g42
g1060
sg43
g1052
sg44
g1063
sg45
g1053
sg46
g1054
sg47
g1065
sg48
g1055
sg49
g1056
sg50
g1067
sg51
g1057
sg52
g1058
sg53
S' '
sg54
g1069
sg55
g1059
stRp1757
ag1
(g1661
g1601
(dp1758
g42
g1079
sg43
g1071
sg44
g1082
sg45
g1072
sg46
g1073
sg47
g1084
sg48
g1074
sg49
g1075
sg50
g1086
sg51
g1076
sg52
g1077
sg53
S' '
sg54
g1088
sg55
g1078
stRp1759
ag1
(g1661
g1601
(dp1760
g42
g1102
sg43
g1096
sg44
g1105
sg45
g1097
sg46
g1098
sg47
g1094
sg48
g1099
sg49
g1090
sg50
g1107
sg51
g1100
sg52
g1092
sg53
g1101
sg54
g1109
sg55
g1093
stRp1761
ag1
(g1661
g1601
(dp1762
g42
g1124
sg43
g1118
sg44
g1127
sg45
g1119
sg46
g1120
sg47
g1116
sg48
g1121
sg49
g1112
sg50
g1129
sg51
g1122
sg52
g1114
sg53
g1123
sg54
g1131
sg55
g1115
stRp1763
ag1
(g1661
g1601
(dp1764
g42
g1146
sg43
g1140
sg44
g1149
sg45
g1141
sg46
g1142
sg47
g1138
sg48
g1143
sg49
g1134
sg50
g1151
sg51
g1144
sg52
g1136
sg53
g1145
sg54
g1153
sg55
g1137
stRp1765
ag1
(g1661
g1601
(dp1766
g42
g1164
sg43
g1156
sg44
g1167
sg45
g1157
sg46
g1158
sg47
g1169
sg48
g1159
sg49
g1160
sg50
g1171
sg51
g1161
sg52
g1162
sg53
S' '
sg54
g1173
sg55
g1163
stRp1767
ag1
(g1661
g1601
(dp1768
g42
g1187
sg43
g1181
sg44
g1190
sg45
g1182
sg46
g1183
sg47
g1179
sg48
g1184
sg49
g1175
sg50
g1192
sg51
g1185
sg52
g1177
sg53
g1186
sg54
g1194
sg55
g1178
stRp1769
ag1
(g1661
g1601
(dp1770
g42
g1209
sg43
g1203
sg44
g1212
sg45
g1204
sg46
g1205
sg47
g1201
sg48
g1206
sg49
g1197
sg50
g1214
sg51
g1207
sg52
g1199
sg53
g1208
sg54
g1216
sg55
g1200
stRp1771
ag1
(g1661
g1601
(dp1772
g42
g1227
sg43
g1219
sg44
g1230
sg45
g1220
sg46
g1221
sg47
g1232
sg48
g1222
sg49
g1223
sg50
g1234
sg51
g1224
sg52
g1225
sg53
S' '
sg54
g1236
sg55
g1226
stRp1773
ag1
(g1661
g1601
(dp1774
g42
g1246
sg43
g1238
sg44
g1249
sg45
g1239
sg46
g1240
sg47
g1251
sg48
g1241
sg49
g1242
sg50
g1253
sg51
g1243
sg52
g1244
sg53
S' '
sg54
g1255
sg55
g1245
stRp1775
ag1
(g1661
g1601
(dp1776
g42
g1269
sg43
g1263
sg44
g1272
sg45
g1264
sg46
g1265
sg47
g1261
sg48
g1266
sg49
g1257
sg50
g1274
sg51
g1267
sg52
g1259
sg53
g1268
sg54
g1276
sg55
g1260
stRp1777
ag1
(g1661
g1601
(dp1778
g42
g1291
sg43
g1285
sg44
g1294
sg45
g1286
sg46
g1287
sg47
g1283
sg48
g1288
sg49
g1279
sg50
g1296
sg51
g1289
sg52
g1281
sg53
g1290
sg54
g1298
sg55
g1282
stRp1779
ag1
(g1661
g1601
(dp1780
g42
g1313
sg43
g1307
sg44
g1316
sg45
g1308
sg46
g1309
sg47
g1305
sg48
g1310
sg49
g1301
sg50
g1318
sg51
g1311
sg52
g1303
sg53
g1312
sg54
g1320
sg55
g1304
stRp1781
ag1
(g1661
g1601
(dp1782
g42
g1331
sg43
g1323
sg44
g1334
sg45
g1324
sg46
g1325
sg47
g1336
sg48
g1326
sg49
g1327
sg50
g1338
sg51
g1328
sg52
g1329
sg53
S' '
sg54
g1340
sg55
g1330
stRp1783
ag1
(g1661
g1601
(dp1784
g42
g1354
sg43
g1348
sg44
g1357
sg45
g1349
sg46
g1350
sg47
g1346
sg48
g1351
sg49
g1342
sg50
g1359
sg51
g1352
sg52
g1344
sg53
g1353
sg54
g1361
sg55
g1345
stRp1785
ag1
(g1661
g1601
(dp1786
g42
g1376
sg43
g1370
sg44
g1379
sg45
g1371
sg46
g1372
sg47
g1368
sg48
g1373
sg49
g1364
sg50
g1381
sg51
g1374
sg52
g1366
sg53
g1375
sg54
g1383
sg55
g1367
stRp1787
ag1
(g1661
g1601
(dp1788
g42
g1398
sg43
g1392
sg44
g1401
sg45
g1393
sg46
g1394
sg47
g1390
sg48
g1395
sg49
g1386
sg50
g1403
sg51
g1396
sg52
g1388
sg53
g1397
sg54
g1405
sg55
g1389
stRp1789
ag1
(g1661
g1601
(dp1790
g42
g1420
sg43
g1414
sg44
g1423
sg45
g1415
sg46
g1416
sg47
g1412
sg48
g1417
sg49
g1408
sg50
g1425
sg51
g1418
sg52
g1410
sg53
g1419
sg54
g1427
sg55
g1411
stRp1791
ag1
(g1661
g1601
(dp1792
g42
g1442
sg43
g1436
sg44
g1445
sg45
g1437
sg46
g1438
sg47
g1434
sg48
g1439
sg49
g1430
sg50
g1447
sg51
g1440
sg52
g1432
sg53
g1441
sg54
g1449
sg55
g1433
stRp1793
ag1
(g1661
g1601
(dp1794
g42
g1464
sg43
g1458
sg44
g1467
sg45
g1459
sg46
g1460
sg47
g1456
sg48
g1461
sg49
g1452
sg50
g1469
sg51
g1462
sg52
g1454
sg53
g1463
sg54
g1471
sg55
g1455
stRp1795
ag1
(g1661
g1601
(dp1796
g42
g1486
sg43
g1480
sg44
g1489
sg45
g1481
sg46
g1482
sg47
g1478
sg48
g1483
sg49
g1474
sg50
g1491
sg51
g1484
sg52
g1476
sg53
g1485
sg54
g1493
sg55
g1477
stRp1797
ag1
(g1661
g1601
(dp1798
g42
g1508
sg43
g1502
sg44
g1511
sg45
g1503
sg46
g1504
sg47
g1500
sg48
g1505
sg49
g1496
sg50
g1513
sg51
g1506
sg52
g1498
sg53
g1507
sg54
g1515
sg55
g1499
stRp1799
ag1
(g1661
g1601
(dp1800
g42
g1530
sg43
g1524
sg44
g1533
sg45
g1525
sg46
g1526
sg47
g1522
sg48
g1527
sg49
g1518
sg50
g1535
sg51
g1528
sg52
g1520
sg53
g1529
sg54
g1537
sg55
g1521
stRp1801
ag1
(g1661
g1601
(dp1802
g42
g1552
sg43
g1546
sg44
g1555
sg45
g1547
sg46
g1548
sg47
g1544
sg48
g1549
sg49
g1540
sg50
g1557
sg51
g1550
sg52
g1542
sg53
g1551
sg54
g1559
sg55
g1543
stRp1803
ag1
(g1661
g1601
(dp1804
g42
g1574
sg43
g1568
sg44
g1577
sg45
g1569
sg46
g1570
sg47
g1566
sg48
g1571
sg49
g1562
sg50
g1579
sg51
g1572
sg52
g1564
sg53
g1573
sg54
g1581
sg55
g1565
stRp1805
asS'seed'
p1806
NsS'thisIndex'
p1807
g1576
sS'thisN'
p1808
I72
sS'thisTrialN'
p1809
I0
sS'nTotal'
p1810
I72
sS'_warnUseOfNext'
p1811
I01
sbasS'savePickle'
p1812
I00
sb.