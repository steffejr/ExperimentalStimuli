ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
S'/Users/jason/Dropbox/SteffenerColumbia/Scripts/ExperimentalStimuli/PartialTrialDIR/Scripts/PsychoPyTask/data/2003_1_PartialTrial_TrainNoFB_2016_02_03_944'
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'PartialTrial'
p11
sS'dataNames'
p12
(lp13
S'ScannerTrigger.keys'
p14
aS'ScannerTrigger.rt'
p15
aS'TrialStartTime'
p16
aS'KeyboardResp.keys'
p17
aS'KeyboardResp.corr'
p18
aS'KeyboardResp.rt'
p19
asS'autoLog'
p20
I01
sS'extraInfo'
p21
(dp22
VParticipant ID
p23
I2003
sS'date'
p24
V2016_Feb_03_0945
p25
sS'expName'
p26
g11
sVVisit ID
p27
I1
sS'frameRate'
p28
cnumpy.core.multiarray
scalar
p29
(cnumpy
dtype
p30
(S'f8'
I0
I1
tRp31
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x08\xfc\xf0\xdb.\x01N@'
tRp32
ssS'loopsUnfinished'
p33
(lp34
g1
(cpsychopy.data
TrialHandler
p35
g3
NtRp36
(dp37
S'origin'
p38
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.01), Thu 24 Sep 2015 11:35:23 AM EDT\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a# from psychopy.hardware.emulator import launchScan\u000aimport time\u000aimport sys\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000aglobal expName\u000aglobal AllowedInputKeys\u000aAllowedInputKeys = ['1', '2','3','4','5','6','7','8','9','down','right']\u000aglobal FullScreenFlag \u000a\u000aFullScreenFlag = True\u000aScreenToUse = 'MacBookPro'\u000aexpName='PartialTrial'\u000a\u000adef TestSomething(subid=9999,visitid=0001):\u000a    expInfo = {u'Visit ID': u'9999', u'Participant ID': u'1'}\u000a    print 'subid is %s'%(subid)\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a    else:\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a    return expInfo\u000a\u000adef PartialTrial(INPUTFILE,subid=9999,visitid=9999):\u000a    #INPUTFILE = 'Optimized60trialsLoads12467_1.xlsx'\u000a    # INPUTFILE = 'TrialListLoads123466_6Repeats_121415_2.csv'\u000a    # INPUTFILE = 'TwoTrials.xlsx'\u000a    IntroTime = 10\u000a    End = 10 # This should be set so that it is at least ten seconds and so the experiment \u000a    # total duration is a multiple of two seconds.\u000a\u000a    MaxLetters = 6\u000a    if MaxLetters == 6:\u000a        SETwrapWidth = 1.5 # The wrap width of text needs to be adjusted based on how manty letters there are\u000a        SETletCycle = 13 # # Spaces are added between letters and this controls the loop which does it\u000a    elif MaxLetters == 7:\u000a        SETwrapWidth = 1.7\u000a        SETletCycle = 15\u000a    expInfo = {u'Visit ID': u'001', u'Participant ID': u''}\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a        if dlg.OK == False: win.close()  # user pressed cancel\u000a    else:\u000a        print "Subid entered is: %s"%(subid)\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a        \u000a    # Store info about the experiment session\u000a\u000a    \u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=True,\u000a        dataFileName=filename)\u000a    #save a log file for detail verbose info\u000a    logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[1366, 768], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor = ScreenToUse, color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'norm')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial"\u000a    trialClock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    \u000a    # THE AIM IS TO \u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=SETwrapWidth, ## Changed from 1.5 because of 7 letters\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=SETwrapWidth,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=SETwrapWidth,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    WaitForScanner = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Waiting for Scanner, press r to advance',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(INPUTFILE),\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a\u000a\u000a    # PRESENT THE SCREEN TO WAIT FOR THE MRI TRIGGER\u000a    #vol = launchScan(win, MR_settings,  mode='Scan')\u000a\u000a    # ########################################################\u000a    # There should be WAITING FOR SCANNER trial here\u000a    # The test2 routine has these parts in it\u000a    #------Prepare to start Routine "ScanWait"-------\u000a    t = 0\u000a    ScanWaitClock = core.Clock()\u000a    ScanWaitClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    ScannerTrigger = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    ScannerTrigger.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    ScanWaitComponents = []\u000a    ScanWaitComponents.append(WaitForScanner)\u000a    ScanWaitComponents.append(ScannerTrigger)\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "ScanWait"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = ScanWaitClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_4* updates\u000a        if t >= 0.0 and WaitForScanner.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            WaitForScanner.tStart = t  # underestimates by a little under one frame\u000a            WaitForScanner.frameNStart = frameN  # exact frame index\u000a            WaitForScanner.setAutoDraw(True)\u000a        \u000a        # *key_resp_3* updates\u000a        if t >= 0.0 and ScannerTrigger.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ScannerTrigger.tStart = t  # underestimates by a little under one frame\u000a            ScannerTrigger.frameNStart = frameN  # exact frame index\u000a            ScannerTrigger.status = STARTED\u000a            # keyboard checking is just starting\u000a            ScannerTrigger.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if ScannerTrigger.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['r','equal'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                ScannerTrigger.keys = theseKeys[-1]  # just the last key pressed\u000a                ScannerTrigger.rt = ScannerTrigger.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ScanWaitComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            \u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "ScanWait"-------\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if ScannerTrigger.keys in ['', [], None]:  # No response was made\u000a       ScannerTrigger.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('ScannerTrigger.keys',ScannerTrigger.keys)\u000a    if ScannerTrigger.keys != None:  # we had a response\u000a        thisExp.addData('ScannerTrigger.rt', ScannerTrigger.rt)\u000a    thisExp.nextEntry()\u000a    # ########################################################\u000a\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a\u000a    # Write out when the experiment begins\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    #------Prepare to start Routine "intro"-------\u000a    t = 0\u000a    introClock = core.Clock()\u000a    introClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(IntroTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    introComponents = []\u000a    introComponents.append(RestCrossHair)\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "intro"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = introClock.getTime()\u000a        \u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_3* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (0.0 + (IntroTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in introComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "intro"-------\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    # ########################################################\u000a\u000a    for thisTrial in trials:\u000a        # Write to the file the time this trial starts\u000a        trials.addData('TrialStartTime',time.time())\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        # ENCODING SET\u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempStimSet = StimSet\u000a        # Letters for space - letter - space - letter ... - space\u000a        StimSet=' '\u000a        for i in tempStimSet:\u000a            StimSet=StimSet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        UpBrackText = ''\u000a        if UpBrack > 0:\u000a            BracketList = list(str(UpBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,SETletCycle,1):   ## Changed from 13 when using 7 letters\u000a                UpBrackText = UpBrackText+' '\u000a            s = list(UpBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            UpBrackText = ''.join(s)\u000a        \u000a        # PROBE \u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempProbeLet = ProbeLet\u000a        # Letters for space - letter - space - letter ... - space\u000a        ProbeLet=' '\u000a        for i in tempProbeLet:\u000a            ProbeLet = ProbeLet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        BotBrackText = ''\u000a        if BotBrack > 0:\u000a            BracketList = list(str(BotBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,SETletCycle,1):   ## Changed from 13 when using 7 letters\u000a                BotBrackText = BotBrackText+' '\u000a            s = list(BotBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            BotBrackText = ''.join(s)\u000a            \u000a        # update component parameters for each repeat\u000a        UpperText.setText(StimSet)\u000a        UpperBrackets.setText(UpBrackText)\u000a        LowerText.setText(ProbeLet)\u000a        LowerBrackets.setText(BotBrackText)\u000a        \u000a        KeyboardResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        KeyboardResp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(TopUpperLine)\u000a        trialComponents.append(UpperText)\u000a        trialComponents.append(UpperBrackets)\u000a        trialComponents.append(BotUpperLine)\u000a        trialComponents.append(TopLowerLine)\u000a        trialComponents.append(LowerText)\u000a        trialComponents.append(LowerBrackets)\u000a        trialComponents.append(BotLowerLine)\u000a        trialComponents.append(TrialCrossHair)\u000a        trialComponents.append(RestCrossHair)\u000a        trialComponents.append(KeyboardResp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            \u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *TopUpperLine* updates\u000a            if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine.frameNStart = frameN  # exact frame index\u000a                TopUpperLine.setAutoDraw(True)\u000a            elif TopUpperLine.status == STARTED and t >= (0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine.setAutoDraw(False)\u000a            \u000a            # *UpperText* updates\u000a            if t >= 0 and UpperText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText.tStart = t  # underestimates by a little under one frame\u000a                UpperText.frameNStart = frameN  # exact frame index\u000a                UpperText.setAutoDraw(True)\u000a            elif UpperText.status == STARTED and t >= (0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets* updates\u000a            if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets.frameNStart = frameN  # exact frame index\u000a                UpperBrackets.setAutoDraw(True)\u000a            elif UpperBrackets.status == STARTED and t >= (0.0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine* updates\u000a            if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine.frameNStart = frameN  # exact frame index\u000a                BotUpperLine.setAutoDraw(True)\u000a            elif BotUpperLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine* updates\u000a            if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine.frameNStart = frameN  # exact frame index\u000a                TopLowerLine.setAutoDraw(True)\u000a            elif TopLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine.setAutoDraw(False)\u000a            \u000a            # *LowerText* updates\u000a            if t >= ProbeStart and LowerText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText.tStart = t  # underestimates by a little under one frame\u000a                LowerText.frameNStart = frameN  # exact frame index\u000a                LowerText.setAutoDraw(True)\u000a            elif LowerText.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets* updates\u000a            if t >= ProbeStart and LowerBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets.frameNStart = frameN  # exact frame index\u000a                LowerBrackets.setAutoDraw(True)\u000a            elif LowerBrackets.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine* updates\u000a            if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine.frameNStart = frameN  # exact frame index\u000a                BotLowerLine.setAutoDraw(True)\u000a            elif BotLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair* updates\u000a            if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair.setAutoDraw(True)\u000a            elif TrialCrossHair.status == STARTED and t >= (0 + (TrialDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= TrialDur and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            elif RestCrossHair.status == STARTED and t >= (TrialDur + (ITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # *KeyboardResp* updates\u000a            if t >= ProbeStart and KeyboardResp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                KeyboardResp.tStart = t  # underestimates by a little under one frame\u000a                KeyboardResp.frameNStart = frameN  # exact frame index\u000a                KeyboardResp.status = STARTED\u000a                # keyboard checking is just starting\u000a                KeyboardResp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif KeyboardResp.status == STARTED and t >= (ProbeStart + (ProbeDurITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                KeyboardResp.status = STOPPED\u000a            if KeyboardResp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    KeyboardResp.keys.extend(theseKeys)  # storing all keys\u000a                    KeyboardResp.rt.append(KeyboardResp.clock.getTime())\u000a                    # was this 'correct'?\u000a                    if (KeyboardResp.keys == str(Correct)) or (KeyboardResp.keys == Correct):\u000a                        KeyboardResp.corr = 1\u000a                    else:\u000a                        KeyboardResp.corr = 0\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(1)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if KeyboardResp.keys in ['', [], None]:  # No response was made\u000a           KeyboardResp.keys=None\u000a           # was no response the correct answer?!\u000a           if str(Correct).lower() == 'none': KeyboardResp.corr = 1  # correct non-response\u000a           else: KeyboardResp.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('KeyboardResp.keys',KeyboardResp.keys)\u000a        trials.addData('KeyboardResp.corr', KeyboardResp.corr)\u000a        if KeyboardResp.keys != None:  # we had a response\u000a            trials.addData('KeyboardResp.rt', KeyboardResp.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    EndTimeClock = core.Clock()\u000a    EndTimeClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(End)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    EndTimeComponents = []\u000a    EndTimeComponents.append(RestCrossHair)\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = EndTimeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        if RestCrossHair.status == STARTED and t >= (0.0 + (End-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in EndTimeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            #win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # ########################################################\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()    \u000a    # completed 1 repeats of 'trials'\u000a    # the Routine "trial" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    win.close()\u000a    #sys.exit()\u000a    return filename\u000a\u000adef PartialTrialFeedback(INPUTFILE,filename,subid=9999,visitid=9999):\u000a    expInfo = {u'Visit ID': u'001', u'Participant ID': u''}\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a        if dlg.OK == False: win.close()  # user pressed cancel\u000a    else:\u000a        print "Subid entered is: %s"%(subid)\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a        \u000a    # Store info about the experiment session\u000a\u000a    \u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    #filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=True,\u000a        dataFileName=filename)\u000a    #save a log file for detail verbose info\u000a    logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=u'testMonitor', color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'use preferences')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial"\u000a    trialClock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=1.7,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=1.7,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=1.5,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    WaitForScanner = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Waiting for Scanner\u005cn Or press r to advance',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    ThankYou = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Merci\u005cnThank you',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    # Initialize components for Routine "Feedback"\u000a    FeedbackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    FeedbackMsg = visual.TextStim(win=win, ori=0, name='FeedbackMsg',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(INPUTFILE),#TrialListShort1#TrialList5Loads6Repeats\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a\u000a\u000a    # PRESENT THE SCREEN TO WAIT FOR THE MRI TRIGGER\u000a    #vol = launchScan(win, MR_settings,  mode='Scan')\u000a\u000a    # ########################################################\u000a    # There should be WAITING FOR SCANNER trial here\u000a    # The test2 routine has these parts in it\u000a    #------Prepare to start Routine "ScanWait"-------\u000a    t = 0\u000a    ScanWaitClock = core.Clock()\u000a    ScanWaitClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    ScannerTrigger = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    ScannerTrigger.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    ScanWaitComponents = []\u000a    ScanWaitComponents.append(WaitForScanner)\u000a    ScanWaitComponents.append(ScannerTrigger)\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "ScanWait"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = ScanWaitClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_4* updates\u000a        if t >= 0.0 and WaitForScanner.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            WaitForScanner.tStart = t  # underestimates by a little under one frame\u000a            WaitForScanner.frameNStart = frameN  # exact frame index\u000a            WaitForScanner.setAutoDraw(True)\u000a        \u000a        # *key_resp_3* updates\u000a        if t >= 0.0 and ScannerTrigger.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ScannerTrigger.tStart = t  # underestimates by a little under one frame\u000a            ScannerTrigger.frameNStart = frameN  # exact frame index\u000a            ScannerTrigger.status = STARTED\u000a            # keyboard checking is just starting\u000a            ScannerTrigger.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if ScannerTrigger.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['5', 'r'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                ScannerTrigger.keys = theseKeys[-1]  # just the last key pressed\u000a                ScannerTrigger.rt = ScannerTrigger.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ScanWaitComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            #core.quit()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "ScanWait"-------\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if ScannerTrigger.keys in ['', [], None]:  # No response was made\u000a       ScannerTrigger.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('ScannerTrigger.keys',ScannerTrigger.keys)\u000a    if ScannerTrigger.keys != None:  # we had a response\u000a        thisExp.addData('ScannerTrigger.rt', ScannerTrigger.rt)\u000a    thisExp.nextEntry()\u000a    # ########################################################\u000a\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a    IntroTime = 5\u000a    # Write out when the experiment begins\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    #------Prepare to start Routine "intro"-------\u000a    t = 0\u000a    introClock = core.Clock()\u000a    introClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(IntroTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    introComponents = []\u000a    introComponents.append(RestCrossHair)\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "intro"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = introClock.getTime()\u000a        \u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_3* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (0.0 + (IntroTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in introComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "intro"-------\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    # ########################################################\u000a\u000a    for thisTrial in trials:\u000a        # Write to the file the time this trial starts\u000a        trials.addData('TrialStartTime',time.time())\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        # ENCODING SET\u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempStimSet = StimSet\u000a        # Letters for space - letter - space - letter ... - space\u000a        StimSet=' '\u000a        for i in tempStimSet:\u000a            StimSet=StimSet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        UpBrackText = ''\u000a        if UpBrack > 0:\u000a            BracketList = list(str(UpBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,13,1):   ## Changed from 13 when using 7 letters\u000a                UpBrackText = UpBrackText+' '\u000a            s = list(UpBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            UpBrackText = ''.join(s)\u000a        \u000a        # PROBE \u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempProbeLet = ProbeLet\u000a        print '%s'%(tempProbeLet)\u000a        # Letters for space - letter - space - letter ... - space\u000a        ProbeLet=' '\u000a        for i in tempProbeLet:\u000a            ProbeLet = ProbeLet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        BotBrackText = ''\u000a        if BotBrack > 0:\u000a            BracketList = list(str(BotBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,13,1):   ## Changed from 13 when using 7 letters\u000a                BotBrackText = BotBrackText+' '\u000a            s = list(BotBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            BotBrackText = ''.join(s)\u000a            \u000a        # update component parameters for each repeat\u000a        UpperText.setText(StimSet)\u000a        UpperBrackets.setText(UpBrackText)\u000a        LowerText.setText(ProbeLet)\u000a        LowerBrackets.setText(BotBrackText)\u000a        \u000a        KeyboardResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        KeyboardResp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(TopUpperLine)\u000a        trialComponents.append(UpperText)\u000a        trialComponents.append(UpperBrackets)\u000a        trialComponents.append(BotUpperLine)\u000a        trialComponents.append(TopLowerLine)\u000a        trialComponents.append(LowerText)\u000a        trialComponents.append(LowerBrackets)\u000a        trialComponents.append(BotLowerLine)\u000a        trialComponents.append(TrialCrossHair)\u000a        trialComponents.append(RestCrossHair)\u000a        trialComponents.append(KeyboardResp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            \u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *TopUpperLine* updates\u000a            if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine.frameNStart = frameN  # exact frame index\u000a                TopUpperLine.setAutoDraw(True)\u000a            elif TopUpperLine.status == STARTED and t >= (0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine.setAutoDraw(False)\u000a            \u000a            # *UpperText* updates\u000a            if t >= 0 and UpperText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText.tStart = t  # underestimates by a little under one frame\u000a                UpperText.frameNStart = frameN  # exact frame index\u000a                UpperText.setAutoDraw(True)\u000a            elif UpperText.status == STARTED and t >= (0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets* updates\u000a            if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets.frameNStart = frameN  # exact frame index\u000a                UpperBrackets.setAutoDraw(True)\u000a            elif UpperBrackets.status == STARTED and t >= (0.0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine* updates\u000a            if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine.frameNStart = frameN  # exact frame index\u000a                BotUpperLine.setAutoDraw(True)\u000a            elif BotUpperLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine* updates\u000a            if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine.frameNStart = frameN  # exact frame index\u000a                TopLowerLine.setAutoDraw(True)\u000a            elif TopLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine.setAutoDraw(False)\u000a            \u000a            # *LowerText* updates\u000a            if t >= ProbeStart and LowerText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText.tStart = t  # underestimates by a little under one frame\u000a                LowerText.frameNStart = frameN  # exact frame index\u000a                LowerText.setAutoDraw(True)\u000a            elif LowerText.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets* updates\u000a            if t >= ProbeStart and LowerBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets.frameNStart = frameN  # exact frame index\u000a                LowerBrackets.setAutoDraw(True)\u000a            elif LowerBrackets.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine* updates\u000a            if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine.frameNStart = frameN  # exact frame index\u000a                BotLowerLine.setAutoDraw(True)\u000a            elif BotLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair* updates\u000a            if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair.setAutoDraw(True)\u000a            elif TrialCrossHair.status == STARTED and t >= (0 + (TrialDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= TrialDur and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            elif RestCrossHair.status == STARTED and t >= (TrialDur + (ITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # *KeyboardResp* updates\u000a            if t >= ProbeStart and KeyboardResp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                KeyboardResp.tStart = t  # underestimates by a little under one frame\u000a                KeyboardResp.frameNStart = frameN  # exact frame index\u000a                KeyboardResp.status = STARTED\u000a                # keyboard checking is just starting\u000a                KeyboardResp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif KeyboardResp.status == STARTED and t >= (ProbeStart + (ProbeDurITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                KeyboardResp.status = STOPPED\u000a            if KeyboardResp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    #KeyboardResp.keys.extend(theseKeys)  # storing all keys\u000a                    KeyboardResp.keys = theseKeys[-1]  # just the last key pressed\u000a                    #KeyboardResp.rt.append(KeyboardResp.clock.getTime())\u000a                    KeyboardResp.rt = KeyboardResp.clock.getTime()\u000a                    # was this 'correct'?\u000a                    # What if the participant responded whenthey were not supposed to?\u000a                    if str(Correct).lower() == 'none':\u000a                        KeyboardResp.corr = -10 # RESPONSE WHEN NONE WAS EXPECTED\u000a                    else:\u000a                        if (KeyboardResp.keys == str(Correct)) or (KeyboardResp.keys == Correct):\u000a                            KeyboardResp.corr = 1 # CORRECT\u000a                        else:\u000a                            KeyboardResp.corr = 0 # INCORRECT\u000a                    # was this 'correct'?\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(1)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if KeyboardResp.keys in ['', [], None]:  # No response was made\u000a           KeyboardResp.keys=None\u000a           # was no response the correct answer?!\u000a           if str(Correct).lower() == 'none': KeyboardResp.corr = 10  # correct non-response\u000a           else: KeyboardResp.corr = -1  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('KeyboardResp.keys',KeyboardResp.keys)\u000a        trials.addData('KeyboardResp.corr', KeyboardResp.corr)\u000a        if KeyboardResp.keys != None:  # we had a response\u000a            trials.addData('KeyboardResp.rt', KeyboardResp.rt)\u000a        thisExp.nextEntry()\u000a        \u000a        \u000a    # ########################################################    \u000a        #------Prepare to start Routine "Feedback"-------\u000a        FeedbackDur = 1.5\u000a        t = 0\u000a        FeedbackClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(FeedbackDur)\u000a        # update component parameters for each repeat\u000a        if KeyboardResp.corr == 1:#stored on last run routine\u000a          msg="Correct! RT=%.3f" %(KeyboardResp.rt)\u000a        elif KeyboardResp.corr == 0:\u000a          msg="Oops! That was wrong"\u000a        elif KeyboardResp.corr == -1:\u000a          msg="No response...miss"\u000a        elif KeyboardResp.corr == 10:\u000a          msg="No response, good!"\u000a        FeedbackMsg.setText(msg)\u000a        # keep track of which components have finished\u000a        FeedbackComponents = []\u000a        FeedbackComponents.append(FeedbackMsg)\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = FeedbackClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *FeedbackMsg* updates\u000a            if t >= 0.0 and FeedbackMsg.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                FeedbackMsg.tStart = t  # underestimates by a little under one frame\u000a                FeedbackMsg.frameNStart = frameN  # exact frame index\u000a                FeedbackMsg.setAutoDraw(True)\u000a            if FeedbackMsg.status == STARTED and t >= (0.0 + (FeedbackDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                FeedbackMsg.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in FeedbackComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback"-------\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a        #------Prepare to start Routine "REST"-------\u000a        t = 0\u000a        RESTClock = core.Clock()\u000a        RESTClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(1.000000)\u000a        # update component parameters for each repeat\u000a        # keep track of which components have finished\u000a        RESTComponents = []\u000a        RESTComponents.append(RestCrossHair)\u000a        for thisComponent in RESTComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "REST"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = RESTClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            if RestCrossHair.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in RESTComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "REST"-------\u000a        for thisComponent in RESTComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        thisExp.nextEntry()\u000a\u000a\u000a    win.flip()\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a    EndTime = 10\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    EndTimeClock = core.Clock()\u000a    EndTimeClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(EndTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    EndTimeComponents = []\u000a    EndTimeComponents.append(RestCrossHair)\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = EndTimeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        if RestCrossHair.status == STARTED and t >= (0.0 + (EndTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in EndTimeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "EndTime"-------\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a            \u000a    # ########################################################        \u000a    # There should be an intro off trial here also\u000a    ThankYouTime = 3\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    ThankYouClock = core.Clock()\u000a    ThankYouClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(ThankYouTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    ThankYouComponents = []\u000a    ThankYouComponents.append(ThankYou)\u000a    for thisComponent in ThankYouComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = ThankYouClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and ThankYou.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ThankYou.tStart = t  # underestimates by a little under one frame\u000a            ThankYou.frameNStart = frameN  # exact frame index\u000a            ThankYou.setAutoDraw(True)\u000a        if ThankYou.status == STARTED and t >= (0.0 + (ThankYouTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            ThankYou.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ThankYouComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "Thank you"-------\u000a    for thisComponent in ThankYouComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)       \u000a    # ########################################################\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()    \u000a    # completed 1 repeats of 'trials'\u000a    win.close()\u000a#    win.close()\u000a\u000adef Instructions():\u000a    # Store info about the experiment session\u000a    expName = u'Instructions'  # from the Builder filename that created this script\u000a    expInfo = {u'session': u'001', u'participant': u''}\u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=False,\u000a        dataFileName=filename)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=u'UbuntuMon', color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'norm')\u000a\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "ButtonPractice"\u000a    ButtonPracticeClock = core.Clock()\u000a    text_28 = visual.TextStim(win=win, ori=0, name='text_28',\u000a        text="First ...\u005cnLet's make sure the buttons work.\u005cnPress the RIGHT INDEX Finger button.",    font='Courier',\u000a        pos=[0,0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    ISI_14 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_14')\u000a    TopUpperLine_14 = visual.Line(win=win, name='TopUpperLine_14',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_14 = visual.TextStim(win=win, ori=0, name='UpperText_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    UpperBrackets_14 = visual.TextStim(win=win, ori=0, name='UpperBrackets_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    BotUpperLine_14 = visual.Line(win=win, name='BotUpperLine_14',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_14 = visual.Line(win=win, name='TopLowerLine_14',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_14 = visual.TextStim(win=win, ori=0, name='LowerText_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    LowerBrackets_14 = visual.TextStim(win=win, ori=0, name='LowerBrackets_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    BotLowerLine_14 = visual.Line(win=win, name='BotLowerLine_14',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_14 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_14',\u000a        text='\u005cn',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    RestCrossHair_14 = visual.TextStim(win=win, ori=0, name='RestCrossHair_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a\u000a    # Initialize components for Routine "Feedback"\u000a    FeedbackClock = core.Clock()\u000a    msg='?????'\u000a    text_25 = visual.TextStim(win=win, ori=0, name='text_25',\u000a        text='default text',    font='Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Initialize components for Routine "ButtonPractice_MIDDLE"\u000a    ButtonPractice_MIDDLEClock = core.Clock()\u000a    text_29 = visual.TextStim(win=win, ori=0, name='text_29',\u000a        text='Press the RIGHT MIDDLE Finger button.',    font='Courier',\u000a        pos=[0,0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    ISI_15 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_15')\u000a    TopUpperLine_15 = visual.Line(win=win, name='TopUpperLine_15',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_15 = visual.TextStim(win=win, ori=0, name='UpperText_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    UpperBrackets_15 = visual.TextStim(win=win, ori=0, name='UpperBrackets_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    BotUpperLine_15 = visual.Line(win=win, name='BotUpperLine_15',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_15 = visual.Line(win=win, name='TopLowerLine_15',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_15 = visual.TextStim(win=win, ori=0, name='LowerText_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    LowerBrackets_15 = visual.TextStim(win=win, ori=0, name='LowerBrackets_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    BotLowerLine_15 = visual.Line(win=win, name='BotLowerLine_15',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_15 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_15',\u000a        text='\u005cn',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    RestCrossHair_15 = visual.TextStim(win=win, ori=0, name='RestCrossHair_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a\u000a    # Initialize components for Routine "Feedback_MIDDLE"\u000a    Feedback_MIDDLEClock = core.Clock()\u000a    msg='?????'\u000a    text_26 = visual.TextStim(win=win, ori=0, name='text_26',\u000a        text='default text',    font=u'Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_2"\u000a    var_6Letters_2Clock = core.Clock()\u000a    text_13 = visual.TextStim(win=win, ori=0, name='text_13',\u000a        text='This is the screen you will see for each trial',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text_16 = visual.TextStim(win=win, ori=0, name='text_16',\u000a        text='With an UPPER Part',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_18 = visual.TextStim(win=win, ori=0, name='text_18',\u000a        text='And a LOWER part',    font='Courier',\u000a        pos=[0,-0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_21 = visual.TextStim(win=win, ori=0, name='text_21',\u000a        text=None,    font='Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_13 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_13')\u000a    TopUpperLine_13 = visual.Line(win=win, name='TopUpperLine_13',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_13 = visual.TextStim(win=win, ori=0, name='UpperText_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_13 = visual.TextStim(win=win, ori=0, name='UpperBrackets_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_13 = visual.Line(win=win, name='BotUpperLine_13',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_13 = visual.Line(win=win, name='TopLowerLine_13',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_13 = visual.TextStim(win=win, ori=0, name='LowerText_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_13 = visual.TextStim(win=win, ori=0, name='LowerBrackets_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_13 = visual.Line(win=win, name='BotLowerLine_13',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_13 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_13',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_13 = visual.TextStim(win=win, ori=0, name='RestCrossHair_13',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_22 = visual.TextStim(win=win, ori=0, name='text_22',\u000a        text='You will also see a cross hair on the screen',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_23 = visual.TextStim(win=win, ori=0, name='text_23',\u000a        text='Either Green',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_24 = visual.TextStim(win=win, ori=0, name='text_24',\u000a        text='Or RED',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_0"\u000a    var_6Letters_0Clock = core.Clock()\u000a    text_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a        text='For this experiment you will see letters at the top of the screen.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.1,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text = visual.TextStim(win=win, ori=0, name='text',\u000a        text='Some of the letters will be enclosed by brackets.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_6 = visual.TextStim(win=win, ori=0, name='text_6',\u000a        text=u'These are the letters to remember.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a        text='The letters will be removed, focus on the green cross hair.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_11 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_11')\u000a    TopUpperLine_11 = visual.Line(win=win, name='TopUpperLine_11',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_11 = visual.TextStim(win=win, ori=0, name='UpperText_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_11 = visual.TextStim(win=win, ori=0, name='UpperBrackets_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_11 = visual.Line(win=win, name='BotUpperLine_11',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_11 = visual.Line(win=win, name='TopLowerLine_11',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_11 = visual.TextStim(win=win, ori=0, name='LowerText_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_11 = visual.TextStim(win=win, ori=0, name='LowerBrackets_11',\u000a        text='  { }        ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_11 = visual.Line(win=win, name='BotLowerLine_11',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_11 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_11',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_11 = visual.TextStim(win=win, ori=0, name='RestCrossHair_11',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_5 = visual.TextStim(win=win, ori=0, name='text_5',\u000a        text='You will then see letters at the bottom.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.1,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a        text='Only one letter will be in brackets.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a    text_8 = visual.TextStim(win=win, ori=0, name='text_8',\u000a        text='You need to decide whether this letter was one that you had to remember.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-18.0)\u000a    text_9 = visual.TextStim(win=win, ori=0, name='text_9',\u000a        text='YES = INDEX finger button\u005cnNO  = MIDDLE finger button',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-19.0)\u000a    text_10 = visual.TextStim(win=win, ori=0, name='text_10',\u000a        text='The trial is then over and the cross hair turns RED.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-20.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_1"\u000a    var_6Letters_1Clock = core.Clock()\u000a    text_11 = visual.TextStim(win=win, ori=0, name='text_11',\u000a        text=u"Let's Repeat",    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_12 = visual.TextStim(win=win, ori=0, name='text_12',\u000a        text='Remember the letters B and C',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_14 = visual.TextStim(win=win, ori=0, name='text_14',\u000a        text=u'Letters are removed',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    ISI_12 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_12')\u000a    TopUpperLine_12 = visual.Line(win=win, name='TopUpperLine_12',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_12 = visual.TextStim(win=win, ori=0, name='UpperText_12',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-5.0)\u000a    UpperBrackets_12 = visual.TextStim(win=win, ori=0, name='UpperBrackets_12',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    BotUpperLine_12 = visual.Line(win=win, name='BotUpperLine_12',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_12 = visual.Line(win=win, name='TopLowerLine_12',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_12 = visual.TextStim(win=win, ori=0, name='LowerText_12',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    LowerBrackets_12 = visual.TextStim(win=win, ori=0, name='LowerBrackets_12',\u000a        text='  { }        ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    BotLowerLine_12 = visual.Line(win=win, name='BotLowerLine_12',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_12 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_12',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-12.0)\u000a    RestCrossHair_12 = visual.TextStim(win=win, ori=0, name='RestCrossHair_12',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    text_17 = visual.TextStim(win=win, ori=0, name='text_17',\u000a        text=u'Are you trying to remember the letter b?',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_19 = visual.TextStim(win=win, ori=0, name='text_19',\u000a        text=u'Yes you are. You would press the INDEX finger button as quickly as possible.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_20 = visual.TextStim(win=win, ori=0, name='text_20',\u000a        text=u'The trial is over and the cross hair turns RED.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "DemoTrialRealTimes"\u000a    DemoTrialRealTimesClock = core.Clock()\u000a    text_44 = visual.TextStim(win=win, ori=0, name='text_44',\u000a        text=u"Let's repeat at the true pace",    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_45 = visual.TextStim(win=win, ori=0, name='text_45',\u000a        text=u'Remember the letters B and C',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_46 = visual.TextStim(win=win, ori=0, name='text_46',\u000a        text=u'Letters are removed',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    ISI_18 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_18')\u000a    TopUpperLine_18 = visual.Line(win=win, name='TopUpperLine_18',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_18 = visual.TextStim(win=win, ori=0, name='UpperText_18',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-5.0)\u000a    UpperBrackets_18 = visual.TextStim(win=win, ori=0, name='UpperBrackets_18',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    BotUpperLine_18 = visual.Line(win=win, name='BotUpperLine_18',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_18 = visual.Line(win=win, name='TopLowerLine_18',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_17 = visual.TextStim(win=win, ori=0, name='LowerText_17',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    LowerBrackets_17 = visual.TextStim(win=win, ori=0, name='LowerBrackets_17',\u000a        text=u'  { }        ',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    BotLowerLine_18 = visual.Line(win=win, name='BotLowerLine_18',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_18 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_18',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-12.0)\u000a    RestCrossHair_18 = visual.TextStim(win=win, ori=0, name='RestCrossHair_18',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-13.0)\u000a    text_48 = visual.TextStim(win=win, ori=0, name='text_48',\u000a        text=u'Respond as quickly as possible',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_49 = visual.TextStim(win=win, ori=0, name='text_49',\u000a        text=u'The trial is over and the cross hair turns RED.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-16.0)\u000a\u000a    # Initialize components for Routine "NumLettersToRem"\u000a    NumLettersToRemClock = core.Clock()\u000a    text_15 = visual.TextStim(win=win, ori=0, name='text_15',\u000a        text='The number of letters to remember',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text_33 = visual.TextStim(win=win, ori=0, name='text_33',\u000a        text='Varies between 1 and 6',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_34 = visual.TextStim(win=win, ori=0, name='text_34',\u000a        text='There will always be six letters presented',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a        text='It is the brackets that indicate which letters to remember.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    text_35 = visual.TextStim(win=win, ori=0, name='text_35',\u000a        text='Here are some examples',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    UpBrack1 = visual.TextStim(win=win, ori=0, name='UpBrack1',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-5.0)\u000a    ISI_17 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_17')\u000a    TopUpperLine_17 = visual.Line(win=win, name='TopUpperLine_17',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_17 = visual.TextStim(win=win, ori=0, name='UpperText_17',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    UpperBrackets_17 = visual.TextStim(win=win, ori=0, name='UpperBrackets_17',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    BotUpperLine_17 = visual.Line(win=win, name='BotUpperLine_17',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_17 = visual.Line(win=win, name='TopLowerLine_17',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    BotLowerLine_17 = visual.Line(win=win, name='BotLowerLine_17',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_17 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_17',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_17 = visual.TextStim(win=win, ori=0, name='RestCrossHair_17',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    UpBrack2 = visual.TextStim(win=win, ori=0, name='UpBrack2',\u000a        text='{   }        ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    UpBrack3 = visual.TextStim(win=win, ori=0, name='UpBrack3',\u000a        text='      {     }',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='Yellow', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    UpBrack4 = visual.TextStim(win=win, ori=0, name='UpBrack4',\u000a        text='  {       }  ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a    UpBrack5 = visual.TextStim(win=win, ori=0, name='UpBrack5',\u000a        text='{         }  ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-18.0)\u000a    UpBrack6 = visual.TextStim(win=win, ori=0, name='UpBrack6',\u000a        text=u'{           }',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-19.0)\u000a    text_38 = visual.TextStim(win=win, ori=0, name='text_38',\u000a        text=u'One letter',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-20.0)\u000a    text_39 = visual.TextStim(win=win, ori=0, name='text_39',\u000a        text=u'Two letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-21.0)\u000a    text_40 = visual.TextStim(win=win, ori=0, name='text_40',\u000a        text=u'Three letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-22.0)\u000a    text_41 = visual.TextStim(win=win, ori=0, name='text_41',\u000a        text=u'Four letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-23.0)\u000a    text_42 = visual.TextStim(win=win, ori=0, name='text_42',\u000a        text=u'Five letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-24.0)\u000a    text_43 = visual.TextStim(win=win, ori=0, name='text_43',\u000a        text=u'Six letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-25.0)\u000a\u000a    # Initialize components for Routine "TrialParts_1"\u000a    TrialParts_1Clock = core.Clock()\u000a    text_27 = visual.TextStim(win=win, ori=0, name='text_27',\u000a        text=u'To help with the analysis of the brain data.\u005cnSome trials are PARTIAL.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_30 = visual.TextStim(win=win, ori=0, name='text_30',\u000a        text='All trials will have a set of letters to study.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_31 = visual.TextStim(win=win, ori=0, name='text_31',\u000a        text='Some will not require a response',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_32 = visual.TextStim(win=win, ori=0, name='text_32',\u000a        text='Some will have no delay between the letters to study and the response.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_16 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_16')\u000a    TopUpperLine_16 = visual.Line(win=win, name='TopUpperLine_16',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_16 = visual.TextStim(win=win, ori=0, name='UpperText_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_16 = visual.TextStim(win=win, ori=0, name='UpperBrackets_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_16 = visual.Line(win=win, name='BotUpperLine_16',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_16 = visual.Line(win=win, name='TopLowerLine_16',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_16 = visual.TextStim(win=win, ori=0, name='LowerText_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_16 = visual.TextStim(win=win, ori=0, name='LowerBrackets_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_16 = visual.Line(win=win, name='BotLowerLine_16',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_16 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_16 = visual.TextStim(win=win, ori=0, name='RestCrossHair_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_36 = visual.TextStim(win=win, ori=0, name='text_36',\u000a        text='What is important is that when the crosshair turns RED. The trial is over.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_37 = visual.TextStim(win=win, ori=0, name='text_37',\u000a        text='Try to forget any of the studied letters and wait for the next trial',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_50 = visual.TextStim(win=win, ori=0, name='text_50',\u000a        text=u'Here is an example trial with feedback.\u005cnRemember respond as quickly as possible.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "trial5_2"\u000a    trial5_2Clock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'      { }    ',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Initialize components for Routine "TrialFeedBack"\u000a    TrialFeedBackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    text_47 = visual.TextStim(win=win, ori=0, name='text_47',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=10, method='sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a    for thisTrial in trials:\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "ButtonPractice"-------\u000a        t = 0\u000a        ButtonPracticeClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(120.000000)\u000a        # update component parameters for each repeat\u000a        UpperText_14.setText('')\u000a        UpperBrackets_14.setText('')\u000a        LowerText_14.setText('')\u000a        key_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        ButtonPracticeComponents = []\u000a        ButtonPracticeComponents.append(text_28)\u000a        ButtonPracticeComponents.append(ISI_14)\u000a        ButtonPracticeComponents.append(TopUpperLine_14)\u000a        ButtonPracticeComponents.append(UpperText_14)\u000a        ButtonPracticeComponents.append(UpperBrackets_14)\u000a        ButtonPracticeComponents.append(BotUpperLine_14)\u000a        ButtonPracticeComponents.append(TopLowerLine_14)\u000a        ButtonPracticeComponents.append(LowerText_14)\u000a        ButtonPracticeComponents.append(LowerBrackets_14)\u000a        ButtonPracticeComponents.append(BotLowerLine_14)\u000a        ButtonPracticeComponents.append(TrialCrossHair_14)\u000a        ButtonPracticeComponents.append(RestCrossHair_14)\u000a        ButtonPracticeComponents.append(key_resp_2)\u000a        for thisComponent in ButtonPracticeComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "ButtonPractice"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = ButtonPracticeClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_28* updates\u000a            if t >= 0 and text_28.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_28.tStart = t  # underestimates by a little under one frame\u000a                text_28.frameNStart = frameN  # exact frame index\u000a                text_28.setAutoDraw(True)\u000a            elif text_28.status == STARTED and t >= (0 + (60-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_28.setAutoDraw(False)\u000a            \u000a            # *TopUpperLine_14* updates\u000a            if t >= 0 and TopUpperLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine_14.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine_14.frameNStart = frameN  # exact frame index\u000a                TopUpperLine_14.setAutoDraw(True)\u000a            elif TopUpperLine_14.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine_14.setAutoDraw(False)\u000a            \u000a            # *UpperText_14* updates\u000a            if t >= 0 and UpperText_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText_14.tStart = t  # underestimates by a little under one frame\u000a                UpperText_14.frameNStart = frameN  # exact frame index\u000a                UpperText_14.setAutoDraw(True)\u000a            elif UpperText_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText_14.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets_14* updates\u000a            if t >= 0 and UpperBrackets_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets_14.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets_14.frameNStart = frameN  # exact frame index\u000a                UpperBrackets_14.setAutoDraw(True)\u000a            elif UpperBrackets_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets_14.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine_14* updates\u000a            if t >= 0.0 and BotUpperLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine_14.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine_14.frameNStart = frameN  # exact frame index\u000a                BotUpperLine_14.setAutoDraw(True)\u000a            elif BotUpperLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine_14.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine_14* updates\u000a            if t >= 0.0 and TopLowerLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine_14.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine_14.frameNStart = frameN  # exact frame index\u000a                TopLowerLine_14.setAutoDraw(True)\u000a            elif TopLowerLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine_14.setAutoDraw(False)\u000a            \u000a            # *LowerText_14* updates\u000a            if t >= 0 and LowerText_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText_14.tStart = t  # underestimates by a little under one frame\u000a                LowerText_14.frameNStart = frameN  # exact frame index\u000a                LowerText_14.setAutoDraw(True)\u000a            elif LowerText_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText_14.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets_14* updates\u000a            if t >= 0 and LowerBrackets_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets_14.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets_14.frameNStart = frameN  # exact frame index\u000a                LowerBrackets_14.setAutoDraw(True)\u000a            elif LowerBrackets_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets_14.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine_14* updates\u000a            if t >= 0.0 and BotLowerLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine_14.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine_14.frameNStart = frameN  # exact frame index\u000a                BotLowerLine_14.setAutoDraw(True)\u000a            elif BotLowerLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine_14.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair_14* updates\u000a            if t >= 0 and TrialCrossHair_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair_14.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair_14.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair_14.setAutoDraw(True)\u000a            elif TrialCrossHair_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair_14.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair_14* updates\u000a            if t >= 0 and RestCrossHair_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair_14.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair_14.frameNStart = frameN  # exact frame index\u000a                RestCrossHair_14.setAutoDraw(True)\u000a            elif RestCrossHair_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair_14.setAutoDraw(False)\u000a            \u000a            # *key_resp_2* updates\u000a            if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_2.tStart = t  # underestimates by a little under one frame\u000a                key_resp_2.frameNStart = frameN  # exact frame index\u000a                key_resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif key_resp_2.status == STARTED and t >= (0.0 + (60-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_2.status = STOPPED\u000a            if key_resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8', '9','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_2.rt = key_resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_2.keys == str('6')) or (key_resp_2.keys == 'down'):\u000a                        key_resp_2.corr = 1\u000a                    else:\u000a                        key_resp_2.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            # *ISI_14* period\u000a            if t >= 0.0 and ISI_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI_14.tStart = t  # underestimates by a little under one frame\u000a                ISI_14.frameNStart = frameN  # exact frame index\u000a                ISI_14.start(1)\u000a            elif ISI_14.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI_14.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in ButtonPracticeComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                #win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "ButtonPractice"-------\u000a        for thisComponent in ButtonPracticeComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_2.keys in ['', [], None]:  # No response was made\u000a           key_resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str('6').lower() == 'none': key_resp_2.corr = 1  # correct non-response\u000a           else: key_resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('key_resp_2.keys',key_resp_2.keys)\u000a        trials.addData('key_resp_2.corr', key_resp_2.corr)\u000a        if key_resp_2.keys != None:  # we had a response\u000a            trials.addData('key_resp_2.rt', key_resp_2.rt)\u000a        \u000a        #------Prepare to start Routine "Feedback"-------\u000a        t = 0\u000a        FeedbackClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        if len(key_resp_2.keys)<1:\u000a            msg="Please press the RIGHT INDEX Finger button"\u000a            trials.finished = Falses\u000a        elif key_resp_2.corr:#stored on last run routine\u000a            msg="Correct! That button indicates a YES response." \u000a            trials.finished = True\u000a        else:\u000a            msg="Oops! Wrong button, please try again."\u000a            trials.finished = False\u000a        text_25.setText(msg)\u000a        # keep track of which components have finished\u000a        FeedbackComponents = []\u000a        FeedbackComponents.append(text_25)\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = FeedbackClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_25* updates\u000a            if t >= 0.0 and text_25.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_25.tStart = t  # underestimates by a little under one frame\u000a                text_25.frameNStart = frameN  # exact frame index\u000a                text_25.setAutoDraw(True)\u000a            elif text_25.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_25.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in FeedbackComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                \u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback"-------\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 10 repeats of 'trials'\u000a\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials_2 = data.TrialHandler(nReps=10, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='trials_2')\u000a    thisExp.addLoop(trials_2)  # add the loop to the experiment\u000a    thisTrial_2 = trials_2.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_2.rgb)\u000a    if thisTrial_2 != None:\u000a        for paramName in thisTrial_2.keys():\u000a            exec(paramName + '= thisTrial_2.' + paramName)\u000a\u000a    for thisTrial_2 in trials_2:\u000a        currentLoop = trials_2\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_2.rgb)\u000a        if thisTrial_2 != None:\u000a            for paramName in thisTrial_2.keys():\u000a                exec(paramName + '= thisTrial_2.' + paramName)\u000a        \u000a        #------Prepare to start Routine "ButtonPractice_MIDDLE"-------\u000a        t = 0\u000a        ButtonPractice_MIDDLEClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(20.000000)\u000a        # update component parameters for each repeat\u000a        UpperText_15.setText('')\u000a        UpperBrackets_15.setText('')\u000a        LowerText_15.setText('')\u000a        key_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_3.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        ButtonPractice_MIDDLEComponents = []\u000a        ButtonPractice_MIDDLEComponents.append(text_29)\u000a        ButtonPractice_MIDDLEComponents.append(ISI_15)\u000a        ButtonPractice_MIDDLEComponents.append(TopUpperLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(UpperText_15)\u000a        ButtonPractice_MIDDLEComponents.append(UpperBrackets_15)\u000a        ButtonPractice_MIDDLEComponents.append(BotUpperLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(TopLowerLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(LowerText_15)\u000a        ButtonPractice_MIDDLEComponents.append(LowerBrackets_15)\u000a        ButtonPractice_MIDDLEComponents.append(BotLowerLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(TrialCrossHair_15)\u000a        ButtonPractice_MIDDLEComponents.append(RestCrossHair_15)\u000a        ButtonPractice_MIDDLEComponents.append(key_resp_3)\u000a        for thisComponent in ButtonPractice_MIDDLEComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "ButtonPractice_MIDDLE"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = ButtonPractice_MIDDLEClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_29* updates\u000a            if t >= 0 and text_29.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_29.tStart = t  # underestimates by a little under one frame\u000a                text_29.frameNStart = frameN  # exact frame index\u000a                text_29.setAutoDraw(True)\u000a            elif text_29.status == STARTED and t >= (0 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_29.setAutoDraw(False)\u000a            \u000a            # *TopUpperLine_15* updates\u000a            if t >= 0 and TopUpperLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine_15.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine_15.frameNStart = frameN  # exact frame index\u000a                TopUpperLine_15.setAutoDraw(True)\u000a            elif TopUpperLine_15.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine_15.setAutoDraw(False)\u000a            \u000a            # *UpperText_15* updates\u000a            if t >= 0 and UpperText_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText_15.tStart = t  # underestimates by a little under one frame\u000a                UpperText_15.frameNStart = frameN  # exact frame index\u000a                UpperText_15.setAutoDraw(True)\u000a            elif UpperText_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText_15.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets_15* updates\u000a            if t >= 0 and UpperBrackets_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets_15.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets_15.frameNStart = frameN  # exact frame index\u000a                UpperBrackets_15.setAutoDraw(True)\u000a            elif UpperBrackets_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets_15.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine_15* updates\u000a            if t >= 0.0 and BotUpperLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine_15.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine_15.frameNStart = frameN  # exact frame index\u000a                BotUpperLine_15.setAutoDraw(True)\u000a            elif BotUpperLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine_15.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine_15* updates\u000a            if t >= 0.0 and TopLowerLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine_15.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine_15.frameNStart = frameN  # exact frame index\u000a                TopLowerLine_15.setAutoDraw(True)\u000a            elif TopLowerLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine_15.setAutoDraw(False)\u000a            \u000a            # *LowerText_15* updates\u000a            if t >= 0 and LowerText_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText_15.tStart = t  # underestimates by a little under one frame\u000a                LowerText_15.frameNStart = frameN  # exact frame index\u000a                LowerText_15.setAutoDraw(True)\u000a            elif LowerText_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText_15.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets_15* updates\u000a            if t >= 0 and LowerBrackets_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets_15.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets_15.frameNStart = frameN  # exact frame index\u000a                LowerBrackets_15.setAutoDraw(True)\u000a            elif LowerBrackets_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets_15.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine_15* updates\u000a            if t >= 0.0 and BotLowerLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine_15.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine_15.frameNStart = frameN  # exact frame index\u000a                BotLowerLine_15.setAutoDraw(True)\u000a            elif BotLowerLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine_15.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair_15* updates\u000a            if t >= 0 and TrialCrossHair_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair_15.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair_15.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair_15.setAutoDraw(True)\u000a            elif TrialCrossHair_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair_15.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair_15* updates\u000a            if t >= 0 and RestCrossHair_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair_15.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair_15.frameNStart = frameN  # exact frame index\u000a                RestCrossHair_15.setAutoDraw(True)\u000a            elif RestCrossHair_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair_15.setAutoDraw(False)\u000a            \u000a            # *key_resp_3* updates\u000a            if t >= 0.0 and key_resp_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_3.tStart = t  # underestimates by a little under one frame\u000a                key_resp_3.frameNStart = frameN  # exact frame index\u000a                key_resp_3.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_3.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif key_resp_3.status == STARTED and t >= (0.0 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_3.status = STOPPED\u000a            if key_resp_3.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8', '9','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_3.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_3.rt = key_resp_3.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_3.keys == str('7')) or (key_resp_3.keys == 'right'):\u000a                        key_resp_3.corr = 1\u000a                    else:\u000a                        key_resp_3.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            # *ISI_15* period\u000a            if t >= 0.0 and ISI_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI_15.tStart = t  # underestimates by a little under one frame\u000a                ISI_15.frameNStart = frameN  # exact frame index\u000a                ISI_15.start(1)\u000a            elif ISI_15.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI_15.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in ButtonPractice_MIDDLEComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "ButtonPractice_MIDDLE"-------\u000a        for thisComponent in ButtonPractice_MIDDLEComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_3.keys in ['', [], None]:  # No response was made\u000a           key_resp_3.keys=None\u000a           # was no response the correct answer?!\u000a           if str('7').lower() == 'none': key_resp_3.corr = 1  # correct non-response\u000a           else: key_resp_3.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials_2 (TrialHandler)\u000a        trials_2.addData('key_resp_3.keys',key_resp_3.keys)\u000a        trials_2.addData('key_resp_3.corr', key_resp_3.corr)\u000a        if key_resp_3.keys != None:  # we had a response\u000a            trials_2.addData('key_resp_3.rt', key_resp_3.rt)\u000a        \u000a        #------Prepare to start Routine "Feedback_MIDDLE"-------\u000a        t = 0\u000a        Feedback_MIDDLEClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        if len(key_resp_3.keys)<1:\u000a            msg="Please press the RIGHT MIDDLE Finger button"\u000a            trials_2.finished = Falses\u000a        elif key_resp_3.corr:#stored on last run routine\u000a            msg="Good! That button indicates a NO response." \u000a            trials_2.finished = True\u000a        else:\u000a            msg="Oops! Wrong button, please try again."\u000a            trials_2.finished = False\u000a        text_26.setText(msg)\u000a        # keep track of which components have finished\u000a        Feedback_MIDDLEComponents = []\u000a        Feedback_MIDDLEComponents.append(text_26)\u000a        for thisComponent in Feedback_MIDDLEComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback_MIDDLE"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = Feedback_MIDDLEClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_26* updates\u000a            if t >= 0.0 and text_26.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_26.tStart = t  # underestimates by a little under one frame\u000a                text_26.frameNStart = frameN  # exact frame index\u000a                text_26.setAutoDraw(True)\u000a            elif text_26.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_26.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Feedback_MIDDLEComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback_MIDDLE"-------\u000a        for thisComponent in Feedback_MIDDLEComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 10 repeats of 'trials_2'\u000a\u000a\u000a    #------Prepare to start Routine "var_6Letters_2"-------\u000a    t = 0\u000a    var_6Letters_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(20.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_13.setText('')\u000a    UpperBrackets_13.setText('')\u000a    LowerText_13.setText('')\u000a    # keep track of which components have finished\u000a    var_6Letters_2Components = []\u000a    var_6Letters_2Components.append(text_13)\u000a    var_6Letters_2Components.append(text_16)\u000a    var_6Letters_2Components.append(text_18)\u000a    var_6Letters_2Components.append(text_21)\u000a    var_6Letters_2Components.append(ISI_13)\u000a    var_6Letters_2Components.append(TopUpperLine_13)\u000a    var_6Letters_2Components.append(UpperText_13)\u000a    var_6Letters_2Components.append(UpperBrackets_13)\u000a    var_6Letters_2Components.append(BotUpperLine_13)\u000a    var_6Letters_2Components.append(TopLowerLine_13)\u000a    var_6Letters_2Components.append(LowerText_13)\u000a    var_6Letters_2Components.append(LowerBrackets_13)\u000a    var_6Letters_2Components.append(BotLowerLine_13)\u000a    var_6Letters_2Components.append(TrialCrossHair_13)\u000a    var_6Letters_2Components.append(RestCrossHair_13)\u000a    var_6Letters_2Components.append(text_22)\u000a    var_6Letters_2Components.append(text_23)\u000a    var_6Letters_2Components.append(text_24)\u000a    for thisComponent in var_6Letters_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_13* updates\u000a        if t >= 0.0 and text_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_13.tStart = t  # underestimates by a little under one frame\u000a            text_13.frameNStart = frameN  # exact frame index\u000a            text_13.setAutoDraw(True)\u000a        elif text_13.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_13.setAutoDraw(False)\u000a        \u000a        # *text_16* updates\u000a        if t >= 3 and text_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_16.tStart = t  # underestimates by a little under one frame\u000a            text_16.frameNStart = frameN  # exact frame index\u000a            text_16.setAutoDraw(True)\u000a        elif text_16.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_16.setAutoDraw(False)\u000a        \u000a        # *text_18* updates\u000a        if t >= 6 and text_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_18.tStart = t  # underestimates by a little under one frame\u000a            text_18.frameNStart = frameN  # exact frame index\u000a            text_18.setAutoDraw(True)\u000a        elif text_18.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_18.setAutoDraw(False)\u000a        \u000a        # *text_21* updates\u000a        if t >= 0 and text_21.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_21.tStart = t  # underestimates by a little under one frame\u000a            text_21.frameNStart = frameN  # exact frame index\u000a            text_21.setAutoDraw(True)\u000a        elif text_21.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_21.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_13* updates\u000a        if t >= 0 and TopUpperLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_13.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_13.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_13.setAutoDraw(True)\u000a        elif TopUpperLine_13.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_13.setAutoDraw(False)\u000a        \u000a        # *UpperText_13* updates\u000a        if t >= 0 and UpperText_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_13.tStart = t  # underestimates by a little under one frame\u000a            UpperText_13.frameNStart = frameN  # exact frame index\u000a            UpperText_13.setAutoDraw(True)\u000a        elif UpperText_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_13.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_13* updates\u000a        if t >= 0 and UpperBrackets_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_13.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_13.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_13.setAutoDraw(True)\u000a        elif UpperBrackets_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_13.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_13* updates\u000a        if t >= 0.0 and BotUpperLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_13.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_13.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_13.setAutoDraw(True)\u000a        elif BotUpperLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_13.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_13* updates\u000a        if t >= 0.0 and TopLowerLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_13.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_13.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_13.setAutoDraw(True)\u000a        elif TopLowerLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_13.setAutoDraw(False)\u000a        \u000a        # *LowerText_13* updates\u000a        if t >= 0 and LowerText_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_13.tStart = t  # underestimates by a little under one frame\u000a            LowerText_13.frameNStart = frameN  # exact frame index\u000a            LowerText_13.setAutoDraw(True)\u000a        elif LowerText_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_13.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_13* updates\u000a        if t >= 0 and LowerBrackets_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_13.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_13.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_13.setAutoDraw(True)\u000a        elif LowerBrackets_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_13.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_13* updates\u000a        if t >= 0.0 and BotLowerLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_13.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_13.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_13.setAutoDraw(True)\u000a        elif BotLowerLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_13.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_13* updates\u000a        if t >= 12 and TrialCrossHair_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_13.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_13.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_13.setAutoDraw(True)\u000a        elif TrialCrossHair_13.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_13.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_13* updates\u000a        if t >= 15 and RestCrossHair_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_13.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_13.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_13.setAutoDraw(True)\u000a        elif RestCrossHair_13.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_13.setAutoDraw(False)\u000a        \u000a        # *text_22* updates\u000a        if t >= 9 and text_22.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_22.tStart = t  # underestimates by a little under one frame\u000a            text_22.frameNStart = frameN  # exact frame index\u000a            text_22.setAutoDraw(True)\u000a        elif text_22.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_22.setAutoDraw(False)\u000a        \u000a        # *text_23* updates\u000a        if t >= 12 and text_23.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_23.tStart = t  # underestimates by a little under one frame\u000a            text_23.frameNStart = frameN  # exact frame index\u000a            text_23.setAutoDraw(True)\u000a        elif text_23.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_23.setAutoDraw(False)\u000a        \u000a        # *text_24* updates\u000a        if t >= 15 and text_24.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_24.tStart = t  # underestimates by a little under one frame\u000a            text_24.frameNStart = frameN  # exact frame index\u000a            text_24.setAutoDraw(True)\u000a        elif text_24.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_24.setAutoDraw(False)\u000a        # *ISI_13* period\u000a        if t >= 0.0 and ISI_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_13.tStart = t  # underestimates by a little under one frame\u000a            ISI_13.frameNStart = frameN  # exact frame index\u000a            ISI_13.start(1)\u000a        elif ISI_13.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_13.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_2"-------\u000a    for thisComponent in var_6Letters_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "var_6Letters_0"-------\u000a    t = 0\u000a    var_6Letters_0Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(30.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_11.setText(' A B C D E F ')\u000a    UpperBrackets_11.setText('  {   }      ')\u000a    LowerText_11.setText(' a b c d e f ')\u000a    KeyboardResp_11 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_11.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    var_6Letters_0Components = []\u000a    var_6Letters_0Components.append(text_2)\u000a    var_6Letters_0Components.append(text)\u000a    var_6Letters_0Components.append(text_6)\u000a    var_6Letters_0Components.append(text_4)\u000a    var_6Letters_0Components.append(ISI_11)\u000a    var_6Letters_0Components.append(TopUpperLine_11)\u000a    var_6Letters_0Components.append(UpperText_11)\u000a    var_6Letters_0Components.append(UpperBrackets_11)\u000a    var_6Letters_0Components.append(BotUpperLine_11)\u000a    var_6Letters_0Components.append(TopLowerLine_11)\u000a    var_6Letters_0Components.append(LowerText_11)\u000a    var_6Letters_0Components.append(LowerBrackets_11)\u000a    var_6Letters_0Components.append(BotLowerLine_11)\u000a    var_6Letters_0Components.append(TrialCrossHair_11)\u000a    var_6Letters_0Components.append(RestCrossHair_11)\u000a    var_6Letters_0Components.append(KeyboardResp_11)\u000a    var_6Letters_0Components.append(text_5)\u000a    var_6Letters_0Components.append(text_7)\u000a    var_6Letters_0Components.append(text_8)\u000a    var_6Letters_0Components.append(text_9)\u000a    var_6Letters_0Components.append(text_10)\u000a    for thisComponent in var_6Letters_0Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_0"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_0Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_2* updates\u000a        if t >= 0.0 and text_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_2.tStart = t  # underestimates by a little under one frame\u000a            text_2.frameNStart = frameN  # exact frame index\u000a            text_2.setAutoDraw(True)\u000a        elif text_2.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_2.setAutoDraw(False)\u000a        \u000a        # *text* updates\u000a        if t >= 3 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        elif text.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # *text_6* updates\u000a        if t >= 6 and text_6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_6.tStart = t  # underestimates by a little under one frame\u000a            text_6.frameNStart = frameN  # exact frame index\u000a            text_6.setAutoDraw(True)\u000a        elif text_6.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_6.setAutoDraw(False)\u000a        \u000a        # *text_4* updates\u000a        if t >= 9 and text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_4.tStart = t  # underestimates by a little under one frame\u000a            text_4.frameNStart = frameN  # exact frame index\u000a            text_4.setAutoDraw(True)\u000a        elif text_4.status == STARTED and t >= (9 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_4.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_11* updates\u000a        if t >= 0 and TopUpperLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_11.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_11.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_11.setAutoDraw(True)\u000a        elif TopUpperLine_11.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_11.setAutoDraw(False)\u000a        \u000a        # *UpperText_11* updates\u000a        if t >= 0 and UpperText_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_11.tStart = t  # underestimates by a little under one frame\u000a            UpperText_11.frameNStart = frameN  # exact frame index\u000a            UpperText_11.setAutoDraw(True)\u000a        elif UpperText_11.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_11.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_11* updates\u000a        if t >= 3 and UpperBrackets_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_11.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_11.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_11.setAutoDraw(True)\u000a        elif UpperBrackets_11.status == STARTED and t >= (3 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_11.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_11* updates\u000a        if t >= 0.0 and BotUpperLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_11.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_11.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_11.setAutoDraw(True)\u000a        elif BotUpperLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_11.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_11* updates\u000a        if t >= 0.0 and TopLowerLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_11.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_11.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_11.setAutoDraw(True)\u000a        elif TopLowerLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_11.setAutoDraw(False)\u000a        \u000a        # *LowerText_11* updates\u000a        if t >= 14 and LowerText_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_11.tStart = t  # underestimates by a little under one frame\u000a            LowerText_11.frameNStart = frameN  # exact frame index\u000a            LowerText_11.setAutoDraw(True)\u000a        elif LowerText_11.status == STARTED and t >= (14 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_11.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_11* updates\u000a        if t >= 17 and LowerBrackets_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_11.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_11.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_11.setAutoDraw(True)\u000a        elif LowerBrackets_11.status == STARTED and t >= (17 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_11.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_11* updates\u000a        if t >= 0.0 and BotLowerLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_11.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_11.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_11.setAutoDraw(True)\u000a        elif BotLowerLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_11.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_11* updates\u000a        if t >= 0 and TrialCrossHair_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_11.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_11.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_11.setAutoDraw(True)\u000a        elif TrialCrossHair_11.status == STARTED and t >= (0 + (26-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_11.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_11* updates\u000a        if t >= 26 and RestCrossHair_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_11.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_11.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_11.setAutoDraw(True)\u000a        elif RestCrossHair_11.status == STARTED and t >= (26 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_11.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_11* updates\u000a        if t >= 0 and KeyboardResp_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_11.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_11.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_11.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_11.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_11.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_11.status = STOPPED\u000a        if KeyboardResp_11.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_11.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_11.rt.append(KeyboardResp_11.clock.getTime())\u000a        \u000a        # *text_5* updates\u000a        if t >= 14 and text_5.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_5.tStart = t  # underestimates by a little under one frame\u000a            text_5.frameNStart = frameN  # exact frame index\u000a            text_5.setAutoDraw(True)\u000a        elif text_5.status == STARTED and t >= (14 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_5.setAutoDraw(False)\u000a        \u000a        # *text_7* updates\u000a        if t >= 17 and text_7.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_7.tStart = t  # underestimates by a little under one frame\u000a            text_7.frameNStart = frameN  # exact frame index\u000a            text_7.setAutoDraw(True)\u000a        elif text_7.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_7.setAutoDraw(False)\u000a        \u000a        # *text_8* updates\u000a        if t >= 20 and text_8.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_8.tStart = t  # underestimates by a little under one frame\u000a            text_8.frameNStart = frameN  # exact frame index\u000a            text_8.setAutoDraw(True)\u000a        elif text_8.status == STARTED and t >= (20 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_8.setAutoDraw(False)\u000a        \u000a        # *text_9* updates\u000a        if t >= 23 and text_9.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_9.tStart = t  # underestimates by a little under one frame\u000a            text_9.frameNStart = frameN  # exact frame index\u000a            text_9.setAutoDraw(True)\u000a        elif text_9.status == STARTED and t >= (23 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_9.setAutoDraw(False)\u000a        \u000a        # *text_10* updates\u000a        if t >= 26 and text_10.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_10.tStart = t  # underestimates by a little under one frame\u000a            text_10.frameNStart = frameN  # exact frame index\u000a            text_10.setAutoDraw(True)\u000a        elif text_10.status == STARTED and t >= (26 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_10.setAutoDraw(False)\u000a        # *ISI_11* period\u000a        if t >= 0.0 and ISI_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_11.tStart = t  # underestimates by a little under one frame\u000a            ISI_11.frameNStart = frameN  # exact frame index\u000a            ISI_11.start(1)\u000a        elif ISI_11.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_11.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_0Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_0"-------\u000a    for thisComponent in var_6Letters_0Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_11.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_11.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_11.keys',KeyboardResp_11.keys)\u000a    if KeyboardResp_11.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_11.rt', KeyboardResp_11.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "var_6Letters_1"-------\u000a    t = 0\u000a    var_6Letters_1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(22.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_12.setText(' A B C D E F ')\u000a    UpperBrackets_12.setText('  {   }      ')\u000a    LowerText_12.setText(u' a b c d e f ')\u000a    KeyboardResp_12 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_12.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    var_6Letters_1Components = []\u000a    var_6Letters_1Components.append(text_11)\u000a    var_6Letters_1Components.append(text_12)\u000a    var_6Letters_1Components.append(text_14)\u000a    var_6Letters_1Components.append(ISI_12)\u000a    var_6Letters_1Components.append(TopUpperLine_12)\u000a    var_6Letters_1Components.append(UpperText_12)\u000a    var_6Letters_1Components.append(UpperBrackets_12)\u000a    var_6Letters_1Components.append(BotUpperLine_12)\u000a    var_6Letters_1Components.append(TopLowerLine_12)\u000a    var_6Letters_1Components.append(LowerText_12)\u000a    var_6Letters_1Components.append(LowerBrackets_12)\u000a    var_6Letters_1Components.append(BotLowerLine_12)\u000a    var_6Letters_1Components.append(TrialCrossHair_12)\u000a    var_6Letters_1Components.append(RestCrossHair_12)\u000a    var_6Letters_1Components.append(KeyboardResp_12)\u000a    var_6Letters_1Components.append(text_17)\u000a    var_6Letters_1Components.append(text_19)\u000a    var_6Letters_1Components.append(text_20)\u000a    for thisComponent in var_6Letters_1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_11* updates\u000a        if t >= 0.0 and text_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_11.tStart = t  # underestimates by a little under one frame\u000a            text_11.frameNStart = frameN  # exact frame index\u000a            text_11.setAutoDraw(True)\u000a        elif text_11.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_11.setAutoDraw(False)\u000a        \u000a        # *text_12* updates\u000a        if t >= 3 and text_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_12.tStart = t  # underestimates by a little under one frame\u000a            text_12.frameNStart = frameN  # exact frame index\u000a            text_12.setAutoDraw(True)\u000a        elif text_12.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_12.setAutoDraw(False)\u000a        \u000a        # *text_14* updates\u000a        if t >= 6 and text_14.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_14.tStart = t  # underestimates by a little under one frame\u000a            text_14.frameNStart = frameN  # exact frame index\u000a            text_14.setAutoDraw(True)\u000a        elif text_14.status == STARTED and t >= (6 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_14.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_12* updates\u000a        if t >= 0 and TopUpperLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_12.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_12.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_12.setAutoDraw(True)\u000a        elif TopUpperLine_12.status == STARTED and t >= (0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_12.setAutoDraw(False)\u000a        \u000a        # *UpperText_12* updates\u000a        if t >= 0 and UpperText_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_12.tStart = t  # underestimates by a little under one frame\u000a            UpperText_12.frameNStart = frameN  # exact frame index\u000a            UpperText_12.setAutoDraw(True)\u000a        elif UpperText_12.status == STARTED and t >= (0 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_12.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_12* updates\u000a        if t >= 3 and UpperBrackets_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_12.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_12.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_12.setAutoDraw(True)\u000a        elif UpperBrackets_12.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_12.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_12* updates\u000a        if t >= 0.0 and BotUpperLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_12.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_12.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_12.setAutoDraw(True)\u000a        elif BotUpperLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_12.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_12* updates\u000a        if t >= 0.0 and TopLowerLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_12.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_12.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_12.setAutoDraw(True)\u000a        elif TopLowerLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_12.setAutoDraw(False)\u000a        \u000a        # *LowerText_12* updates\u000a        if t >= 11 and LowerText_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_12.tStart = t  # underestimates by a little under one frame\u000a            LowerText_12.frameNStart = frameN  # exact frame index\u000a            LowerText_12.setAutoDraw(True)\u000a        elif LowerText_12.status == STARTED and t >= (11 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_12.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_12* updates\u000a        if t >= 11 and LowerBrackets_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_12.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_12.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_12.setAutoDraw(True)\u000a        elif LowerBrackets_12.status == STARTED and t >= (11 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_12.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_12* updates\u000a        if t >= 0.0 and BotLowerLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_12.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_12.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_12.setAutoDraw(True)\u000a        elif BotLowerLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_12.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_12* updates\u000a        if t >= 0 and TrialCrossHair_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_12.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_12.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_12.setAutoDraw(True)\u000a        elif TrialCrossHair_12.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_12.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_12* updates\u000a        if t >= 17 and RestCrossHair_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_12.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_12.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_12.setAutoDraw(True)\u000a        elif RestCrossHair_12.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_12.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_12* updates\u000a        if t >= 0 and KeyboardResp_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_12.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_12.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_12.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_12.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_12.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_12.status = STOPPED\u000a        if KeyboardResp_12.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_12.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_12.rt.append(KeyboardResp_12.clock.getTime())\u000a        \u000a        # *text_17* updates\u000a        if t >= 11 and text_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_17.tStart = t  # underestimates by a little under one frame\u000a            text_17.frameNStart = frameN  # exact frame index\u000a            text_17.setAutoDraw(True)\u000a        elif text_17.status == STARTED and t >= (11 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_17.setAutoDraw(False)\u000a        \u000a        # *text_19* updates\u000a        if t >= 14 and text_19.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_19.tStart = t  # underestimates by a little under one frame\u000a            text_19.frameNStart = frameN  # exact frame index\u000a            text_19.setAutoDraw(True)\u000a        elif text_19.status == STARTED and t >= (14 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_19.setAutoDraw(False)\u000a        \u000a        # *text_20* updates\u000a        if t >= 17 and text_20.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_20.tStart = t  # underestimates by a little under one frame\u000a            text_20.frameNStart = frameN  # exact frame index\u000a            text_20.setAutoDraw(True)\u000a        elif text_20.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_20.setAutoDraw(False)\u000a        # *ISI_12* period\u000a        if t >= 0.0 and ISI_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_12.tStart = t  # underestimates by a little under one frame\u000a            ISI_12.frameNStart = frameN  # exact frame index\u000a            ISI_12.start(1)\u000a        elif ISI_12.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_12.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_1"-------\u000a    for thisComponent in var_6Letters_1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_12.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_12.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_12.keys',KeyboardResp_12.keys)\u000a    if KeyboardResp_12.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_12.rt', KeyboardResp_12.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "DemoTrialRealTimes"-------\u000a    t = 0\u000a    DemoTrialRealTimesClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(17.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_18.setText(u' A B C D E F ')\u000a    UpperBrackets_18.setText(u'  {   }      ')\u000a    LowerText_17.setText(u' a b c d e f ')\u000a    KeyboardResp_13 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_13.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    DemoTrialRealTimesComponents = []\u000a    DemoTrialRealTimesComponents.append(text_44)\u000a    DemoTrialRealTimesComponents.append(text_45)\u000a    DemoTrialRealTimesComponents.append(text_46)\u000a    DemoTrialRealTimesComponents.append(ISI_18)\u000a    DemoTrialRealTimesComponents.append(TopUpperLine_18)\u000a    DemoTrialRealTimesComponents.append(UpperText_18)\u000a    DemoTrialRealTimesComponents.append(UpperBrackets_18)\u000a    DemoTrialRealTimesComponents.append(BotUpperLine_18)\u000a    DemoTrialRealTimesComponents.append(TopLowerLine_18)\u000a    DemoTrialRealTimesComponents.append(LowerText_17)\u000a    DemoTrialRealTimesComponents.append(LowerBrackets_17)\u000a    DemoTrialRealTimesComponents.append(BotLowerLine_18)\u000a    DemoTrialRealTimesComponents.append(TrialCrossHair_18)\u000a    DemoTrialRealTimesComponents.append(RestCrossHair_18)\u000a    DemoTrialRealTimesComponents.append(KeyboardResp_13)\u000a    DemoTrialRealTimesComponents.append(text_48)\u000a    DemoTrialRealTimesComponents.append(text_49)\u000a    for thisComponent in DemoTrialRealTimesComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "DemoTrialRealTimes"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = DemoTrialRealTimesClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_44* updates\u000a        if t >= 0.0 and text_44.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_44.tStart = t  # underestimates by a little under one frame\u000a            text_44.frameNStart = frameN  # exact frame index\u000a            text_44.setAutoDraw(True)\u000a        elif text_44.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_44.setAutoDraw(False)\u000a        \u000a        # *text_45* updates\u000a        if t >= 3 and text_45.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_45.tStart = t  # underestimates by a little under one frame\u000a            text_45.frameNStart = frameN  # exact frame index\u000a            text_45.setAutoDraw(True)\u000a        elif text_45.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_45.setAutoDraw(False)\u000a        \u000a        # *text_46* updates\u000a        if t >= 5 and text_46.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_46.tStart = t  # underestimates by a little under one frame\u000a            text_46.frameNStart = frameN  # exact frame index\u000a            text_46.setAutoDraw(True)\u000a        elif text_46.status == STARTED and t >= (5 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_46.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_18* updates\u000a        if t >= 0 and TopUpperLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_18.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_18.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_18.setAutoDraw(True)\u000a        elif TopUpperLine_18.status == STARTED and t >= (0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_18.setAutoDraw(False)\u000a        \u000a        # *UpperText_18* updates\u000a        if t >= 3 and UpperText_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_18.tStart = t  # underestimates by a little under one frame\u000a            UpperText_18.frameNStart = frameN  # exact frame index\u000a            UpperText_18.setAutoDraw(True)\u000a        elif UpperText_18.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_18.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_18* updates\u000a        if t >= 3 and UpperBrackets_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_18.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_18.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_18.setAutoDraw(True)\u000a        elif UpperBrackets_18.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_18.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_18* updates\u000a        if t >= 0.0 and BotUpperLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_18.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_18.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_18.setAutoDraw(True)\u000a        elif BotUpperLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_18.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_18* updates\u000a        if t >= 0.0 and TopLowerLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_18.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_18.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_18.setAutoDraw(True)\u000a        elif TopLowerLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_18.setAutoDraw(False)\u000a        \u000a        # *LowerText_17* updates\u000a        if t >= 10 and LowerText_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_17.tStart = t  # underestimates by a little under one frame\u000a            LowerText_17.frameNStart = frameN  # exact frame index\u000a            LowerText_17.setAutoDraw(True)\u000a        elif LowerText_17.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_17.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_17* updates\u000a        if t >= 10 and LowerBrackets_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_17.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_17.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_17.setAutoDraw(True)\u000a        elif LowerBrackets_17.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_17.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_18* updates\u000a        if t >= 0.0 and BotLowerLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_18.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_18.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_18.setAutoDraw(True)\u000a        elif BotLowerLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_18.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_18* updates\u000a        if t >= 0 and TrialCrossHair_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_18.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_18.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_18.setAutoDraw(True)\u000a        elif TrialCrossHair_18.status == STARTED and t >= (0 + (12-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_18.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_18* updates\u000a        if t >= 12 and RestCrossHair_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_18.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_18.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_18.setAutoDraw(True)\u000a        elif RestCrossHair_18.status == STARTED and t >= (12 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_18.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_13* updates\u000a        if t >= 0 and KeyboardResp_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_13.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_13.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_13.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_13.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_13.status = STOPPED\u000a        if KeyboardResp_13.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_13.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_13.rt.append(KeyboardResp_13.clock.getTime())\u000a        \u000a        # *text_48* updates\u000a        if t >= 10 and text_48.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_48.tStart = t  # underestimates by a little under one frame\u000a            text_48.frameNStart = frameN  # exact frame index\u000a            text_48.setAutoDraw(True)\u000a        elif text_48.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_48.setAutoDraw(False)\u000a        \u000a        # *text_49* updates\u000a        if t >= 12 and text_49.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_49.tStart = t  # underestimates by a little under one frame\u000a            text_49.frameNStart = frameN  # exact frame index\u000a            text_49.setAutoDraw(True)\u000a        elif text_49.status == STARTED and t >= (12 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_49.setAutoDraw(False)\u000a        # *ISI_18* period\u000a        if t >= 0.0 and ISI_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_18.tStart = t  # underestimates by a little under one frame\u000a            ISI_18.frameNStart = frameN  # exact frame index\u000a            ISI_18.start(1)\u000a        elif ISI_18.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_18.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in DemoTrialRealTimesComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "DemoTrialRealTimes"-------\u000a    for thisComponent in DemoTrialRealTimesComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_13.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_13.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_13.keys',KeyboardResp_13.keys)\u000a    if KeyboardResp_13.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_13.rt', KeyboardResp_13.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "NumLettersToRem"-------\u000a    t = 0\u000a    NumLettersToRemClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(30.000000)\u000a    # update component parameters for each repeat\u000a    UpBrack1.setText('        { }  ')\u000a    UpperText_17.setText(' A B C D E F ')\u000a    UpperBrackets_17.setText('')\u000a    # keep track of which components have finished\u000a    NumLettersToRemComponents = []\u000a    NumLettersToRemComponents.append(text_15)\u000a    NumLettersToRemComponents.append(text_33)\u000a    NumLettersToRemComponents.append(text_34)\u000a    NumLettersToRemComponents.append(text_3)\u000a    NumLettersToRemComponents.append(text_35)\u000a    NumLettersToRemComponents.append(UpBrack1)\u000a    NumLettersToRemComponents.append(ISI_17)\u000a    NumLettersToRemComponents.append(TopUpperLine_17)\u000a    NumLettersToRemComponents.append(UpperText_17)\u000a    NumLettersToRemComponents.append(UpperBrackets_17)\u000a    NumLettersToRemComponents.append(BotUpperLine_17)\u000a    NumLettersToRemComponents.append(TopLowerLine_17)\u000a    NumLettersToRemComponents.append(BotLowerLine_17)\u000a    NumLettersToRemComponents.append(TrialCrossHair_17)\u000a    NumLettersToRemComponents.append(RestCrossHair_17)\u000a    NumLettersToRemComponents.append(UpBrack2)\u000a    NumLettersToRemComponents.append(UpBrack3)\u000a    NumLettersToRemComponents.append(UpBrack4)\u000a    NumLettersToRemComponents.append(UpBrack5)\u000a    NumLettersToRemComponents.append(UpBrack6)\u000a    NumLettersToRemComponents.append(text_38)\u000a    NumLettersToRemComponents.append(text_39)\u000a    NumLettersToRemComponents.append(text_40)\u000a    NumLettersToRemComponents.append(text_41)\u000a    NumLettersToRemComponents.append(text_42)\u000a    NumLettersToRemComponents.append(text_43)\u000a    for thisComponent in NumLettersToRemComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "NumLettersToRem"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = NumLettersToRemClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_15* updates\u000a        if t >= 0.0 and text_15.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_15.tStart = t  # underestimates by a little under one frame\u000a            text_15.frameNStart = frameN  # exact frame index\u000a            text_15.setAutoDraw(True)\u000a        elif text_15.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_15.setAutoDraw(False)\u000a        \u000a        # *text_33* updates\u000a        if t >= 3 and text_33.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_33.tStart = t  # underestimates by a little under one frame\u000a            text_33.frameNStart = frameN  # exact frame index\u000a            text_33.setAutoDraw(True)\u000a        elif text_33.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_33.setAutoDraw(False)\u000a        \u000a        # *text_34* updates\u000a        if t >= 6 and text_34.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_34.tStart = t  # underestimates by a little under one frame\u000a            text_34.frameNStart = frameN  # exact frame index\u000a            text_34.setAutoDraw(True)\u000a        elif text_34.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_34.setAutoDraw(False)\u000a        \u000a        # *text_3* updates\u000a        if t >= 9 and text_3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_3.tStart = t  # underestimates by a little under one frame\u000a            text_3.frameNStart = frameN  # exact frame index\u000a            text_3.setAutoDraw(True)\u000a        elif text_3.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_3.setAutoDraw(False)\u000a        \u000a        # *text_35* updates\u000a        if t >= 12 and text_35.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_35.tStart = t  # underestimates by a little under one frame\u000a            text_35.frameNStart = frameN  # exact frame index\u000a            text_35.setAutoDraw(True)\u000a        elif text_35.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_35.setAutoDraw(False)\u000a        \u000a        # *UpBrack1* updates\u000a        if t >= 15 and UpBrack1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack1.tStart = t  # underestimates by a little under one frame\u000a            UpBrack1.frameNStart = frameN  # exact frame index\u000a            UpBrack1.setAutoDraw(True)\u000a        elif UpBrack1.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack1.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_17* updates\u000a        if t >= 0 and TopUpperLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_17.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_17.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_17.setAutoDraw(True)\u000a        elif TopUpperLine_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_17.setAutoDraw(False)\u000a        \u000a        # *UpperText_17* updates\u000a        if t >= 0 and UpperText_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_17.tStart = t  # underestimates by a little under one frame\u000a            UpperText_17.frameNStart = frameN  # exact frame index\u000a            UpperText_17.setAutoDraw(True)\u000a        elif UpperText_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_17.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_17* updates\u000a        if t >= 0.0 and UpperBrackets_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_17.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_17.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_17.setAutoDraw(True)\u000a        elif UpperBrackets_17.status == STARTED and t >= (0.0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_17.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_17* updates\u000a        if t >= 0.0 and BotUpperLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_17.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_17.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_17.setAutoDraw(True)\u000a        elif BotUpperLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_17.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_17* updates\u000a        if t >= 0.0 and TopLowerLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_17.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_17.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_17.setAutoDraw(True)\u000a        elif TopLowerLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_17.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_17* updates\u000a        if t >= 0.0 and BotLowerLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_17.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_17.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_17.setAutoDraw(True)\u000a        elif BotLowerLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_17.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_17* updates\u000a        if t >= 0 and TrialCrossHair_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_17.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_17.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_17.setAutoDraw(True)\u000a        elif TrialCrossHair_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_17.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_17* updates\u000a        if t >= 0.0 and RestCrossHair_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_17.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_17.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_17.setAutoDraw(True)\u000a        elif RestCrossHair_17.status == STARTED and t >= (0.0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_17.setAutoDraw(False)\u000a        \u000a        # *UpBrack2* updates\u000a        if t >= 18 and UpBrack2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack2.tStart = t  # underestimates by a little under one frame\u000a            UpBrack2.frameNStart = frameN  # exact frame index\u000a            UpBrack2.setAutoDraw(True)\u000a        elif UpBrack2.status == STARTED and t >= (18 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack2.setAutoDraw(False)\u000a        \u000a        # *UpBrack3* updates\u000a        if t >= 20 and UpBrack3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack3.tStart = t  # underestimates by a little under one frame\u000a            UpBrack3.frameNStart = frameN  # exact frame index\u000a            UpBrack3.setAutoDraw(True)\u000a        elif UpBrack3.status == STARTED and t >= (20 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack3.setAutoDraw(False)\u000a        \u000a        # *UpBrack4* updates\u000a        if t >= 22 and UpBrack4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack4.tStart = t  # underestimates by a little under one frame\u000a            UpBrack4.frameNStart = frameN  # exact frame index\u000a            UpBrack4.setAutoDraw(True)\u000a        elif UpBrack4.status == STARTED and t >= (22 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack4.setAutoDraw(False)\u000a        \u000a        # *UpBrack5* updates\u000a        if t >= 24 and UpBrack5.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack5.tStart = t  # underestimates by a little under one frame\u000a            UpBrack5.frameNStart = frameN  # exact frame index\u000a            UpBrack5.setAutoDraw(True)\u000a        elif UpBrack5.status == STARTED and t >= (24 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack5.setAutoDraw(False)\u000a        \u000a        # *UpBrack6* updates\u000a        if t >= 26 and UpBrack6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack6.tStart = t  # underestimates by a little under one frame\u000a            UpBrack6.frameNStart = frameN  # exact frame index\u000a            UpBrack6.setAutoDraw(True)\u000a        elif UpBrack6.status == STARTED and t >= (26 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack6.setAutoDraw(False)\u000a        \u000a        # *text_38* updates\u000a        if t >= 15 and text_38.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_38.tStart = t  # underestimates by a little under one frame\u000a            text_38.frameNStart = frameN  # exact frame index\u000a            text_38.setAutoDraw(True)\u000a        elif text_38.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_38.setAutoDraw(False)\u000a        \u000a        # *text_39* updates\u000a        if t >= 18 and text_39.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_39.tStart = t  # underestimates by a little under one frame\u000a            text_39.frameNStart = frameN  # exact frame index\u000a            text_39.setAutoDraw(True)\u000a        elif text_39.status == STARTED and t >= (18 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_39.setAutoDraw(False)\u000a        \u000a        # *text_40* updates\u000a        if t >= 20 and text_40.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_40.tStart = t  # underestimates by a little under one frame\u000a            text_40.frameNStart = frameN  # exact frame index\u000a            text_40.setAutoDraw(True)\u000a        elif text_40.status == STARTED and t >= (20 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_40.setAutoDraw(False)\u000a        \u000a        # *text_41* updates\u000a        if t >= 22 and text_41.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_41.tStart = t  # underestimates by a little under one frame\u000a            text_41.frameNStart = frameN  # exact frame index\u000a            text_41.setAutoDraw(True)\u000a        elif text_41.status == STARTED and t >= (22 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_41.setAutoDraw(False)\u000a        \u000a        # *text_42* updates\u000a        if t >= 24 and text_42.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_42.tStart = t  # underestimates by a little under one frame\u000a            text_42.frameNStart = frameN  # exact frame index\u000a            text_42.setAutoDraw(True)\u000a        elif text_42.status == STARTED and t >= (24 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_42.setAutoDraw(False)\u000a        \u000a        # *text_43* updates\u000a        if t >= 26 and text_43.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_43.tStart = t  # underestimates by a little under one frame\u000a            text_43.frameNStart = frameN  # exact frame index\u000a            text_43.setAutoDraw(True)\u000a        elif text_43.status == STARTED and t >= (26 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_43.setAutoDraw(False)\u000a        # *ISI_17* period\u000a        if t >= 0.0 and ISI_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_17.tStart = t  # underestimates by a little under one frame\u000a            ISI_17.frameNStart = frameN  # exact frame index\u000a            ISI_17.start(1)\u000a        elif ISI_17.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_17.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in NumLettersToRemComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "NumLettersToRem"-------\u000a    for thisComponent in NumLettersToRemComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "TrialParts_1"-------\u000a    t = 0\u000a    TrialParts_1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(25.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_16.setText('')\u000a    UpperBrackets_16.setText('')\u000a    LowerText_16.setText('')\u000a    # keep track of which components have finished\u000a    TrialParts_1Components = []\u000a    TrialParts_1Components.append(text_27)\u000a    TrialParts_1Components.append(text_30)\u000a    TrialParts_1Components.append(text_31)\u000a    TrialParts_1Components.append(text_32)\u000a    TrialParts_1Components.append(ISI_16)\u000a    TrialParts_1Components.append(TopUpperLine_16)\u000a    TrialParts_1Components.append(UpperText_16)\u000a    TrialParts_1Components.append(UpperBrackets_16)\u000a    TrialParts_1Components.append(BotUpperLine_16)\u000a    TrialParts_1Components.append(TopLowerLine_16)\u000a    TrialParts_1Components.append(LowerText_16)\u000a    TrialParts_1Components.append(LowerBrackets_16)\u000a    TrialParts_1Components.append(BotLowerLine_16)\u000a    TrialParts_1Components.append(TrialCrossHair_16)\u000a    TrialParts_1Components.append(RestCrossHair_16)\u000a    TrialParts_1Components.append(text_36)\u000a    TrialParts_1Components.append(text_37)\u000a    TrialParts_1Components.append(text_50)\u000a    for thisComponent in TrialParts_1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialParts_1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialParts_1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_27* updates\u000a        if t >= 0.0 and text_27.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_27.tStart = t  # underestimates by a little under one frame\u000a            text_27.frameNStart = frameN  # exact frame index\u000a            text_27.setAutoDraw(True)\u000a        elif text_27.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_27.setAutoDraw(False)\u000a        \u000a        # *text_30* updates\u000a        if t >= 3 and text_30.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_30.tStart = t  # underestimates by a little under one frame\u000a            text_30.frameNStart = frameN  # exact frame index\u000a            text_30.setAutoDraw(True)\u000a        elif text_30.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_30.setAutoDraw(False)\u000a        \u000a        # *text_31* updates\u000a        if t >= 6 and text_31.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_31.tStart = t  # underestimates by a little under one frame\u000a            text_31.frameNStart = frameN  # exact frame index\u000a            text_31.setAutoDraw(True)\u000a        elif text_31.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_31.setAutoDraw(False)\u000a        \u000a        # *text_32* updates\u000a        if t >= 9 and text_32.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_32.tStart = t  # underestimates by a little under one frame\u000a            text_32.frameNStart = frameN  # exact frame index\u000a            text_32.setAutoDraw(True)\u000a        elif text_32.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_32.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_16* updates\u000a        if t >= 0 and TopUpperLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_16.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_16.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_16.setAutoDraw(True)\u000a        elif TopUpperLine_16.status == STARTED and t >= (0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_16.setAutoDraw(False)\u000a        \u000a        # *UpperText_16* updates\u000a        if t >= 0 and UpperText_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_16.tStart = t  # underestimates by a little under one frame\u000a            UpperText_16.frameNStart = frameN  # exact frame index\u000a            UpperText_16.setAutoDraw(True)\u000a        elif UpperText_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_16.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_16* updates\u000a        if t >= 0 and UpperBrackets_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_16.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_16.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_16.setAutoDraw(True)\u000a        elif UpperBrackets_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_16.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_16* updates\u000a        if t >= 0.0 and BotUpperLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_16.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_16.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_16.setAutoDraw(True)\u000a        elif BotUpperLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_16.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_16* updates\u000a        if t >= 0.0 and TopLowerLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_16.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_16.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_16.setAutoDraw(True)\u000a        elif TopLowerLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_16.setAutoDraw(False)\u000a        \u000a        # *LowerText_16* updates\u000a        if t >= 0 and LowerText_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_16.tStart = t  # underestimates by a little under one frame\u000a            LowerText_16.frameNStart = frameN  # exact frame index\u000a            LowerText_16.setAutoDraw(True)\u000a        elif LowerText_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_16.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_16* updates\u000a        if t >= 0 and LowerBrackets_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_16.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_16.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_16.setAutoDraw(True)\u000a        elif LowerBrackets_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_16.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_16* updates\u000a        if t >= 0.0 and BotLowerLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_16.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_16.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_16.setAutoDraw(True)\u000a        elif BotLowerLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_16.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_16* updates\u000a        if t >= 0 and TrialCrossHair_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_16.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_16.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_16.setAutoDraw(True)\u000a        elif TrialCrossHair_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_16.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_16* updates\u000a        if t >= 0 and RestCrossHair_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_16.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_16.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_16.setAutoDraw(True)\u000a        elif RestCrossHair_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_16.setAutoDraw(False)\u000a        \u000a        # *text_36* updates\u000a        if t >= 12 and text_36.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_36.tStart = t  # underestimates by a little under one frame\u000a            text_36.frameNStart = frameN  # exact frame index\u000a            text_36.setAutoDraw(True)\u000a        elif text_36.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_36.setAutoDraw(False)\u000a        \u000a        # *text_37* updates\u000a        if t >= 15 and text_37.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_37.tStart = t  # underestimates by a little under one frame\u000a            text_37.frameNStart = frameN  # exact frame index\u000a            text_37.setAutoDraw(True)\u000a        elif text_37.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_37.setAutoDraw(False)\u000a        \u000a        # *text_50* updates\u000a        if t >= 20 and text_50.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_50.tStart = t  # underestimates by a little under one frame\u000a            text_50.frameNStart = frameN  # exact frame index\u000a            text_50.setAutoDraw(True)\u000a        elif text_50.status == STARTED and t >= (20 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_50.setAutoDraw(False)\u000a        # *ISI_16* period\u000a        if t >= 0.0 and ISI_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_16.tStart = t  # underestimates by a little under one frame\u000a            ISI_16.frameNStart = frameN  # exact frame index\u000a            ISI_16.start(1)\u000a        elif ISI_16.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_16.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialParts_1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialParts_1"-------\u000a    for thisComponent in TrialParts_1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "trial5_2"-------\u000a    t = 0\u000a    trial5_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    UpperText.setText(u' L K R G M X ')\u000a    UpperBrackets.setText(u'  {         }')\u000a    LowerText.setText(u' b t y g q j ')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trial5_2Components = []\u000a    trial5_2Components.append(ISI)\u000a    trial5_2Components.append(TopUpperLine)\u000a    trial5_2Components.append(UpperText)\u000a    trial5_2Components.append(UpperBrackets)\u000a    trial5_2Components.append(BotUpperLine)\u000a    trial5_2Components.append(TopLowerLine)\u000a    trial5_2Components.append(LowerText)\u000a    trial5_2Components.append(LowerBrackets)\u000a    trial5_2Components.append(BotLowerLine)\u000a    trial5_2Components.append(TrialCrossHair)\u000a    trial5_2Components.append(RestCrossHair)\u000a    trial5_2Components.append(resp)\u000a    for thisComponent in trial5_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "trial5_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial5_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *TopUpperLine* updates\u000a        if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine.frameNStart = frameN  # exact frame index\u000a            TopUpperLine.setAutoDraw(True)\u000a        elif TopUpperLine.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine.setAutoDraw(False)\u000a        \u000a        # *UpperText* updates\u000a        if t >= 0 and UpperText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText.tStart = t  # underestimates by a little under one frame\u000a            UpperText.frameNStart = frameN  # exact frame index\u000a            UpperText.setAutoDraw(True)\u000a        elif UpperText.status == STARTED and t >= (0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets* updates\u000a        if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets.frameNStart = frameN  # exact frame index\u000a            UpperBrackets.setAutoDraw(True)\u000a        elif UpperBrackets.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine* updates\u000a        if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine.frameNStart = frameN  # exact frame index\u000a            BotUpperLine.setAutoDraw(True)\u000a        elif BotUpperLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine* updates\u000a        if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine.frameNStart = frameN  # exact frame index\u000a            TopLowerLine.setAutoDraw(True)\u000a        elif TopLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine.setAutoDraw(False)\u000a        \u000a        # *LowerText* updates\u000a        if t >= 7 and LowerText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText.tStart = t  # underestimates by a little under one frame\u000a            LowerText.frameNStart = frameN  # exact frame index\u000a            LowerText.setAutoDraw(True)\u000a        elif LowerText.status == STARTED and t >= (7 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets* updates\u000a        if t >= 7 and LowerBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets.frameNStart = frameN  # exact frame index\u000a            LowerBrackets.setAutoDraw(True)\u000a        elif LowerBrackets.status == STARTED and t >= (7 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine* updates\u000a        if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine.frameNStart = frameN  # exact frame index\u000a            BotLowerLine.setAutoDraw(True)\u000a        elif BotLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair* updates\u000a        if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair.setAutoDraw(True)\u000a        elif TrialCrossHair.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair* updates\u000a        if t >= 9 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (9 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # *resp* updates\u000a        if t >= 7 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif resp.status == STARTED and t >= (7 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(u'6')) or (resp.keys == u'6'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(1)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial5_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "trial5_2"-------\u000a    for thisComponent in trial5_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(u'6').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('resp.keys',resp.keys)\u000a    thisExp.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        thisExp.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "TrialFeedBack"-------\u000a    t = 0\u000a    TrialFeedBackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.000000)\u000a    # update component parameters for each repeat\u000a    if ((resp.corr) & (resp.rt < 2.0)):#stored on last run routine\u000a      msg="Correct and on time! RT=%.3f" %(resp.rt)\u000a    elif ((resp.corr) & (resp.rt > 2.0)):#stored on last run routine\u000a      msg="Correct, but too slow!\u005cn RT=%.3f\u005cnResponse time should be less than two seconds." %(resp.rt)\u000a    else:\u000a      if resp.rt < 2.0:\u000a        msg="Oops! That was incorrect, but on time!"\u000a      else: \u000a        msg="Oops! That was incorrect and too slow!"\u000a    text_47.setText(msg)\u000a    # keep track of which components have finished\u000a    TrialFeedBackComponents = []\u000a    TrialFeedBackComponents.append(text_47)\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialFeedBack"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialFeedBackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text_47* updates\u000a        if t >= 0.0 and text_47.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_47.tStart = t  # underestimates by a little under one frame\u000a            text_47.frameNStart = frameN  # exact frame index\u000a            text_47.setAutoDraw(True)\u000a        elif text_47.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_47.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialFeedBackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialFeedBack"-------\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    msg='Ended'\u000a    win.close()\u000a#    win.close()\u000a\u000adef Test(subid,visitid):\u000a    expInfo = {u'Visit ID': u'9999', u'Participant ID': u'1'}\u000a    print 'subid is %s'%(subid)\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a    else:\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid    \u000a    # Store info about the experiment session\u000a\u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'],expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=False,\u000a        dataFileName=filename)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=ScreenToUse, color=[-1,-1,-1], colorSpace='rgb',\u000a        blendMode='average', useFBO=True,\u000a        units='cm')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial_2"\u000a    trial_2Clock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text='      { }    ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Initialize components for Routine "TrialFeedBack"\u000a    TrialFeedBackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    text = visual.TextStim(win=win, ori=0, name='text',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    #------Prepare to start Routine "trial_2"-------\u000a    t = 0\u000a    trial_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    UpperText.setText(' A B C D E F ')\u000a    UpperBrackets.setText('  {         }')\u000a    LowerText.setText(' a b c d e f ')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trial_2Components = []\u000a    trial_2Components.append(ISI)\u000a    trial_2Components.append(TopUpperLine)\u000a    trial_2Components.append(UpperText)\u000a    trial_2Components.append(UpperBrackets)\u000a    trial_2Components.append(BotUpperLine)\u000a    trial_2Components.append(TopLowerLine)\u000a    trial_2Components.append(LowerText)\u000a    trial_2Components.append(LowerBrackets)\u000a    trial_2Components.append(BotLowerLine)\u000a    trial_2Components.append(TrialCrossHair)\u000a    trial_2Components.append(RestCrossHair)\u000a    trial_2Components.append(resp)\u000a    for thisComponent in trial_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "trial_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *TopUpperLine* updates\u000a        if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine.frameNStart = frameN  # exact frame index\u000a            TopUpperLine.setAutoDraw(True)\u000a        elif TopUpperLine.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine.setAutoDraw(False)\u000a        \u000a        # *UpperText* updates\u000a        if t >= 0 and UpperText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText.tStart = t  # underestimates by a little under one frame\u000a            UpperText.frameNStart = frameN  # exact frame index\u000a            UpperText.setAutoDraw(True)\u000a        elif UpperText.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets* updates\u000a        if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets.frameNStart = frameN  # exact frame index\u000a            UpperBrackets.setAutoDraw(True)\u000a        elif UpperBrackets.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine* updates\u000a        if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine.frameNStart = frameN  # exact frame index\u000a            BotUpperLine.setAutoDraw(True)\u000a        elif BotUpperLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine* updates\u000a        if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine.frameNStart = frameN  # exact frame index\u000a            TopLowerLine.setAutoDraw(True)\u000a        elif TopLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine.setAutoDraw(False)\u000a        \u000a        # *LowerText* updates\u000a        if t >= 7 and LowerText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText.tStart = t  # underestimates by a little under one frame\u000a            LowerText.frameNStart = frameN  # exact frame index\u000a            LowerText.setAutoDraw(True)\u000a        elif LowerText.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets* updates\u000a        if t >= 7 and LowerBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets.frameNStart = frameN  # exact frame index\u000a            LowerBrackets.setAutoDraw(True)\u000a        elif LowerBrackets.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine* updates\u000a        if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine.frameNStart = frameN  # exact frame index\u000a            BotLowerLine.setAutoDraw(True)\u000a        elif BotLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair* updates\u000a        if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair.setAutoDraw(True)\u000a        elif TrialCrossHair.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair* updates\u000a        if t >= 9 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (9 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # *resp* updates\u000a        if t >= 7 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif resp.status == STARTED and t >= (7 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(u'6')) or (resp.keys == u'6'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(1)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "trial_2"-------\u000a    for thisComponent in trial_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(u'6').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('resp.keys',resp.keys)\u000a    thisExp.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        thisExp.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "TrialFeedBack"-------\u000a    t = 0\u000a    TrialFeedBackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.000000)\u000a    # update component parameters for each repeat\u000a    if ((resp.corr) & (resp.rt < 2.0)):#stored on last run routine\u000a      msg="Correct and on time! RT=%.3f" %(resp.rt)\u000a    elif ((resp.corr) & (resp.rt > 2.0)):#stored on last run routine\u000a      msg="Correct, but too slow!\u005cn RT=%.3f\u005cnResponse time should be less than two seconds." %(resp.rt)\u000a    else:\u000a      if resp.rt < 2.0:\u000a        msg="Oops! That was incorrect, but on time!"\u000a      else: \u000a        msg="Oops! That was incorrect and too slow!"\u000a    text.setText(msg)\u000a    # keep track of which components have finished\u000a    TrialFeedBackComponents = []\u000a    TrialFeedBackComponents.append(text)\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialFeedBack"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialFeedBackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        elif text.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialFeedBackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialFeedBack"-------\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    msg='Ended'\u000a\u000a    win.close()\u000a\u000a
p39
sS'thisTrial'
p40
g1
(cpsychopy.data
TrialType
p41
c__builtin__
dict
p42
(dp43
S'RetDur'
p44
g29
(g30
(S'i8'
I0
I1
tRp45
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp46
sS'BotBrack'
p47
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp48
sS'StimDur'
p49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp50
sS'UpBrack'
p51
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp52
sS'ProbeDurITI'
p53
g29
(g31
S'{\x14\xaeG\xe1\xfa\x10@'
tRp54
sS'ProbeDur'
p55
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp56
sS'ProbeStart'
p57
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp58
sS'TrialDur'
p59
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp60
sS'ITI'
p61
g29
(g31
S'{\x14\xaeG\xe1\xfa\x10@'
tRp62
sS'StimSet'
p63
VNDGJXB
p64
sS'RetStart'
p65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp66
sS'ProbeLet'
p67
V 
sS'TrialITIDur'
p68
g29
(g31
S'{\x14\xaeG\xe1\xfa\x18@'
tRp69
sS'Correct'
p70
Vnone
p71
stRp72
sS'_exp'
p73
I182260752
sg10
S'trials'
p74
sg6
S'PartialTrialFunction.py'
p75
sS'thisRepN'
p76
I0
sg20
I01
sg21
g22
sS'data'
p77
g1
(cpsychopy.data
DataHandler
p78
g42
(dp79
g18
cnumpy.ma.core
_mareconstruct
p80
(cnumpy.ma.core
MaskedArray
p81
cnumpy
ndarray
p82
(I0
tp83
S'b'
tRp84
(I1
(I30
I1
tg30
(S'f4'
I0
I1
tRp85
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01'
Ntbsg19
g80
(g81
g82
g83
S'b'
tRp86
(I1
(I30
I1
tg85
I00
S'\xcc\xf1\x8c?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01'
NtbsS'ran'
p87
g80
(g81
g82
g83
S'b'
tRp88
(I1
(I30
I1
tg85
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
cnumpy.core.multiarray
_reconstruct
p89
(g82
(I0
tS'b'
tRp90
(I1
(I30
I1
tg30
(S'O4'
I0
I1
tRp91
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp92
S'down'
p93
aS'--'
p94
aS'--'
p95
aS'--'
p96
aS'--'
p97
aS'--'
p98
aS'--'
p99
aS'--'
p100
aS'--'
p101
aS'--'
p102
aS'--'
p103
aS'--'
p104
aS'--'
p105
aS'--'
p106
aS'--'
p107
aS'--'
p108
aS'--'
p109
aS'--'
p110
aS'--'
p111
aS'--'
p112
aS'--'
p113
aS'--'
p114
aS'--'
p115
aS'--'
p116
aS'--'
p117
aS'--'
p118
aS'--'
p119
aS'--'
p120
aS'--'
p121
aS'--'
p122
atbsg16
g80
(g81
g82
g83
S'b'
tRp123
(I1
(I30
I1
tg85
I00
S'%d\xadN%d\xadN\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01'
NtbsS'order'
p124
g80
(g81
g82
g83
S'b'
tRp125
(I1
(I30
I1
tg85
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01'
NtbstRp126
(dp127
S'isNumeric'
p128
(dp129
g18
I01
sg87
I01
sg16
I01
sg19
I01
sg17
I00
sg124
I01
ssg74
g36
sS'dataTypes'
p130
(lp131
g87
ag124
ag16
ag17
ag18
ag19
asS'dataShape'
p132
(lp133
I30
aI1
asbsS'method'
p134
Vsequential
p135
sS'sequenceIndices'
p136
g89
(g82
(I0
tS'b'
tRp137
(I1
(I30
I1
tg30
(S'i4'
I0
I1
tRp138
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00'
tbsS'finished'
p139
I00
sS'nReps'
p140
I1
sS'nRemaining'
p141
I28
sS'trialList'
p142
(lp143
g1
(g41
g42
(dp144
g44
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp145
sg47
g29
(g45
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp146
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp147
sg51
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp148
sg53
g29
(g31
S'\xaeG\xe1z\x14\xae\x1b@'
tRp149
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp150
sg57
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp151
sg59
g29
(g45
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp152
sg61
g29
(g31
S'\xaeG\xe1z\x14\xae\x13@'
tRp153
sg63
VKTJDRY
p154
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp155
sg67
Vtbnmqx
p156
sg68
g29
(g31
S'\xd7\xa3p=\n\xd7!@'
tRp157
sg70
Vdown
p158
stRp159
ag72
ag1
(g41
g42
(dp160
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp161
sg47
g29
(g45
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp162
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp163
sg51
g29
(g45
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp164
sg53
g29
(g31
S'Nb\x10X94\x18@'
tRp165
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp166
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp167
sg59
g29
(g45
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp168
sg61
g29
(g31
S'Nb\x10X94\x10@'
tRp169
sg63
VNWQMYF
p170
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp171
sg67
Vjhbrxg
p172
sg68
g29
(g31
S'&1\x08\xac\x1c\x1a*@'
tRp173
sg70
Vright
p174
stRp175
ag1
(g41
g42
(dp176
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp177
sg47
g29
(g45
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp178
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp179
sg51
g29
(g45
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp180
sg53
g29
(g31
S'\xb6\xf3\xfd\xd4xi\x19@'
tRp181
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp182
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp183
sg59
g29
(g45
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp184
sg61
g29
(g31
S'\xb6\xf3\xfd\xd4xi\x11@'
tRp185
sg63
VJNDLBY
p186
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp187
sg67
Vtfmqgd
p188
sg68
g29
(g31
S'\xdb\xf9~j\xbc\xb4*@'
tRp189
sg70
g158
stRp190
ag1
(g41
g42
(dp191
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp192
sg47
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp193
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp194
sg51
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp195
sg53
g29
(g31
S'\xd1"\xdb\xf9~\xea\x12@'
tRp196
sg55
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp197
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp198
sg59
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp199
sg61
g29
(g31
S'\xd1"\xdb\xf9~\xea\x12@'
tRp200
sg63
VJXKMYH
p201
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp202
sg67
V 
sg68
g29
(g31
S"i\x91\xed|?u'@"
tRp203
sg70
g71
stRp204
ag1
(g41
g42
(dp205
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp206
sg47
g29
(g45
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp207
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp208
sg51
g29
(g45
S'\x0c\x00\x00\x00\x00\x00\x00\x00'
tRp209
sg53
g29
(g31
S'\xc5 \xb0rh\x11\x18@'
tRp210
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp211
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp212
sg59
g29
(g45
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp213
sg61
g29
(g31
S'\xc4 \xb0rh\x11\x10@'
tRp214
sg63
VKNTYRB
p215
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp216
sg67
Vjfgldw
p217
sg68
g29
(g31
S'c\x10X9\xb4\x08*@'
tRp218
sg70
g174
stRp219
ag1
(g41
g42
(dp220
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp221
sg47
g29
(g45
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp222
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp223
sg51
g29
(g45
S'"\x00\x00\x00\x00\x00\x00\x00'
tRp224
sg53
g29
(g31
S'\x8cl\xe7\xfb\xa9\xf1\x19@'
tRp225
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp226
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp227
sg59
g29
(g45
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp228
sg61
g29
(g31
S'\x8cl\xe7\xfb\xa9\xf1\x11@'
tRp229
sg63
VHQDTGF
p230
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp231
sg67
Vlbwnrx
p232
sg68
g29
(g31
S'E\xb6\xf3\xfd\xd4\xf8*@'
tRp233
sg70
g174
stRp234
ag1
(g41
g42
(dp235
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp236
sg47
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp237
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp238
sg51
g29
(g45
S'"\x00\x00\x00\x00\x00\x00\x00'
tRp239
sg53
g29
(g31
S'\xb0rh\x91\xed\xfc\x10@'
tRp240
sg55
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp241
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp242
sg59
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp243
sg61
g29
(g31
S'\xb0rh\x91\xed\xfc\x10@'
tRp244
sg63
VKBTDYW
p245
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp246
sg67
V 
sg68
g29
(g31
S'X9\xb4\xc8v~&@'
tRp247
sg70
g71
stRp248
ag1
(g41
g42
(dp249
g44
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp250
sg47
g29
(g45
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp251
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp252
sg51
g29
(g45
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp253
sg53
g29
(g31
S'\x08\xac\x1cZd;\x18@'
tRp254
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp255
sg57
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp256
sg59
g29
(g45
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp257
sg61
g29
(g31
S'\x08\xac\x1cZd;\x10@'
tRp258
sg63
VFMKRHT
p259
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp260
sg67
Vldynqj
p261
sg68
g29
(g31
S'\x04V\x0e-\xb2\x1d @'
tRp262
sg70
g174
stRp263
ag1
(g41
g42
(dp264
g44
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp265
sg47
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp266
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp267
sg51
g29
(g45
S'8\x00\x00\x00\x00\x00\x00\x00'
tRp268
sg53
g29
(g31
S'\x9a\x99\x99\x99\x99\x19\x10@'
tRp269
sg55
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp270
sg57
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp271
sg59
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp272
sg61
g29
(g31
S'\x9a\x99\x99\x99\x99\x19\x10@'
tRp273
sg63
VHTXMJR
p274
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp275
sg67
V 
sg68
g29
(g31
S'\x9a\x99\x99\x99\x99\x19\x18@'
tRp276
sg70
g71
stRp277
ag1
(g41
g42
(dp278
g44
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp279
sg47
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp280
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp281
sg51
g29
(g45
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp282
sg53
g29
(g31
S'5^\xbaI\x0c\x02\x10@'
tRp283
sg55
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp284
sg57
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp285
sg59
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp286
sg61
g29
(g31
S'5^\xbaI\x0c\x02\x10@'
tRp287
sg63
VYBDHMX
p288
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp289
sg67
V 
sg68
g29
(g31
S'6^\xbaI\x0c\x02\x18@'
tRp290
sg70
g71
stRp291
ag1
(g41
g42
(dp292
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp293
sg47
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp294
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp295
sg51
g29
(g45
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp296
sg53
g29
(g31
S'\xbbI\x0c\x02+\x07\x18@'
tRp297
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp298
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp299
sg59
g29
(g45
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp300
sg61
g29
(g31
S'\xbaI\x0c\x02+\x07\x10@'
tRp301
sg63
VQXTJMN
p302
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp303
sg67
Vbfylkh
p304
sg68
g29
(g31
S'\xdd$\x06\x81\x95\x03*@'
tRp305
sg70
g174
stRp306
ag1
(g41
g42
(dp307
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp308
sg47
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp309
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp310
sg51
g29
(g45
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp311
sg53
g29
(g31
S'\x92\xed|?5\xde\x1b@'
tRp312
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp313
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp314
sg59
g29
(g45
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp315
sg61
g29
(g31
S'\x91\xed|?5\xde\x13@'
tRp316
sg63
VFBMDTY
p317
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp318
sg67
Vjblrgh
p319
sg68
g29
(g31
S'\xc9v\xbe\x9f\x1a\xef+@'
tRp320
sg70
g158
stRp321
ag1
(g41
g42
(dp322
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp323
sg47
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp324
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp325
sg51
g29
(g45
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp326
sg53
g29
(g31
S'\xcd\xcc\xcc\xcc\xccL\x10@'
tRp327
sg55
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp328
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp329
sg59
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp330
sg61
g29
(g31
S'\xcd\xcc\xcc\xcc\xccL\x10@'
tRp331
sg63
VTDMLKB
p332
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp333
sg67
V 
sg68
g29
(g31
S'fffff&&@'
tRp334
sg70
g71
stRp335
ag1
(g41
g42
(dp336
g44
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp337
sg47
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp338
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp339
sg51
g29
(g45
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp340
sg53
g29
(g31
S'\xcd\xcc\xcc\xcc\xcc\xcc\x1a@'
tRp341
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp342
sg57
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp343
sg59
g29
(g45
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp344
sg61
g29
(g31
S'\xcd\xcc\xcc\xcc\xcc\xcc\x12@'
tRp345
sg63
VJMKRNX
p346
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp347
sg67
Vfbdgly
p348
sg68
g29
(g31
S'ffffff!@'
tRp349
sg70
g174
stRp350
ag1
(g41
g42
(dp351
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp352
sg47
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp353
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp354
sg51
g29
(g45
S')\t\x00\x00\x00\x00\x00\x00'
tRp355
sg53
g29
(g31
S'`\xe5\xd0"\xdb\xf9\x11@'
tRp356
sg55
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp357
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp358
sg59
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp359
sg61
g29
(g31
S'`\xe5\xd0"\xdb\xf9\x11@'
tRp360
sg63
VMDTQWF
p361
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp362
sg67
V 
sg68
g29
(g31
S'\xb1rh\x91\xed\xfc&@'
tRp363
sg70
g71
stRp364
ag1
(g41
g42
(dp365
g44
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp366
sg47
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp367
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp368
sg51
g29
(g45
S')\t\x00\x00\x00\x00\x00\x00'
tRp369
sg53
g29
(g31
S'\x04V\x0e-\xb2\x1d\x11@'
tRp370
sg55
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp371
sg57
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp372
sg59
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp373
sg61
g29
(g31
S'\x04V\x0e-\xb2\x1d\x11@'
tRp374
sg63
VKLFWTJ
p375
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp376
sg67
V 
sg68
g29
(g31
S'\x04V\x0e-\xb2\x1d\x19@'
tRp377
sg70
g71
stRp378
ag1
(g41
g42
(dp379
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp380
sg47
g29
(g45
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp381
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp382
sg51
g29
(g45
S')\t\x00\x00\x00\x00\x00\x00'
tRp383
sg53
g29
(g31
S'\xca\xa1E\xb6\xf3\xfd\x1a@'
tRp384
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp385
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp386
sg59
g29
(g45
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp387
sg61
g29
(g31
S'\xcb\xa1E\xb6\xf3\xfd\x12@'
tRp388
sg63
VWNLMBQ
p389
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp390
sg67
Vhtfnxj
p391
sg68
g29
(g31
S'\xe5\xd0"\xdb\xf9~+@'
tRp392
sg70
g158
stRp393
ag1
(g41
g42
(dp394
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp395
sg47
g29
(g45
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp396
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp397
sg51
g29
(g45
S')\t\x00\x00\x00\x00\x00\x00'
tRp398
sg53
g29
(g31
S'\x83\xc0\xca\xa1E6\x18@'
tRp399
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp400
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp401
sg59
g29
(g45
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp402
sg61
g29
(g31
S'\x83\xc0\xca\xa1E6\x10@'
tRp403
sg63
VRXHGFK
p404
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp405
sg67
Vjwtgnm
p406
sg68
g29
(g31
S'A`\xe5\xd0"\x1b*@'
tRp407
sg70
g158
stRp408
ag1
(g41
g42
(dp409
g44
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp410
sg47
g29
(g45
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp411
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp412
sg51
g29
(g45
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp413
sg53
g29
(g31
S'\x93\x18\x04V\x0e-\x19@'
tRp414
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp415
sg57
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp416
sg59
g29
(g45
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp417
sg61
g29
(g31
S'\x93\x18\x04V\x0e-\x11@'
tRp418
sg63
VGJLMXF
p419
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp420
sg67
Vxbykdn
p421
sg68
g29
(g31
S'J\x0c\x02+\x87\x96 @'
tRp422
sg70
g158
stRp423
ag1
(g41
g42
(dp424
g44
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp425
sg47
g29
(g45
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp426
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp427
sg51
g29
(g45
S'90\x00\x00\x00\x00\x00\x00'
tRp428
sg53
g29
(g31
S'\xa8\xc6K7\x89A\x18@'
tRp429
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp430
sg57
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp431
sg59
g29
(g45
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp432
sg61
g29
(g31
S'\xa8\xc6K7\x89A\x10@'
tRp433
sg63
VNHXYGK
p434
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp435
sg67
Vrldbwm
p436
sg68
g29
(g31
S'T\xe3\xa5\x9b\xc4  @'
tRp437
sg70
g174
stRp438
ag1
(g41
g42
(dp439
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp440
sg47
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp441
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp442
sg51
g29
(g45
S'90\x00\x00\x00\x00\x00\x00'
tRp443
sg53
g29
(g31
S'\x11X9\xb4\xc8v\x10@'
tRp444
sg55
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp445
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp446
sg59
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp447
sg61
g29
(g31
S'\x11X9\xb4\xc8v\x10@'
tRp448
sg63
VWNYDXF
p449
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp450
sg67
V 
sg68
g29
(g31
S'\x08\xac\x1cZd;&@'
tRp451
sg70
g71
stRp452
ag1
(g41
g42
(dp453
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp454
sg47
g29
(g45
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp455
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp456
sg51
g29
(g45
S'90\x00\x00\x00\x00\x00\x00'
tRp457
sg53
g29
(g31
S'\x18\x04V\x0e-2\x18@'
tRp458
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp459
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp460
sg59
g29
(g45
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp461
sg61
g29
(g31
S'\x18\x04V\x0e-2\x10@'
tRp462
sg63
VXGFBNY
p463
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp464
sg67
Vxdmrkw
p465
sg68
g29
(g31
S'\r\x02+\x87\x16\x19*@'
tRp466
sg70
g158
stRp467
ag1
(g41
g42
(dp468
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp469
sg47
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp470
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp471
sg51
g29
(g45
S'90\x00\x00\x00\x00\x00\x00'
tRp472
sg53
g29
(g31
S'\xf3\xfd\xd4x\xe9\xa6\x1d@'
tRp473
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp474
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp475
sg59
g29
(g45
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp476
sg61
g29
(g31
S'\xf3\xfd\xd4x\xe9\xa6\x15@'
tRp477
sg63
g302
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp478
sg67
Vbrfwhy
p479
sg68
g29
(g31
S'\xfa~j\xbct\xd3,@'
tRp480
sg70
g174
stRp481
ag1
(g41
g42
(dp482
g44
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp483
sg47
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp484
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp485
sg51
g29
(g45
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp486
sg53
g29
(g31
S'T\xe3\xa5\x9b\xc4 \x10@'
tRp487
sg55
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp488
sg57
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp489
sg59
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp490
sg61
g29
(g31
S'T\xe3\xa5\x9b\xc4 \x10@'
tRp491
sg63
VDWQGBL
p492
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp493
sg67
V 
sg68
g29
(g31
S'T\xe3\xa5\x9b\xc4 \x18@'
tRp494
sg70
g71
stRp495
ag1
(g41
g42
(dp496
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp497
sg47
g29
(g45
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp498
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp499
sg51
g29
(g45
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp500
sg53
g29
(g31
S'R\xb8\x1e\x85\xebQ\x18@'
tRp501
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp502
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp503
sg59
g29
(g45
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp504
sg61
g29
(g31
S'R\xb8\x1e\x85\xebQ\x10@'
tRp505
sg63
VWLQHYX
p506
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp507
sg67
Vljngtk
p508
sg68
g29
(g31
S')\\\x8f\xc2\xf5(*@'
tRp509
sg70
g158
stRp510
ag1
(g41
g42
(dp511
g44
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp512
sg47
g29
(g45
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp513
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp514
sg51
g29
(g45
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp515
sg53
g29
(g31
S'\x9a\x99\x99\x99\x99\x99\x1a@'
tRp516
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp517
sg57
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp518
sg59
g29
(g45
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp519
sg61
g29
(g31
S'\x9a\x99\x99\x99\x99\x99\x12@'
tRp520
sg63
VRDJKWY
p521
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp522
sg67
Vnbhlgr
p523
sg68
g29
(g31
S'\xcd\xcc\xcc\xcc\xccL!@'
tRp524
sg70
g158
stRp525
ag1
(g41
g42
(dp526
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp527
sg47
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp528
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp529
sg51
g29
(g45
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp530
sg53
g29
(g31
S'j\xbct\x93\x18\x04\x18@'
tRp531
sg55
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp532
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp533
sg59
g29
(g45
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp534
sg61
g29
(g31
S'j\xbct\x93\x18\x04\x10@'
tRp535
sg63
VDKWFTM
p536
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp537
sg67
Vrlxyjn
p538
sg68
g29
(g31
S'6^\xbaI\x0c\x02*@'
tRp539
sg70
g174
stRp540
ag1
(g41
g42
(dp541
g44
g29
(g45
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp542
sg47
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp543
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp544
sg51
g29
(g45
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp545
sg53
g29
(g31
S'\x83\xc0\xca\xa1E\xb6\x11@'
tRp546
sg55
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp547
sg57
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp548
sg59
g29
(g45
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp549
sg61
g29
(g31
S'\x83\xc0\xca\xa1E\xb6\x11@'
tRp550
sg63
VRBLJXK
p551
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp552
sg67
V 
sg68
g29
(g31
S'A`\xe5\xd0"\xdb&@'
tRp553
sg70
g71
stRp554
ag1
(g41
g42
(dp555
g44
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp556
sg47
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp557
sg49
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp558
sg51
g29
(g45
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp559
sg53
g29
(g31
S'\xb2\x9d\xef\xa7\xc6\xcb\x11@'
tRp560
sg55
g29
(g45
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp561
sg57
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp562
sg59
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp563
sg61
g29
(g31
S'\xb2\x9d\xef\xa7\xc6\xcb\x11@'
tRp564
sg63
VFQJTXR
p565
sg65
g29
(g45
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp566
sg67
V 
sg68
g29
(g31
S'\xb2\x9d\xef\xa7\xc6\xcb\x19@'
tRp567
sg70
g71
stRp568
asS'seed'
p569
NsS'thisIndex'
p570
g29
(g138
S'\x01\x00\x00\x00'
tRp571
sS'thisN'
p572
I1
sS'thisTrialN'
p573
I1
sS'nTotal'
p574
I30
sS'_warnUseOfNext'
p575
I01
sbasS'saveWideText'
p576
I01
sS'thisEntry'
p577
(dp578
g16
F1454510720.568413
ssS'version'
p579
S''
sS'_paramNamesSoFar'
p580
(lp581
g44
ag47
ag49
ag51
ag53
ag55
ag57
ag59
ag61
ag63
ag65
ag67
ag68
ag70
asS'entries'
p582
(lp583
(dp584
g23
I2003
sS'trials.thisIndex'
p585
I0
sg26
g11
sg27
I1
sS'trials.thisRepN'
p586
I0
sg28
g32
sS'trials.thisN'
p587
I-1
sg15
F1.1961009502410889
sS'trials.thisTrialN'
p588
I-1
sg24
g25
sg14
S'r'
sa(dp589
g23
I2003
sS'trials.thisIndex'
p590
I0
sg27
I1
sS'trials.thisRepN'
p591
I0
sg28
g32
sg16
F1454510704.1535759
sS'trials.thisN'
p592
I-1
sg26
g11
sS'trials.thisTrialN'
p593
I-1
sg24
g25
sa(dp594
g23
I2003
sg28
g32
sg59
g152
sg19
F1.1011290550231934
sg65
g155
sg70
g158
sg18
I1
sg27
I1
sg55
g150
sg16
F1454510709.1455431
sS'trials.thisN'
p595
I0
sg47
g146
sg51
g148
sg53
g149
sg57
g151
sg63
g154
sg24
g25
sg67
g156
sg44
g145
sS'trials.thisIndex'
p596
g29
(g138
S'\x00\x00\x00\x00'
tRp597
sg49
g147
sS'trials.thisRepN'
p598
I0
sg61
g153
sg26
g11
sS'trials.thisTrialN'
p599
I0
sg68
g157
sg17
g93
sa(dp600
g23
I2003
sg26
g11
sg47
g146
sg51
g148
sg53
g149
sg57
g151
sg63
g154
sg65
g155
sg24
g25
sg67
g156
sg70
g158
sg44
g145
sS'trials.thisIndex'
p601
g597
sg27
I1
sg49
g147
sS'trials.thisRepN'
p602
I0
sg55
g150
sg59
g152
sg28
g32
sS'trials.thisN'
p603
I0
sg61
g153
sS'trials.thisTrialN'
p604
I0
sg68
g157
sasS'loops'
p605
(lp606
g36
asS'savePickle'
p607
I00
sb.