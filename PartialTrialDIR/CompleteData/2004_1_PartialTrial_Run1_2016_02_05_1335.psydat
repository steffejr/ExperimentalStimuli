ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
S'/Users/jason/Dropbox/SteffenerColumbia/Scripts/ExperimentalStimuli/PartialTrialDIR/Scripts/PsychoPyTask/data/2004_1_PartialTrial_Run1_2016_02_05_1335'
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'PartialTrial'
p11
sS'dataNames'
p12
(lp13
S'ScannerTrigger.keys'
p14
aS'ScannerTrigger.rt'
p15
aS'TrialStartTime'
p16
aS'KeyboardResp.keys'
p17
aS'KeyboardResp.corr'
p18
aS'KeyboardResp.rt'
p19
asS'autoLog'
p20
I01
sS'extraInfo'
p21
(dp22
VParticipant ID
p23
I2004
sS'date'
p24
V2016_Feb_05_1335
p25
sS'expName'
p26
g11
sVVisit ID
p27
I1
sS'frameRate'
p28
cnumpy.core.multiarray
scalar
p29
(cnumpy
dtype
p30
(S'f8'
I0
I1
tRp31
(I3
S'<'
NNNI-1
I-1
I0
tbS'+\x93\xbb\x9aE\xd1M@'
tRp32
ssS'loopsUnfinished'
p33
(lp34
sS'saveWideText'
p35
I01
sS'thisEntry'
p36
(dp37
sS'version'
p38
S''
sS'_paramNamesSoFar'
p39
(lp40
S'RetDur'
p41
aS'BotBrack'
p42
aS'StimDur'
p43
aS'UpBrack'
p44
aS'ProbeDurITI'
p45
aS'ProbeDur'
p46
aS'ProbeStart'
p47
aS'TrialDur'
p48
aS'ITI'
p49
aS'StimSet'
p50
aS'RetStart'
p51
aS'ProbeLet'
p52
aS'TrialITIDur'
p53
aS'Correct'
p54
asS'entries'
p55
(lp56
(dp57
g23
I2004
sS'trials.thisIndex'
p58
I0
sg26
g11
sg27
I1
sS'trials.thisRepN'
p59
I0
sg28
g32
sS'trials.thisN'
p60
I-1
sg15
F7.7254149913787842
sS'trials.thisTrialN'
p61
I-1
sg24
g25
sg14
S'equal'
p62
sa(dp63
g23
I2004
sS'trials.thisIndex'
p64
I0
sg27
I1
sS'trials.thisRepN'
p65
I0
sg28
g32
sg16
F1454697330.424263
sS'trials.thisN'
p66
I-1
sg26
g11
sS'trials.thisTrialN'
p67
I-1
sg24
g25
sa(dp68
g23
I2004
sg26
g11
sg42
g29
(g30
(S'i8'
I0
I1
tRp69
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp70
sg44
g29
(g69
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp71
sg45
g29
(g31
S'\x7fj\xbct\x93\x18\x10@'
tRp72
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp73
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp74
sg50
VQGHFKR
p75
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp76
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp77
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp78
sS'trials.thisIndex'
p79
g29
(g30
(S'i4'
I0
I1
tRp80
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00'
tRp81
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp82
sS'trials.thisRepN'
p83
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp84
sg16
F1454697340.4194391
sg28
g32
sS'trials.thisN'
p85
I0
sg49
g29
(g31
S'\x7fj\xbct\x93\x18\x10@'
tRp86
sS'trials.thisTrialN'
p87
I0
sg53
g29
(g31
S'@5^\xbaI\x0c&@'
tRp88
sg17
Nsa(dp89
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp90
sg44
g29
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp91
sg45
g29
(g31
S'\x85\xebQ\xb8\x1e\x85\x10@'
tRp92
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp93
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp94
sg50
VXDJLTM
p95
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp96
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp97
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp98
sS'trials.thisIndex'
p99
g29
(g80
S'\x01\x00\x00\x00'
tRp100
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp101
sS'trials.thisRepN'
p102
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp103
sg16
F1454697351.44187
sg28
g32
sS'trials.thisN'
p104
I1
sg49
g29
(g31
S'\x85\xebQ\xb8\x1e\x85\x10@'
tRp105
sS'trials.thisTrialN'
p106
I1
sg53
g29
(g31
S'\xc3\xf5(\\\x8fB&@'
tRp107
sg17
Nsa(dp108
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp109
sg19
(lp110
F1.7348999977111816
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp111
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp112
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp113
sg16
F1454697362.563746
sS'trials.thisN'
p114
I2
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp115
sg44
g29
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp116
sg45
g29
(g31
S'\xda\xce\xf7S\xe3%\x19@'
tRp117
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp118
sg50
VXYNBRF
p119
sg24
g25
sg52
Vgkqdtj
p120
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp121
sS'trials.thisIndex'
p122
g29
(g80
S'\x02\x00\x00\x00'
tRp123
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp124
sS'trials.thisRepN'
p125
I0
sg49
g29
(g31
S'\xd9\xce\xf7S\xe3%\x11@'
tRp126
sg26
g11
sS'trials.thisTrialN'
p127
I2
sg53
g29
(g31
S'm\xe7\xfb\xa9\xf1\x92*@'
tRp128
sg17
(lp129
S'8'
asa(dp130
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp131
sg19
(lp132
F1.2512640953063965
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp133
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp134
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp135
sg16
F1454697375.8545091
sS'trials.thisN'
p136
I3
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp137
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp138
sg45
g29
(g31
S'\xbct\x93\x18\x04\xd6\x18@'
tRp139
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp140
sg50
VFKMTQG
p141
sg24
g25
sg52
Vyhdlwb
p142
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp143
sS'trials.thisIndex'
p144
g29
(g80
S'\x03\x00\x00\x00'
tRp145
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp146
sS'trials.thisRepN'
p147
I0
sg49
g29
(g31
S'\xbct\x93\x18\x04\xd6\x10@'
tRp148
sg26
g11
sS'trials.thisTrialN'
p149
I3
sg53
g29
(g31
S'_\xbaI\x0c\x02k*@'
tRp150
sg17
(lp151
S'8'
asa(dp152
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp153
sg19
(lp154
F0.83428001403808594
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp155
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp156
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp157
sg16
F1454697389.067631
sS'trials.thisN'
p158
I4
sg42
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp159
sg44
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp160
sg45
g29
(g31
S'-\xb2\x9d\xef\xa7F\x1a@'
tRp161
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp162
sg50
VTNJDWB
p163
sg24
g25
sg52
Vqxhyfl
p164
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp165
sS'trials.thisIndex'
p166
g29
(g80
S'\x04\x00\x00\x00'
tRp167
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp168
sS'trials.thisRepN'
p169
I0
sg49
g29
(g31
S'-\xb2\x9d\xef\xa7F\x12@'
tRp170
sg26
g11
sS'trials.thisTrialN'
p171
I4
sg53
g29
(g31
S'\x17\xd9\xce\xf7S#+@'
tRp172
sg17
(lp173
S'8'
asa(dp174
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp175
sg19
(lp176
F0.91793203353881836
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp177
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp178
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp179
sg16
F1454697402.6392469
sS'trials.thisN'
p180
I5
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp181
sg44
g29
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp182
sg45
g29
(g31
S'\xaeG\xe1z\x14\xae\x1a@'
tRp183
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp184
sg50
VLRHKMY
p185
sg24
g25
sg52
Vqgrnfw
p186
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp187
sS'trials.thisIndex'
p188
g29
(g80
S'\x05\x00\x00\x00'
tRp189
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp190
sS'trials.thisRepN'
p191
I0
sg49
g29
(g31
S'\xaeG\xe1z\x14\xae\x12@'
tRp192
sg26
g11
sS'trials.thisTrialN'
p193
I5
sg53
g29
(g31
S'\xd7\xa3p=\nW!@'
tRp194
sg17
(lp195
S'7'
asa(dp196
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp197
sg19
(lp198
F0.78423714637756348
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp199
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp200
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp201
sg16
F1454697411.309411
sS'trials.thisN'
p202
I6
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp203
sg44
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp204
sg45
g29
(g31
S'\xc3\xf5(\\\x8fB\x1a@'
tRp205
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp206
sg50
VWRBDHN
p207
sg24
g25
sg52
Vmyqxgl
p208
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp209
sS'trials.thisIndex'
p210
g29
(g80
S'\x06\x00\x00\x00'
tRp211
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp212
sS'trials.thisRepN'
p213
I0
sg49
g29
(g31
S'\xc3\xf5(\\\x8fB\x12@'
tRp214
sg26
g11
sS'trials.thisTrialN'
p215
I6
sg53
g29
(g31
S'\xe1z\x14\xaeG!+@'
tRp216
sg17
(lp217
S'8'
asa(dp218
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp219
sg19
(lp220
F1.066953182220459
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp221
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp222
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp223
sg16
F1454697424.8646569
sS'trials.thisN'
p224
I7
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp225
sg44
g29
(g69
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp226
sg45
g29
(g31
S'\xa6\x9b\xc4 \xb0r\x18@'
tRp227
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp228
sg50
VXLTFHQ
p229
sg24
g25
sg52
Vrgjdbh
p230
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp231
sS'trials.thisIndex'
p232
g29
(g80
S'\x07\x00\x00\x00'
tRp233
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp234
sS'trials.thisRepN'
p235
I0
sg49
g29
(g31
S'\xa6\x9b\xc4 \xb0r\x10@'
tRp236
sg26
g11
sS'trials.thisTrialN'
p237
I7
sg53
g29
(g31
S'\xd3Mb\x10X9*@'
tRp238
sg17
(lp239
S'7'
asa(dp240
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp241
sg19
(lp242
F0.6512150764465332
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp243
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp244
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp245
sg16
F1454697437.9699039
sS'trials.thisN'
p246
I8
sg42
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp247
sg44
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp248
sg45
g29
(g31
S'333333\x18@'
tRp249
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp250
sg50
VWBFJTY
p251
sg24
g25
sg52
Vrmhqyd
p252
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp253
sS'trials.thisIndex'
p254
g29
(g80
S'\x08\x00\x00\x00'
tRp255
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp256
sS'trials.thisRepN'
p257
I0
sg49
g29
(g31
S'333333\x10@'
tRp258
sg26
g11
sS'trials.thisTrialN'
p259
I8
sg53
g29
(g31
S'\x9a\x99\x99\x99\x99\x19*@'
tRp260
sg17
(lp261
S'7'
asa(dp262
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp263
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp264
sg45
g29
(g31
S'\xd1"\xdb\xf9~j\x10@'
tRp265
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp266
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp267
sg50
VJGMQFB
p268
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp269
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp270
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp271
sS'trials.thisIndex'
p272
g29
(g80
S'\t\x00\x00\x00'
tRp273
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp274
sS'trials.thisRepN'
p275
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp276
sg16
F1454697451.009932
sg28
g32
sS'trials.thisN'
p277
I9
sg49
g29
(g31
S'\xd1"\xdb\xf9~j\x10@'
tRp278
sS'trials.thisTrialN'
p279
I9
sg53
g29
(g31
S'\xd1"\xdb\xf9~j\x18@'
tRp280
sg17
Nsa(dp281
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp282
sg44
g29
(g69
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp283
sg45
g29
(g31
S'\x00\x00\x00\x00\x00\x80\x18@'
tRp284
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp285
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp286
sg50
VKTMWNL
p287
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp288
sg24
g25
sg52
Vdrbgfq
p289
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp290
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp291
sS'trials.thisIndex'
p292
g29
(g80
S'\n\x00\x00\x00'
tRp293
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp294
sS'trials.thisRepN'
p295
I0
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp296
sg16
F1454697457.1126981
sg28
g32
sS'trials.thisN'
p297
I10
sg49
g29
(g31
S'\x00\x00\x00\x00\x00\x80\x10@'
tRp298
sS'trials.thisTrialN'
p299
I10
sg53
g29
(g31
S'\x00\x00\x00\x00\x00@ @'
tRp300
sg17
Nsa(dp301
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp302
sg19
(lp303
F1.8011159896850586
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp304
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp305
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp306
sg16
F1454697465.2341549
sS'trials.thisN'
p307
I11
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp308
sg44
g29
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp309
sg45
g29
(g31
S'\x9a\x99\x99\x99\x99\x19\x18@'
tRp310
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp311
sg50
VKLQMGW
p312
sg24
g25
sg52
Vydjrtb
p313
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp314
sS'trials.thisIndex'
p315
g29
(g80
S'\x0b\x00\x00\x00'
tRp316
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp317
sS'trials.thisRepN'
p318
I0
sg49
g29
(g31
S'\x9a\x99\x99\x99\x99\x19\x10@'
tRp319
sg26
g11
sS'trials.thisTrialN'
p320
I11
sg53
g29
(g31
S'\xcd\xcc\xcc\xcc\xcc\x0c*@'
tRp321
sg17
(lp322
S'8'
asa(dp323
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp324
sg44
g29
(g69
S'"\x00\x00\x00\x00\x00\x00\x00'
tRp325
sg45
g29
(g31
S'\x9a\x99\x99\x99\x99\x99\x11@'
tRp326
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp327
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp328
sg50
VKMNFBQ
p329
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp330
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp331
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp332
sS'trials.thisIndex'
p333
g29
(g80
S'\x0c\x00\x00\x00'
tRp334
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp335
sS'trials.thisRepN'
p336
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp337
sg16
F1454697478.257911
sg28
g32
sS'trials.thisN'
p338
I12
sg49
g29
(g31
S'\x9a\x99\x99\x99\x99\x99\x11@'
tRp339
sS'trials.thisTrialN'
p340
I12
sg53
g29
(g31
S'\x9a\x99\x99\x99\x99\x99\x19@'
tRp341
sg17
Nsa(dp342
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp343
sg19
(lp344
F0.90120911598205566
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp345
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp346
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp347
sg16
F1454697484.6519721
sS'trials.thisN'
p348
I13
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp349
sg44
g29
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp350
sg45
g29
(g31
S'\xf3\xfd\xd4x\xe9&\x18@'
tRp351
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp352
sg50
VGJBMRN
p353
sg24
g25
sg52
Vhjxlqk
p354
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp355
sS'trials.thisIndex'
p356
g29
(g80
S'\r\x00\x00\x00'
tRp357
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp358
sS'trials.thisRepN'
p359
I0
sg49
g29
(g31
S'\xf4\xfd\xd4x\xe9&\x10@'
tRp360
sg26
g11
sS'trials.thisTrialN'
p361
I13
sg53
g29
(g31
S'\xfa~j\xbct\x13*@'
tRp362
sg17
(lp363
S'7'
asa(dp364
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp365
sg44
g29
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp366
sg45
g29
(g31
S'\x14\xaeG\xe1z\x14\x10@'
tRp367
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp368
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp369
sg50
VYRMBKD
p370
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp371
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp372
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp373
sS'trials.thisIndex'
p374
g29
(g80
S'\x0e\x00\x00\x00'
tRp375
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp376
sS'trials.thisRepN'
p377
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp378
sg16
F1454697497.69032
sg28
g32
sS'trials.thisN'
p379
I14
sg49
g29
(g31
S'\x14\xaeG\xe1z\x14\x10@'
tRp380
sS'trials.thisTrialN'
p381
I14
sg53
g29
(g31
S'\n\xd7\xa3p=\n&@'
tRp382
sg17
Nsa(dp383
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp384
sg19
(lp385
F1.2670879364013672
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp386
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp387
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp388
sg16
F1454697508.7108409
sS'trials.thisN'
p389
I15
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp390
sg44
g29
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp391
sg45
g29
(g31
S'@5^\xbaI\x8c\x1c@'
tRp392
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp393
sg50
VWHQBYD
p394
sg24
g25
sg52
Vgntfrx
p395
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp396
sS'trials.thisIndex'
p397
g29
(g80
S'\x0f\x00\x00\x00'
tRp398
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp399
sS'trials.thisRepN'
p400
I0
sg49
g29
(g31
S'@5^\xbaI\x8c\x14@'
tRp401
sg26
g11
sS'trials.thisTrialN'
p402
I15
sg53
g29
(g31
S'\xa0\x1a/\xdd$F"@'
tRp403
sg17
(lp404
S'8'
asa(dp405
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp406
sg19
(lp407
F0.86829090118408203
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp408
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp409
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp410
sg16
F1454697517.8475449
sS'trials.thisN'
p411
I16
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp412
sg44
g29
(g69
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp413
sg45
g29
(g31
S'\x11X9\xb4\xc8v\x18@'
tRp414
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp415
sg50
VXYDNTF
p416
sg24
g25
sg52
Vkgmjwn
p417
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp418
sS'trials.thisIndex'
p419
g29
(g80
S'\x10\x00\x00\x00'
tRp420
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp421
sS'trials.thisRepN'
p422
I0
sg49
g29
(g31
S'\x11X9\xb4\xc8v\x10@'
tRp423
sg26
g11
sS'trials.thisTrialN'
p424
I16
sg53
g29
(g31
S'\x08\xac\x1cZd;*@'
tRp425
sg17
(lp426
S'7'
asa(dp427
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp428
sg19
(lp429
F0.95078897476196289
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp430
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp431
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp432
sg16
F1454697530.969682
sS'trials.thisN'
p433
I17
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp434
sg44
g29
(g69
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp435
sg45
g29
(g31
S't\x93\x18\x04V\x8e\x1c@'
tRp436
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp437
sg50
VLMBRKW
p438
sg24
g25
sg52
Vfnxgtj
p439
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp440
sS'trials.thisIndex'
p441
g29
(g80
S'\x11\x00\x00\x00'
tRp442
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp443
sS'trials.thisRepN'
p444
I0
sg49
g29
(g31
S't\x93\x18\x04V\x8e\x14@'
tRp445
sg26
g11
sS'trials.thisTrialN'
p446
I17
sg53
g29
(g31
S'\xbbI\x0c\x02+G,@'
tRp447
sg17
(lp448
S'8'
asa(dp449
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp450
sg19
(lp451
F1.3509769439697266
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp452
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp453
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp454
sg16
F1454697545.1086431
sS'trials.thisN'
p455
I18
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp456
sg44
g29
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp457
sg45
g29
(g31
S'E\xb6\xf3\xfd\xd4x\x1a@'
tRp458
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp459
sg50
VMFXWDL
p460
sg24
g25
sg52
Vjhrbkd
p461
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp462
sS'trials.thisIndex'
p463
g29
(g80
S'\x12\x00\x00\x00'
tRp464
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp465
sS'trials.thisRepN'
p466
I0
sg49
g29
(g31
S'F\xb6\xf3\xfd\xd4x\x12@'
tRp467
sg26
g11
sS'trials.thisTrialN'
p468
I18
sg53
g29
(g31
S'#\xdb\xf9~j<+@'
tRp469
sg17
(lp470
S'7'
asa(dp471
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp472
sg19
(lp473
F1.3346450328826904
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp474
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp475
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp476
sg16
F1454697558.7157321
sS'trials.thisN'
p477
I19
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp478
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp479
sg45
g29
(g31
S'\x1b/\xdd$\x06\x01\x18@'
tRp480
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp481
sg50
VJRHKTN
p482
sg24
g25
sg52
Vmlyxbd
p483
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp484
sS'trials.thisIndex'
p485
g29
(g80
S'\x13\x00\x00\x00'
tRp486
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp487
sS'trials.thisRepN'
p488
I0
sg49
g29
(g31
S'\x1b/\xdd$\x06\x01\x10@'
tRp489
sg26
g11
sS'trials.thisTrialN'
p490
I19
sg53
g29
(g31
S'\x8d\x97n\x12\x83\x00*@'
tRp491
sg17
(lp492
S'8'
asa(dp493
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp494
sg19
(lp495
F1.0842838287353516
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp496
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp497
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp498
sg16
F1454697571.7061191
sS'trials.thisN'
p499
I20
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp500
sg44
g29
(g69
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp501
sg45
g29
(g31
S'\x00\x00\x00\x00\x00\x00\x18@'
tRp502
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp503
sg50
VGJDXLW
p504
sg24
g25
sg52
Vjqmrhf
p505
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp506
sS'trials.thisIndex'
p507
g29
(g80
S'\x14\x00\x00\x00'
tRp508
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp509
sS'trials.thisRepN'
p510
I0
sg49
g29
(g31
S'\x00\x00\x00\x00\x00\x00\x10@'
tRp511
sg26
g11
sS'trials.thisTrialN'
p512
I20
sg53
g29
(g31
S'\x00\x00\x00\x00\x00\x00 @'
tRp513
sg17
(lp514
S'7'
asa(dp515
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp516
sg19
(lp517
F0.86749815940856934
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp518
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp519
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp520
sg16
F1454697579.7100151
sS'trials.thisN'
p521
I21
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp522
sg44
g29
(g69
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp523
sg45
g29
(g31
S'{\x14\xaeG\xe1z\x18@'
tRp524
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp525
sg50
VXWMYTB
p526
sg24
g25
sg52
Vhdnmfk
p527
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp528
sS'trials.thisIndex'
p529
g29
(g80
S'\x15\x00\x00\x00'
tRp530
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp531
sS'trials.thisRepN'
p532
I0
sg49
g29
(g31
S'{\x14\xaeG\xe1z\x10@'
tRp533
sg26
g11
sS'trials.thisTrialN'
p534
I21
sg53
g29
(g31
S'=\n\xd7\xa3p=*@'
tRp535
sg17
(lp536
S'7'
asa(dp537
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp538
sg19
(lp539
F0.90109896659851074
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp540
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp541
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp542
sg16
F1454697592.824173
sS'trials.thisN'
p543
I22
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp544
sg44
g29
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp545
sg45
g29
(g31
S'_\xbaI\x0c\x02\xab\x19@'
tRp546
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp547
sg50
VJKFLDH
p548
sg24
g25
sg52
Vynqxrg
p549
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp550
sS'trials.thisIndex'
p551
g29
(g80
S'\x16\x00\x00\x00'
tRp552
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp553
sS'trials.thisRepN'
p554
I0
sg49
g29
(g31
S'^\xbaI\x0c\x02\xab\x11@'
tRp555
sg26
g11
sS'trials.thisTrialN'
p556
I22
sg53
g29
(g31
S'/\xdd$\x06\x81\xd5*@'
tRp557
sg17
(lp558
S'8'
asa(dp559
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp560
sg19
(lp561
F1.234281063079834
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp562
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp563
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp564
sg16
F1454697606.2459249
sS'trials.thisN'
p565
I23
sg42
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp566
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp567
sg45
g29
(g31
S'\x17\xd9\xce\xf7S\xe3\x1f@'
tRp568
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp569
sg50
VNHWFQR
p570
sg24
g25
sg52
Vxbktqj
p571
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp572
sS'trials.thisIndex'
p573
g29
(g80
S'\x17\x00\x00\x00'
tRp574
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp575
sS'trials.thisRepN'
p576
I0
sg49
g29
(g31
S'\x17\xd9\xce\xf7S\xe3\x17@'
tRp577
sg26
g11
sS'trials.thisTrialN'
p578
I23
sg53
g29
(g31
S'\x8cl\xe7\xfb\xa9\xf1#@'
tRp579
sg17
(lp580
S'7'
asa(dp581
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp582
sg44
g29
(g69
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp583
sg45
g29
(g31
S'\x7fj\xbct\x93\x18\x10@'
tRp584
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp585
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp586
sg50
VQWYKRB
p587
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp588
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp589
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp590
sS'trials.thisIndex'
p591
g29
(g80
S'\x18\x00\x00\x00'
tRp592
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp593
sS'trials.thisRepN'
p594
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp595
sg16
F1454697616.2161429
sg28
g32
sS'trials.thisN'
p596
I24
sg49
g29
(g31
S'\x7fj\xbct\x93\x18\x10@'
tRp597
sS'trials.thisTrialN'
p598
I24
sg53
g29
(g31
S'@5^\xbaI\x0c&@'
tRp599
sg17
Nsa(dp600
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp601
sg44
g29
(g69
S')\t\x00\x00\x00\x00\x00\x00'
tRp602
sg45
g29
(g31
S'5^\xbaI\x0c\x02\x10@'
tRp603
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp604
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp605
sg50
VHXTQMD
p606
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp607
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp608
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp609
sS'trials.thisIndex'
p610
g29
(g80
S'\x19\x00\x00\x00'
tRp611
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp612
sS'trials.thisRepN'
p613
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp614
sg16
F1454697627.2365849
sg28
g32
sS'trials.thisN'
p615
I25
sg49
g29
(g31
S'5^\xbaI\x0c\x02\x10@'
tRp616
sS'trials.thisTrialN'
p617
I25
sg53
g29
(g31
S'6^\xbaI\x0c\x02\x18@'
tRp618
sg17
Nsa(dp619
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp620
sg19
(lp621
F1.467972993850708
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp622
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp623
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp624
sg16
F1454697633.23911
sS'trials.thisN'
p625
I26
sg42
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp626
sg44
g29
(g69
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp627
sg45
g29
(g31
S'/\xdd$\x06\x81\x15\x18@'
tRp628
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp629
sg50
VGRKBTJ
p630
sg24
g25
sg52
Vnymxql
p631
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp632
sS'trials.thisIndex'
p633
g29
(g80
S'\x1a\x00\x00\x00'
tRp634
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp635
sS'trials.thisRepN'
p636
I0
sg49
g29
(g31
S'/\xdd$\x06\x81\x15\x10@'
tRp637
sg26
g11
sS'trials.thisTrialN'
p638
I26
sg53
g29
(g31
S'\x97n\x12\x83\xc0\n*@'
tRp639
sg17
(lp640
S'8'
asa(dp641
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp642
sg44
g29
(g69
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp643
sg45
g29
(g31
S'%\x06\x81\x95C\x8b\x11@'
tRp644
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp645
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp646
sg50
VXTRNKH
p647
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp648
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp649
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp650
sS'trials.thisIndex'
p651
g29
(g80
S'\x1b\x00\x00\x00'
tRp652
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp653
sS'trials.thisRepN'
p654
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp655
sg16
F1454697646.2618339
sg28
g32
sS'trials.thisN'
p656
I27
sg49
g29
(g31
S'%\x06\x81\x95C\x8b\x11@'
tRp657
sS'trials.thisTrialN'
p658
I27
sg53
g29
(g31
S'\x12\x83\xc0\xca\xa1\xc5&@'
tRp659
sg17
Nsa(dp660
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp661
sg44
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp662
sg45
g29
(g31
S'\xf4\xfd\xd4x\xe9&\x10@'
tRp663
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp664
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp665
sg50
VWLRJNG
p666
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp667
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp668
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp669
sS'trials.thisIndex'
p670
g29
(g80
S'\x1c\x00\x00\x00'
tRp671
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp672
sS'trials.thisRepN'
p673
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp674
sg16
F1454697657.6510589
sg28
g32
sS'trials.thisN'
p675
I28
sg49
g29
(g31
S'\xf4\xfd\xd4x\xe9&\x10@'
tRp676
sS'trials.thisTrialN'
p677
I28
sg53
g29
(g31
S'\xf3\xfd\xd4x\xe9&\x18@'
tRp678
sg17
Nsa(dp679
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp680
sg19
(lp681
F1.1676580905914307
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp682
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp683
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp684
sg16
F1454697663.687017
sS'trials.thisN'
p685
I29
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp686
sg44
g29
(g69
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp687
sg45
g29
(g31
S')\\\x8f\xc2\xf5\xa8\x19@'
tRp688
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp689
sg50
VXTNJWF
p690
sg24
g25
sg52
Vygbqdh
p691
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp692
sS'trials.thisIndex'
p693
g29
(g80
S'\x1d\x00\x00\x00'
tRp694
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp695
sS'trials.thisRepN'
p696
I0
sg49
g29
(g31
S')\\\x8f\xc2\xf5\xa8\x11@'
tRp697
sg26
g11
sS'trials.thisTrialN'
p698
I29
sg53
g29
(g31
S'\x14\xaeG\xe1z\xd4*@'
tRp699
sg17
(lp700
S'8'
asa(dp701
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp702
sg19
(lp703
F0.86756491661071777
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp704
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp705
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp706
sg16
F1454697677.093854
sS'trials.thisN'
p707
I30
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp708
sg44
g29
(g69
S'\x0c\x00\x00\x00\x00\x00\x00\x00'
tRp709
sg45
g29
(g31
S'O\x8d\x97n\x12\x83\x18@'
tRp710
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp711
sg50
VKXBLTD
p712
sg24
g25
sg52
Vmnygrf
p713
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp714
sS'trials.thisIndex'
p715
g29
(g80
S'\x1e\x00\x00\x00'
tRp716
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp717
sS'trials.thisRepN'
p718
I0
sg49
g29
(g31
S'P\x8d\x97n\x12\x83\x10@'
tRp719
sg26
g11
sS'trials.thisTrialN'
p720
I30
sg53
g29
(g31
S'\xa8\xc6K7\x89A*@'
tRp721
sg17
(lp722
S'8'
asa(dp723
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp724
sg44
g29
(g69
S'Y\x01\x00\x00\x00\x00\x00\x00'
tRp725
sg45
g29
(g31
S'\x8f\xc2\xf5(\\\x0f\x10@'
tRp726
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp727
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp728
sg50
VQRFJDH
p729
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp730
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp731
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp732
sS'trials.thisIndex'
p733
g29
(g80
S'\x1f\x00\x00\x00'
tRp734
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp735
sS'trials.thisRepN'
p736
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp737
sg16
F1454697690.2262721
sg28
g32
sS'trials.thisN'
p738
I31
sg49
g29
(g31
S'\x8f\xc2\xf5(\\\x0f\x10@'
tRp739
sS'trials.thisTrialN'
p740
I31
sg53
g29
(g31
S'H\xe1z\x14\xae\x07&@'
tRp741
sg17
Nsa(dp742
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp743
sg19
(lp744
F1.0344319343566895
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp745
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp746
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp747
sg16
F1454697701.24651
sS'trials.thisN'
p748
I32
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp749
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp750
sg45
g29
(g31
S'\x0e-\xb2\x9d\xef\xa7\x18@'
tRp751
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp752
sg50
VMXRTLF
p753
sg24
g25
sg52
Vbylqkd
p754
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp755
sS'trials.thisIndex'
p756
g29
(g80
S' \x00\x00\x00'
tRp757
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp758
sS'trials.thisRepN'
p759
I0
sg49
g29
(g31
S'\x0e-\xb2\x9d\xef\xa7\x10@'
tRp760
sg26
g11
sS'trials.thisTrialN'
p761
I32
sg53
g29
(g31
S'\x88\x16\xd9\xce\xf7S*@'
tRp762
sg17
(lp763
S'7'
asa(dp764
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp765
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp766
sg45
g29
(g31
S'\xc4 \xb0rh\x11\x12@'
tRp767
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp768
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp769
sg50
VFJKMBQ
p770
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp771
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp772
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp773
sS'trials.thisIndex'
p774
g29
(g80
S'!\x00\x00\x00'
tRp775
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp776
sS'trials.thisRepN'
p777
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp778
sg16
F1454697714.4020491
sg28
g32
sS'trials.thisN'
p779
I33
sg49
g29
(g31
S'\xc4 \xb0rh\x11\x12@'
tRp780
sS'trials.thisTrialN'
p781
I33
sg53
g29
(g31
S'\xc5 \xb0rh\x11\x1a@'
tRp782
sg17
Nsa(dp783
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp784
sg19
(lp785
F1.0674698352813721
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp786
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp787
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp788
sg16
F1454697720.9201739
sS'trials.thisN'
p789
I34
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp790
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp791
sg45
g29
(g31
S'\xb2\x9d\xef\xa7\xc6K\x18@'
tRp792
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp793
sg50
VYMQHXG
p794
sg24
g25
sg52
Vtwrkjy
p795
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp796
sS'trials.thisIndex'
p797
g29
(g80
S'"\x00\x00\x00'
tRp798
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp799
sS'trials.thisRepN'
p800
I0
sg49
g29
(g31
S'\xb2\x9d\xef\xa7\xc6K\x10@'
tRp801
sg26
g11
sS'trials.thisTrialN'
p802
I34
sg53
g29
(g31
S'\xda\xce\xf7S\xe3%*@'
tRp803
sg17
(lp804
S'8'
asa(dp805
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp806
sg19
(lp807
F1.0677618980407715
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp808
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp809
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp810
sg16
F1454697733.9919441
sS'trials.thisN'
p811
I35
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp812
sg44
g29
(g69
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp813
sg45
g29
(g31
S'\x85\xebQ\xb8\x1e\x05\x1d@'
tRp814
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp815
sg50
VJFRBMN
p816
sg24
g25
sg52
Vnhgxqt
p817
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp818
sS'trials.thisIndex'
p819
g29
(g80
S'#\x00\x00\x00'
tRp820
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp821
sS'trials.thisRepN'
p822
I0
sg49
g29
(g31
S'\x85\xebQ\xb8\x1e\x05\x15@'
tRp823
sg26
g11
sS'trials.thisTrialN'
p824
I35
sg53
g29
(g31
S'\xc3\xf5(\\\x8f\x82,@'
tRp825
sg17
(lp826
S'7'
asa(dp827
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp828
sg19
(lp829
F1.2516019344329834
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp830
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp831
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp832
sg16
F1454697748.2483799
sS'trials.thisN'
p833
I36
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp834
sg44
g29
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp835
sg45
g29
(g31
S'\xaa\xf1\xd2Mb\x10\x1a@'
tRp836
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp837
sg50
VGMBFLX
p838
sg24
g25
sg52
Vhqydrt
p839
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp840
sS'trials.thisIndex'
p841
g29
(g80
S'$\x00\x00\x00'
tRp842
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp843
sS'trials.thisRepN'
p844
I0
sg49
g29
(g31
S'\xaa\xf1\xd2Mb\x10\x12@'
tRp845
sg26
g11
sS'trials.thisTrialN'
p846
I36
sg53
g29
(g31
S'\xd4x\xe9&1\x08+@'
tRp847
sg17
(lp848
S'8'
asa(dp849
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp850
sg44
g29
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp851
sg45
g29
(g31
S'Nb\x10X94\x11@'
tRp852
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp853
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp854
sg50
VMGJHDF
p855
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp856
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp857
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp858
sS'trials.thisIndex'
p859
g29
(g80
S'%\x00\x00\x00'
tRp860
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp861
sS'trials.thisRepN'
p862
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp863
sg16
F1454697761.754976
sg28
g32
sS'trials.thisN'
p864
I37
sg49
g29
(g31
S'Nb\x10X94\x11@'
tRp865
sS'trials.thisTrialN'
p866
I37
sg53
g29
(g31
S'Nb\x10X94\x19@'
tRp867
sg17
Nsa(dp868
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp869
sg19
(lp870
F1.2846550941467285
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp871
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp872
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp873
sg16
F1454697768.0581329
sS'trials.thisN'
p874
I38
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp875
sg44
g29
(g69
S'\xc8\x01\x00\x00\x00\x00\x00\x00'
tRp876
sg45
g29
(g31
S'\x9a\x99\x99\x99\x99\x19\x18@'
tRp877
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp878
sg50
VWMJNLK
p879
sg24
g25
sg52
Vtdyxhb
p880
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp881
sS'trials.thisIndex'
p882
g29
(g80
S'&\x00\x00\x00'
tRp883
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp884
sS'trials.thisRepN'
p885
I0
sg49
g29
(g31
S'\x9a\x99\x99\x99\x99\x19\x10@'
tRp886
sg26
g11
sS'trials.thisTrialN'
p887
I38
sg53
g29
(g31
S'\xcd\xcc\xcc\xcc\xcc\x0c @'
tRp888
sg17
(lp889
S'8'
asa(dp890
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp891
sg19
(lp892
F1.2016768455505371
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp893
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp894
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp895
sg16
F1454697776.0791399
sS'trials.thisN'
p896
I39
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp897
sg44
g29
(g69
S'\xd2\x04\x00\x00\x00\x00\x00\x00'
tRp898
sg45
g29
(g31
S'sh\x91\xed|?\x19@'
tRp899
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp900
sg50
VQGMLKT
p901
sg24
g25
sg52
Vqhyndw
p902
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp903
sS'trials.thisIndex'
p904
g29
(g80
S"'\x00\x00\x00"
tRp905
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp906
sS'trials.thisRepN'
p907
I0
sg49
g29
(g31
S'sh\x91\xed|?\x11@'
tRp908
sg26
g11
sS'trials.thisTrialN'
p909
I39
sg53
g29
(g31
S':\xb4\xc8v\xbe\x9f*@'
tRp910
sg17
(lp911
S'7'
asa(dp912
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp913
sg19
(lp914
F0.86711478233337402
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp915
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp916
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp917
sg16
F1454697789.386379
sS'trials.thisN'
p918
I40
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp919
sg44
g29
(g69
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp920
sg45
g29
(g31
S'O\x8d\x97n\x12\x03\x18@'
tRp921
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp922
sg50
VNHQMRX
p923
sg24
g25
sg52
Vljhtbw
p924
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp925
sS'trials.thisIndex'
p926
g29
(g80
S'(\x00\x00\x00'
tRp927
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp928
sS'trials.thisRepN'
p929
I0
sg49
g29
(g31
S'P\x8d\x97n\x12\x03\x10@'
tRp930
sg26
g11
sS'trials.thisTrialN'
p931
I40
sg53
g29
(g31
S'\xa8\xc6K7\x89\x01*@'
tRp932
sg17
(lp933
S'7'
asa(dp934
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp935
sg19
(lp936
F1.1675479412078857
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp937
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp938
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp939
sg16
F1454697802.3837121
sS'trials.thisN'
p940
I41
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp941
sg44
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp942
sg45
g29
(g31
S'ffffff\x1a@'
tRp943
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp944
sg50
VNTKWBY
p945
sg24
g25
sg52
Vdxmrgw
p946
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp947
sS'trials.thisIndex'
p948
g29
(g80
S')\x00\x00\x00'
tRp949
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp950
sS'trials.thisRepN'
p951
I0
sg49
g29
(g31
S'ffffff\x12@'
tRp952
sg26
g11
sS'trials.thisTrialN'
p953
I41
sg53
g29
(g31
S'333333!@'
tRp954
sg17
(lp955
S'7'
asa(dp956
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp957
sg44
g29
(g69
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp958
sg45
g29
(g31
S"\x0e-\xb2\x9d\xef'\x10@"
tRp959
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp960
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp961
sg50
VYLTXNK
p962
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp963
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp964
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp965
sS'trials.thisIndex'
p966
g29
(g80
S'*\x00\x00\x00'
tRp967
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp968
sS'trials.thisRepN'
p969
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp970
sg16
F1454697810.9861979
sg28
g32
sS'trials.thisN'
p971
I42
sg49
g29
(g31
S"\x0e-\xb2\x9d\xef'\x10@"
tRp972
sS'trials.thisTrialN'
p973
I42
sg53
g29
(g31
S"\x0e-\xb2\x9d\xef'\x18@"
tRp974
sg17
Nsa(dp975
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp976
sg19
(lp977
F0.86765098571777344
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp978
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp979
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp980
sg16
F1454697817.021668
sS'trials.thisN'
p981
I43
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp982
sg44
g29
(g69
S'\xc8\x01\x00\x00\x00\x00\x00\x00'
tRp983
sg45
g29
(g31
S'J\x0c\x02+\x87\x96\x18@'
tRp984
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp985
sg50
g416
sg24
g25
sg52
Vbtmrgk
p986
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp987
sS'trials.thisIndex'
p988
g29
(g80
S'+\x00\x00\x00'
tRp989
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp990
sS'trials.thisRepN'
p991
I0
sg49
g29
(g31
S'J\x0c\x02+\x87\x96\x10@'
tRp992
sg26
g11
sS'trials.thisTrialN'
p993
I43
sg53
g29
(g31
S'%\x06\x81\x95CK*@'
tRp994
sg17
(lp995
S'7'
asa(dp996
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp997
sg19
(lp998
F0.78378701210021973
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp999
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1000
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1001
sg16
F1454697830.1600909
sS'trials.thisN'
p1002
I44
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1003
sg44
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1004
sg45
g29
(g31
S'\xfd\xd4x\xe9&\xb1\x18@'
tRp1005
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1006
sg50
VDHWBGK
p1007
sg24
g25
sg52
Vgrxjnq
p1008
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1009
sS'trials.thisIndex'
p1010
g29
(g80
S',\x00\x00\x00'
tRp1011
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1012
sS'trials.thisRepN'
p1013
I0
sg49
g29
(g31
S'\xfe\xd4x\xe9&\xb1\x10@'
tRp1014
sg26
g11
sS'trials.thisTrialN'
p1015
I44
sg53
g29
(g31
S'\x7fj\xbct\x93X*@'
tRp1016
sg17
(lp1017
S'7'
asa(dp1018
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1019
sg19
(lp1020
F0.96770095825195312
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1021
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1022
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1023
sg16
F1454697843.3324361
sS'trials.thisN'
p1024
I45
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1025
sg44
g29
(g69
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp1026
sg45
g29
(g31
S'\xfc\xa9\xf1\xd2Mb\x18@'
tRp1027
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1028
sg50
VBMLJWY
p1029
sg24
g25
sg52
Vktnxfh
p1030
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1031
sS'trials.thisIndex'
p1032
g29
(g80
S'-\x00\x00\x00'
tRp1033
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1034
sS'trials.thisRepN'
p1035
I0
sg49
g29
(g31
S'\xfc\xa9\xf1\xd2Mb\x10@'
tRp1036
sg26
g11
sS'trials.thisTrialN'
p1037
I45
sg53
g29
(g31
S'\xfe\xd4x\xe9&1 @'
tRp1038
sg17
(lp1039
S'8'
asa(dp1040
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1041
sg19
(lp1042
F1.3175170421600342
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1043
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1044
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1045
sg16
F1454697851.4189301
sS'trials.thisN'
p1046
I46
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1047
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1048
sg45
g29
(g31
S'\x03+\x87\x16\xd9\xce\x18@'
tRp1049
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1050
sg50
VKHGWLF
p1051
sg24
g25
sg52
Vdqyxtn
p1052
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1053
sS'trials.thisIndex'
p1054
g29
(g80
S'.\x00\x00\x00'
tRp1055
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1056
sS'trials.thisRepN'
p1057
I0
sg49
g29
(g31
S'\x02+\x87\x16\xd9\xce\x10@'
tRp1058
sg26
g11
sS'trials.thisTrialN'
p1059
I46
sg53
g29
(g31
S'\x81\x95C\x8blg @'
tRp1060
sg17
(lp1061
S'8'
asa(dp1062
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1063
sg19
(lp1064
F1.4180400371551514
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1065
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1066
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1067
sg16
F1454697859.6227
sS'trials.thisN'
p1068
I47
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1069
sg44
g29
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp1070
sg45
g29
(g31
S'\xc9v\xbe\x9f\x1a\xaf\x1e@'
tRp1071
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1072
sg50
VKYTQLJ
p1073
sg24
g25
sg52
Vqxgwrd
p1074
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1075
sS'trials.thisIndex'
p1076
g29
(g80
S'/\x00\x00\x00'
tRp1077
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1078
sS'trials.thisRepN'
p1079
I0
sg49
g29
(g31
S'\xc9v\xbe\x9f\x1a\xaf\x16@'
tRp1080
sg26
g11
sS'trials.thisTrialN'
p1081
I47
sg53
g29
(g31
S'd;\xdfO\x8dW-@'
tRp1082
sg17
(lp1083
S'7'
asa(dp1084
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1085
sg44
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1086
sg45
g29
(g31
S'\xa8\xc6K7\x89\xc1\x10@'
tRp1087
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1088
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1089
sg50
VXYLWHD
p1090
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1091
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1092
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1093
sS'trials.thisIndex'
p1094
g29
(g80
S'0\x00\x00\x00'
tRp1095
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1096
sS'trials.thisRepN'
p1097
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1098
sg16
F1454697874.2969029
sg28
g32
sS'trials.thisN'
p1099
I48
sg49
g29
(g31
S'\xa8\xc6K7\x89\xc1\x10@'
tRp1100
sS'trials.thisTrialN'
p1101
I48
sg53
g29
(g31
S'\xa8\xc6K7\x89\xc1\x18@'
tRp1102
sg17
Nsa(dp1103
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1104
sg44
g29
(g69
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp1105
sg45
g29
(g31
S'\xc1\xca\xa1E\xb6s\x11@'
tRp1106
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1107
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1108
sg50
VLNFKGJ
p1109
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1110
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1111
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1112
sS'trials.thisIndex'
p1113
g29
(g80
S'1\x00\x00\x00'
tRp1114
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1115
sS'trials.thisRepN'
p1116
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1117
sg16
F1454697880.483592
sg28
g32
sS'trials.thisN'
p1118
I49
sg49
g29
(g31
S'\xc1\xca\xa1E\xb6s\x11@'
tRp1119
sS'trials.thisTrialN'
p1120
I49
sg53
g29
(g31
S'`\xe5\xd0"\xdb\xb9&@'
tRp1121
sg17
Nsa(dp1122
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1123
sg19
(lp1124
F1.2924909591674805
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1125
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1126
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1127
sg16
F1454697891.8395469
sS'trials.thisN'
p1128
I50
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1129
sg44
g29
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1130
sg45
g29
(g31
S'i\x91\xed|?5\x18@'
tRp1131
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1132
sg50
VGYHWQK
p1133
sg24
g25
sg52
Vdjxnrf
p1134
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1135
sS'trials.thisIndex'
p1136
g29
(g80
S'2\x00\x00\x00'
tRp1137
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1138
sS'trials.thisRepN'
p1139
I0
sg49
g29
(g31
S'h\x91\xed|?5\x10@'
tRp1140
sg26
g11
sS'trials.thisTrialN'
p1141
I50
sg53
g29
(g31
S'\xb4\xc8v\xbe\x9f\x1a*@'
tRp1142
sg17
(lp1143
S'8'
asa(dp1144
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1145
sg19
(lp1146
F0.81771016120910645
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1147
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1148
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1149
sg16
F1454697904.887115
sS'trials.thisN'
p1150
I51
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1151
sg44
g29
(g69
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp1152
sg45
g29
(g31
S'\x96C\x8bl\xe7{\x18@'
tRp1153
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1154
sg50
VRYNLWB
p1155
sg24
g25
sg52
Vjmtghl
p1156
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1157
sS'trials.thisIndex'
p1158
g29
(g80
S'3\x00\x00\x00'
tRp1159
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1160
sS'trials.thisRepN'
p1161
I0
sg49
g29
(g31
S'\x96C\x8bl\xe7{\x10@'
tRp1162
sg26
g11
sS'trials.thisTrialN'
p1163
I51
sg53
g29
(g31
S'\xcb\xa1E\xb6\xf3= @'
tRp1164
sg17
(lp1165
S'7'
asa(dp1166
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1167
sg44
g29
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1168
sg45
g29
(g31
S'\xb6\xf3\xfd\xd4xi\x10@'
tRp1169
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1170
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1171
sg50
VTYBDRX
p1172
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1173
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1174
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1175
sS'trials.thisIndex'
p1176
g29
(g80
S'4\x00\x00\x00'
tRp1177
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1178
sS'trials.thisRepN'
p1179
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1180
sg16
F1454697913.0065069
sg28
g32
sS'trials.thisN'
p1181
I52
sg49
g29
(g31
S'\xb6\xf3\xfd\xd4xi\x10@'
tRp1182
sS'trials.thisTrialN'
p1183
I52
sg53
g29
(g31
S'\xb6\xf3\xfd\xd4xi\x18@'
tRp1184
sg17
Nsa(dp1185
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1186
sg44
g29
(g69
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp1187
sg45
g29
(g31
S'\xaeG\xe1z\x14.\x10@'
tRp1188
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1189
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1190
sg50
VXDYGRT
p1191
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1192
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1193
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1194
sS'trials.thisIndex'
p1195
g29
(g80
S'5\x00\x00\x00'
tRp1196
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1197
sS'trials.thisRepN'
p1198
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1199
sg16
F1454697919.1082399
sg28
g32
sS'trials.thisN'
p1200
I53
sg49
g29
(g31
S'\xaeG\xe1z\x14.\x10@'
tRp1201
sS'trials.thisTrialN'
p1202
I53
sg53
g29
(g31
S'\xaeG\xe1z\x14.\x18@'
tRp1203
sg17
Nsa(dp1204
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1205
sg44
g29
(g69
S'{\x00\x00\x00\x00\x00\x00\x00'
tRp1206
sg45
g29
(g31
S'\n\xd7\xa3p=\n\x10@'
tRp1207
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1208
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1209
sg50
VHYDTGR
p1210
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1211
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1212
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1213
sS'trials.thisIndex'
p1214
g29
(g80
S'6\x00\x00\x00'
tRp1215
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1216
sS'trials.thisRepN'
p1217
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1218
sg16
F1454697925.143898
sg28
g32
sS'trials.thisN'
p1219
I54
sg49
g29
(g31
S'\n\xd7\xa3p=\n\x10@'
tRp1220
sS'trials.thisTrialN'
p1221
I54
sg53
g29
(g31
S'\n\xd7\xa3p=\n\x18@'
tRp1222
sg17
Nsa(dp1223
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1224
sg19
(lp1225
F1.5174298286437988
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1226
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1227
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1228
sg16
F1454697931.1462071
sS'trials.thisN'
p1229
I55
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1230
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1231
sg45
g29
(g31
S'%\x06\x81\x95C\x0b\x18@'
tRp1232
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1233
sg50
VWNDHRY
p1234
sg24
g25
sg52
Vtxbkml
p1235
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1236
sS'trials.thisIndex'
p1237
g29
(g80
S'7\x00\x00\x00'
tRp1238
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1239
sS'trials.thisRepN'
p1240
I0
sg49
g29
(g31
S'%\x06\x81\x95C\x0b\x10@'
tRp1241
sg26
g11
sS'trials.thisTrialN'
p1242
I55
sg53
g29
(g31
S'\x12\x83\xc0\xca\xa1\x05*@'
tRp1243
sg17
(lp1244
S'8'
asa(dp1245
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1246
sg19
(lp1247
F0.90105199813842773
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1248
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1249
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1250
sg16
F1454697944.151154
sS'trials.thisN'
p1251
I56
sg42
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1252
sg44
g29
(g69
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp1253
sg45
g29
(g31
S'/\xdd$\x06\x81\x95\x18@'
tRp1254
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1255
sg50
VNJWFRG
p1256
sg24
g25
sg52
Vlkqmdj
p1257
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1258
sS'trials.thisIndex'
p1259
g29
(g80
S'8\x00\x00\x00'
tRp1260
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1261
sS'trials.thisRepN'
p1262
I0
sg49
g29
(g31
S'/\xdd$\x06\x81\x95\x10@'
tRp1263
sg26
g11
sS'trials.thisTrialN'
p1264
I56
sg53
g29
(g31
S'\x97n\x12\x83\xc0J*@'
tRp1265
sg17
(lp1266
S'7'
asa(dp1267
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1268
sg19
(lp1269
F1.1352880001068115
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1270
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1271
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1272
sg16
F1454697957.290935
sS'trials.thisN'
p1273
I57
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1274
sg44
g29
(g69
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp1275
sg45
g29
(g31
S'=\n\xd7\xa3p\xbd\x18@'
tRp1276
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1277
sg50
VBTXWRQ
p1278
sg24
g25
sg52
Vmykndj
p1279
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1280
sS'trials.thisIndex'
p1281
g29
(g80
S'9\x00\x00\x00'
tRp1282
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1283
sS'trials.thisRepN'
p1284
I0
sg49
g29
(g31
S'=\n\xd7\xa3p\xbd\x10@'
tRp1285
sg26
g11
sS'trials.thisTrialN'
p1286
I57
sg53
g29
(g31
S'\x1f\x85\xebQ\xb8^*@'
tRp1287
sg17
(lp1288
S'8'
asa(dp1289
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1290
sg44
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1291
sg45
g29
(g31
S'\xaeG\xe1z\x14.\x10@'
tRp1292
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1293
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1294
sg50
VMYXJNT
p1295
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1296
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1297
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1298
sS'trials.thisIndex'
p1299
g29
(g80
S':\x00\x00\x00'
tRp1300
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1301
sS'trials.thisRepN'
p1302
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1303
sg16
F1454697970.480551
sg28
g32
sS'trials.thisN'
p1304
I58
sg49
g29
(g31
S'\xaeG\xe1z\x14.\x10@'
tRp1305
sS'trials.thisTrialN'
p1306
I58
sg53
g29
(g31
S'\xd7\xa3p=\n\x17&@'
tRp1307
sg17
Nsa(dp1308
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1309
sg44
g29
(g69
S'\x80\r\x00\x00\x00\x00\x00\x00'
tRp1310
sg45
g29
(g31
S'y\xe9&1\x08,\x10@'
tRp1311
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1312
sg48
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1313
sg50
VHBYLMQ
p1314
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1315
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1316
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1317
sS'trials.thisIndex'
p1318
g29
(g80
S';\x00\x00\x00'
tRp1319
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1320
sS'trials.thisRepN'
p1321
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1322
sg16
F1454697981.519352
sg28
g32
sS'trials.thisN'
p1323
I59
sg49
g29
(g31
S'y\xe9&1\x08,\x10@'
tRp1324
sS'trials.thisTrialN'
p1325
I59
sg53
g29
(g31
S'x\xe9&1\x08,\x18@'
tRp1326
sg17
Nsa(dp1327
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1328
sg19
(lp1329
F1.3177199363708496
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1330
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1331
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1332
sg16
F1454697987.5556951
sS'trials.thisN'
p1333
I60
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1334
sg44
g29
(g69
S'90\x00\x00\x00\x00\x00\x00'
tRp1335
sg45
g29
(g31
S'i\x91\xed|?\xb5\x19@'
tRp1336
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1337
sg50
VGLMNYH
p1338
sg24
g25
sg52
Vknqwxb
p1339
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1340
sS'trials.thisIndex'
p1341
g29
(g80
S'<\x00\x00\x00'
tRp1342
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1343
sS'trials.thisRepN'
p1344
I0
sg49
g29
(g31
S'h\x91\xed|?\xb5\x11@'
tRp1345
sg26
g11
sS'trials.thisTrialN'
p1346
I60
sg53
g29
(g31
S'\xb4\xc8v\xbe\x9f\xda @'
tRp1347
sg17
(lp1348
S'7'
asa(dp1349
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1350
sg19
(lp1351
F1.0096759796142578
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1352
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1353
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1354
sg16
F1454697995.977093
sS'trials.thisN'
p1355
I61
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1356
sg44
g29
(g69
S'\xea\x00\x00\x00\x00\x00\x00\x00'
tRp1357
sg45
g29
(g31
S'\xe9&1\x08\xac\x1c\x19@'
tRp1358
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1359
sg50
VWHXFRB
p1360
sg24
g25
sg52
Vjdglqm
p1361
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1362
sS'trials.thisIndex'
p1363
g29
(g80
S'=\x00\x00\x00'
tRp1364
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1365
sS'trials.thisRepN'
p1366
I0
sg49
g29
(g31
S'\xea&1\x08\xac\x1c\x11@'
tRp1367
sg26
g11
sS'trials.thisTrialN'
p1368
I61
sg53
g29
(g31
S't\x93\x18\x04V\x8e*@'
tRp1369
sg17
(lp1370
S'8'
asa(dp1371
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1372
sg19
(lp1373
F0.85100483894348145
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1374
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1375
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1376
sg16
F1454698009.257772
sS'trials.thisN'
p1377
I62
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1378
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1379
sg45
g29
(g31
S'6^\xbaI\x0c\x02\x18@'
tRp1380
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1381
sg50
VJRWBTF
p1382
sg24
g25
sg52
Vlgbnqh
p1383
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1384
sS'trials.thisIndex'
p1385
g29
(g80
S'>\x00\x00\x00'
tRp1386
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1387
sS'trials.thisRepN'
p1388
I0
sg49
g29
(g31
S'5^\xbaI\x0c\x02\x10@'
tRp1389
sg26
g11
sS'trials.thisTrialN'
p1390
I62
sg53
g29
(g31
S'\x1b/\xdd$\x06\x01*@'
tRp1391
sg17
(lp1392
S'7'
asa(dp1393
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1394
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1395
sg45
g29
(g31
S'\xf8S\xe3\xa5\x9bD\x10@'
tRp1396
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1397
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1398
sg50
VBDLTMY
p1399
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1400
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1401
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1402
sS'trials.thisIndex'
p1403
g29
(g80
S'?\x00\x00\x00'
tRp1404
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1405
sS'trials.thisRepN'
p1406
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1407
sg16
F1454698022.262207
sg28
g32
sS'trials.thisN'
p1408
I63
sg49
g29
(g31
S'\xf8S\xe3\xa5\x9bD\x10@'
tRp1409
sS'trials.thisTrialN'
p1410
I63
sg53
g29
(g31
S'\xfc\xa9\xf1\xd2M"&@'
tRp1411
sg17
Nsa(dp1412
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1413
sg19
(lp1414
F0.85132384300231934
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1415
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1416
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1417
sg16
F1454698033.332778
sS'trials.thisN'
p1418
I64
sg42
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1419
sg44
g29
(g69
S'-\x00\x00\x00\x00\x00\x00\x00'
tRp1420
sg45
g29
(g31
S'\xe5\xd0"\xdb\xf9~\x19@'
tRp1421
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1422
sg50
VQMGDKH
p1423
sg24
g25
sg52
Vtlxrjy
p1424
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1425
sS'trials.thisIndex'
p1426
g29
(g80
S'@\x00\x00\x00'
tRp1427
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1428
sS'trials.thisRepN'
p1429
I0
sg49
g29
(g31
S'\xe5\xd0"\xdb\xf9~\x11@'
tRp1430
sg26
g11
sS'trials.thisTrialN'
p1431
I64
sg53
g29
(g31
S'sh\x91\xed|\xbf*@'
tRp1432
sg17
(lp1433
S'8'
asa(dp1434
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1435
sg19
(lp1436
F0.80142688751220703
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1437
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1438
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1439
sg16
F1454698046.7054119
sS'trials.thisN'
p1440
I65
sg42
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1441
sg44
g29
(g69
S'\xa0[\x00\x00\x00\x00\x00\x00'
tRp1442
sg45
g29
(g31
S'\x1f\x85\xebQ\xb8\x9e\x18@'
tRp1443
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1444
sg50
VYWDLHX
p1445
sg24
g25
sg52
Vtlfbjr
p1446
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1447
sS'trials.thisIndex'
p1448
g29
(g80
S'A\x00\x00\x00'
tRp1449
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1450
sS'trials.thisRepN'
p1451
I0
sg49
g29
(g31
S'\x1f\x85\xebQ\xb8\x9e\x10@'
tRp1452
sg26
g11
sS'trials.thisTrialN'
p1453
I65
sg53
g29
(g31
S'\x8f\xc2\xf5(\\O*@'
tRp1454
sg17
(lp1455
S'7'
asa(dp1456
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1457
sg44
g29
(g69
S'\x17\x00\x00\x00\x00\x00\x00\x00'
tRp1458
sg45
g29
(g31
S'\x83\xc0\xca\xa1E6\x10@'
tRp1459
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1460
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1461
sg50
VHGFJRD
p1462
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1463
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1464
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1465
sS'trials.thisIndex'
p1466
g29
(g80
S'B\x00\x00\x00'
tRp1467
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1468
sS'trials.thisRepN'
p1469
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1470
sg16
F1454698059.8604641
sg28
g32
sS'trials.thisN'
p1471
I66
sg49
g29
(g31
S'\x83\xc0\xca\xa1E6\x10@'
tRp1472
sS'trials.thisTrialN'
p1473
I66
sg53
g29
(g31
S'A`\xe5\xd0"\x1b&@'
tRp1474
sg17
Nsa(dp1475
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1476
sg19
(lp1477
F0.81786680221557617
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1478
sg54
g29
(g69
S'\x06\x00\x00\x00\x00\x00\x00\x00'
tRp1479
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1480
sg16
F1454698070.9160299
sS'trials.thisN'
p1481
I67
sg42
g29
(g69
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp1482
sg44
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1483
sg45
g29
(g31
S'\xb8\x1e\x85\xebQ8\x18@'
tRp1484
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1485
sg50
VTNJHXF
p1486
sg24
g25
sg52
Vxgqrdk
p1487
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1488
sS'trials.thisIndex'
p1489
g29
(g80
S'C\x00\x00\x00'
tRp1490
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1491
sS'trials.thisRepN'
p1492
I0
sg49
g29
(g31
S'\xb8\x1e\x85\xebQ8\x10@'
tRp1493
sg26
g11
sS'trials.thisTrialN'
p1494
I67
sg53
g29
(g31
S'\\\x8f\xc2\xf5(\x1c*@'
tRp1495
sg17
(lp1496
S'7'
asa(dp1497
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1498
sg44
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1499
sg45
g29
(g31
S'\x04V\x0e-\xb2\x1d\x11@'
tRp1500
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1501
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1502
sg50
VQWNGHM
p1503
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1504
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1505
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1506
sS'trials.thisIndex'
p1507
g29
(g80
S'D\x00\x00\x00'
tRp1508
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1509
sS'trials.thisRepN'
p1510
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1511
sg16
F1454698083.973099
sg28
g32
sS'trials.thisN'
p1512
I68
sg49
g29
(g31
S'\x04V\x0e-\xb2\x1d\x11@'
tRp1513
sS'trials.thisTrialN'
p1514
I68
sg53
g29
(g31
S'\x03+\x87\x16\xd9\x8e&@'
tRp1515
sg17
Nsa(dp1516
g23
I2004
sg26
g11
sg42
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1517
sg44
g29
(g69
S'@\xe2\x01\x00\x00\x00\x00\x00'
tRp1518
sg45
g29
(g31
S'R\xb8\x1e\x85\xeb\xd1\x11@'
tRp1519
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1520
sg48
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1521
sg50
VXLNJFR
p1522
sg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1523
sg24
g25
sg52
V 
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1524
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1525
sS'trials.thisIndex'
p1526
g29
(g80
S'E\x00\x00\x00'
tRp1527
sg18
I0
sg27
I1
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1528
sS'trials.thisRepN'
p1529
I0
sg46
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1530
sg16
F1454698095.24542
sg28
g32
sS'trials.thisN'
p1531
I69
sg49
g29
(g31
S'R\xb8\x1e\x85\xeb\xd1\x11@'
tRp1532
sS'trials.thisTrialN'
p1533
I69
sg53
g29
(g31
S')\\\x8f\xc2\xf5\xe8&@'
tRp1534
sg17
Nsa(dp1535
g23
I2004
sg28
g32
sg48
g29
(g69
S'\t\x00\x00\x00\x00\x00\x00\x00'
tRp1536
sg19
(lp1537
F0.83460783958435059
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1538
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1539
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1540
sg16
F1454698106.6925671
sS'trials.thisN'
p1541
I70
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1542
sg44
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1543
sg45
g29
(g31
S'i\x91\xed|?5\x18@'
tRp1544
sg47
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1545
sg50
VDYKFTL
p1546
sg24
g25
sg52
Vnhqjmr
p1547
sg41
g29
(g69
S'\x05\x00\x00\x00\x00\x00\x00\x00'
tRp1548
sS'trials.thisIndex'
p1549
g29
(g80
S'F\x00\x00\x00'
tRp1550
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1551
sS'trials.thisRepN'
p1552
I0
sg49
g29
(g31
S'h\x91\xed|?5\x10@'
tRp1553
sg26
g11
sS'trials.thisTrialN'
p1554
I70
sg53
g29
(g31
S'\xb4\xc8v\xbe\x9f\x1a*@'
tRp1555
sg17
(lp1556
S'8'
asa(dp1557
g23
I2004
sg28
g32
sg48
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1558
sg19
(lp1559
F0.9515380859375
asg51
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1560
sg54
g29
(g69
S'\x07\x00\x00\x00\x00\x00\x00\x00'
tRp1561
sg18
I0
sg27
I1
sg46
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1562
sg16
F1454698119.747282
sS'trials.thisN'
p1563
I71
sg42
g29
(g69
S'\x03\x00\x00\x00\x00\x00\x00\x00'
tRp1564
sg44
g29
(g69
S'\x04\x00\x00\x00\x00\x00\x00\x00'
tRp1565
sg45
g29
(g31
S'\\\x8f\xc2\xf5(\xdc\x19@'
tRp1566
sg47
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1567
sg50
VBYFQKT
p1568
sg24
g25
sg52
Vhrxljn
p1569
sg41
g29
(g69
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp1570
sS'trials.thisIndex'
p1571
g29
(g80
S'G\x00\x00\x00'
tRp1572
sg43
g29
(g69
S'\x02\x00\x00\x00\x00\x00\x00\x00'
tRp1573
sS'trials.thisRepN'
p1574
I0
sg49
g29
(g31
S'\\\x8f\xc2\xf5(\xdc\x11@'
tRp1575
sg26
g11
sS'trials.thisTrialN'
p1576
I71
sg53
g29
(g31
S'\xaeG\xe1z\x14\xee @'
tRp1577
sg17
(lp1578
S'8'
asa(dp1579
g23
I2004
sg26
g11
sg27
I1
sg24
g25
sg28
g32
sg16
F1454698128.216753
sa(dp1580
g23
I2004
sg26
g11
sg27
I1
sg24
g25
sg28
g32
sg16
F1454698138.2195151
sa(dp1581
g23
I2004
sg26
g11
sg27
I1
sg24
g25
sg28
g32
sg16
F1454698138.2195821
sasS'loops'
p1582
(lp1583
g1
(cpsychopy.data
TrialHandler
p1584
g3
NtRp1585
(dp1586
S'origin'
p1587
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.81.01), Thu 24 Sep 2015 11:35:23 AM EDT\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a# from psychopy.hardware.emulator import launchScan\u000aimport time\u000aimport sys\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000aglobal expName\u000aglobal AllowedInputKeys\u000aAllowedInputKeys = ['1', '2','3','4','5','6','7','8','9','down','right']\u000aglobal FullScreenFlag \u000a\u000aFullScreenFlag = True\u000aScreenToUse = 'MacBookPro'\u000aexpName='PartialTrial'\u000a\u000adef TestSomething(subid=9999,visitid=0001):\u000a    expInfo = {u'Visit ID': u'9999', u'Participant ID': u'1'}\u000a    print 'subid is %s'%(subid)\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a    else:\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a    return expInfo\u000a\u000adef PartialTrial(INPUTFILE,filename,subid=9999,visitid=9999):\u000a    #INPUTFILE = 'Optimized60trialsLoads12467_1.xlsx'\u000a    # INPUTFILE = 'TrialListLoads123466_6Repeats_121415_2.csv'\u000a    # INPUTFILE = 'TwoTrials.xlsx'\u000a    IntroTime = 10\u000a    End = 10 # This should be set so that it is at least ten seconds and so the experiment \u000a    # total duration is a multiple of two seconds.\u000a\u000a    MaxLetters = 6\u000a    if MaxLetters == 6:\u000a        SETwrapWidth = 1.5 # The wrap width of text needs to be adjusted based on how manty letters there are\u000a        SETletCycle = 13 # # Spaces are added between letters and this controls the loop which does it\u000a    elif MaxLetters == 7:\u000a        SETwrapWidth = 1.7\u000a        SETletCycle = 15\u000a    expInfo = {u'Visit ID': u'001', u'Participant ID': u''}\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a        if dlg.OK == False: win.close()  # user pressed cancel\u000a    else:\u000a        print "Subid entered is: %s"%(subid)\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a        \u000a    # Store info about the experiment session\u000a\u000a    \u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    # filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=True,\u000a        dataFileName=filename)\u000a    #save a log file for detail verbose info\u000a    logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[1366, 768], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor = ScreenToUse, color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'norm')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial"\u000a    trialClock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    \u000a    # THE AIM IS TO \u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=SETwrapWidth, ## Changed from 1.5 because of 7 letters\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=SETwrapWidth,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=SETwrapWidth,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    WaitForScanner = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Waiting for Scanner, press r to advance',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(INPUTFILE),\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a\u000a\u000a    # PRESENT THE SCREEN TO WAIT FOR THE MRI TRIGGER\u000a    #vol = launchScan(win, MR_settings,  mode='Scan')\u000a\u000a    # ########################################################\u000a    # There should be WAITING FOR SCANNER trial here\u000a    # The test2 routine has these parts in it\u000a    #------Prepare to start Routine "ScanWait"-------\u000a    t = 0\u000a    ScanWaitClock = core.Clock()\u000a    ScanWaitClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    ScannerTrigger = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    ScannerTrigger.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    ScanWaitComponents = []\u000a    ScanWaitComponents.append(WaitForScanner)\u000a    ScanWaitComponents.append(ScannerTrigger)\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "ScanWait"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = ScanWaitClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_4* updates\u000a        if t >= 0.0 and WaitForScanner.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            WaitForScanner.tStart = t  # underestimates by a little under one frame\u000a            WaitForScanner.frameNStart = frameN  # exact frame index\u000a            WaitForScanner.setAutoDraw(True)\u000a        \u000a        # *key_resp_3* updates\u000a        if t >= 0.0 and ScannerTrigger.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ScannerTrigger.tStart = t  # underestimates by a little under one frame\u000a            ScannerTrigger.frameNStart = frameN  # exact frame index\u000a            ScannerTrigger.status = STARTED\u000a            # keyboard checking is just starting\u000a            ScannerTrigger.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if ScannerTrigger.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['r','equal'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                ScannerTrigger.keys = theseKeys[-1]  # just the last key pressed\u000a                ScannerTrigger.rt = ScannerTrigger.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ScanWaitComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            \u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "ScanWait"-------\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if ScannerTrigger.keys in ['', [], None]:  # No response was made\u000a       ScannerTrigger.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('ScannerTrigger.keys',ScannerTrigger.keys)\u000a    if ScannerTrigger.keys != None:  # we had a response\u000a        thisExp.addData('ScannerTrigger.rt', ScannerTrigger.rt)\u000a    thisExp.nextEntry()\u000a    # ########################################################\u000a\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a\u000a    # Write out when the experiment begins\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    #------Prepare to start Routine "intro"-------\u000a    t = 0\u000a    introClock = core.Clock()\u000a    introClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(IntroTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    introComponents = []\u000a    introComponents.append(RestCrossHair)\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "intro"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = introClock.getTime()\u000a        \u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_3* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (0.0 + (IntroTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in introComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "intro"-------\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    # ########################################################\u000a\u000a    for thisTrial in trials:\u000a        # Write to the file the time this trial starts\u000a        trials.addData('TrialStartTime',time.time())\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        # ENCODING SET\u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempStimSet = StimSet\u000a        # Letters for space - letter - space - letter ... - space\u000a        StimSet=' '\u000a        for i in tempStimSet:\u000a            StimSet=StimSet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        UpBrackText = ''\u000a        if UpBrack > 0:\u000a            BracketList = list(str(UpBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,SETletCycle,1):   ## Changed from 13 when using 7 letters\u000a                UpBrackText = UpBrackText+' '\u000a            s = list(UpBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            UpBrackText = ''.join(s)\u000a        \u000a        # PROBE \u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempProbeLet = ProbeLet\u000a        # Letters for space - letter - space - letter ... - space\u000a        ProbeLet=' '\u000a        for i in tempProbeLet:\u000a            ProbeLet = ProbeLet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        BotBrackText = ''\u000a        if BotBrack > 0:\u000a            BracketList = list(str(BotBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,SETletCycle,1):   ## Changed from 13 when using 7 letters\u000a                BotBrackText = BotBrackText+' '\u000a            s = list(BotBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            BotBrackText = ''.join(s)\u000a            \u000a        # update component parameters for each repeat\u000a        UpperText.setText(StimSet)\u000a        UpperBrackets.setText(UpBrackText)\u000a        LowerText.setText(ProbeLet)\u000a        LowerBrackets.setText(BotBrackText)\u000a        \u000a        KeyboardResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        KeyboardResp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(TopUpperLine)\u000a        trialComponents.append(UpperText)\u000a        trialComponents.append(UpperBrackets)\u000a        trialComponents.append(BotUpperLine)\u000a        trialComponents.append(TopLowerLine)\u000a        trialComponents.append(LowerText)\u000a        trialComponents.append(LowerBrackets)\u000a        trialComponents.append(BotLowerLine)\u000a        trialComponents.append(TrialCrossHair)\u000a        trialComponents.append(RestCrossHair)\u000a        trialComponents.append(KeyboardResp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            \u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *TopUpperLine* updates\u000a            if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine.frameNStart = frameN  # exact frame index\u000a                TopUpperLine.setAutoDraw(True)\u000a            elif TopUpperLine.status == STARTED and t >= (0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine.setAutoDraw(False)\u000a            \u000a            # *UpperText* updates\u000a            if t >= 0 and UpperText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText.tStart = t  # underestimates by a little under one frame\u000a                UpperText.frameNStart = frameN  # exact frame index\u000a                UpperText.setAutoDraw(True)\u000a            elif UpperText.status == STARTED and t >= (0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets* updates\u000a            if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets.frameNStart = frameN  # exact frame index\u000a                UpperBrackets.setAutoDraw(True)\u000a            elif UpperBrackets.status == STARTED and t >= (0.0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine* updates\u000a            if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine.frameNStart = frameN  # exact frame index\u000a                BotUpperLine.setAutoDraw(True)\u000a            elif BotUpperLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine* updates\u000a            if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine.frameNStart = frameN  # exact frame index\u000a                TopLowerLine.setAutoDraw(True)\u000a            elif TopLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine.setAutoDraw(False)\u000a            \u000a            # *LowerText* updates\u000a            if t >= ProbeStart and LowerText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText.tStart = t  # underestimates by a little under one frame\u000a                LowerText.frameNStart = frameN  # exact frame index\u000a                LowerText.setAutoDraw(True)\u000a            elif LowerText.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets* updates\u000a            if t >= ProbeStart and LowerBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets.frameNStart = frameN  # exact frame index\u000a                LowerBrackets.setAutoDraw(True)\u000a            elif LowerBrackets.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine* updates\u000a            if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine.frameNStart = frameN  # exact frame index\u000a                BotLowerLine.setAutoDraw(True)\u000a            elif BotLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair* updates\u000a            if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair.setAutoDraw(True)\u000a            elif TrialCrossHair.status == STARTED and t >= (0 + (TrialDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= TrialDur and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            elif RestCrossHair.status == STARTED and t >= (TrialDur + (ITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # *KeyboardResp* updates\u000a            if t >= ProbeStart and KeyboardResp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                KeyboardResp.tStart = t  # underestimates by a little under one frame\u000a                KeyboardResp.frameNStart = frameN  # exact frame index\u000a                KeyboardResp.status = STARTED\u000a                # keyboard checking is just starting\u000a                KeyboardResp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif KeyboardResp.status == STARTED and t >= (ProbeStart + (ProbeDurITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                KeyboardResp.status = STOPPED\u000a            if KeyboardResp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    KeyboardResp.keys.extend(theseKeys)  # storing all keys\u000a                    KeyboardResp.rt.append(KeyboardResp.clock.getTime())\u000a                    # was this 'correct'?\u000a                    if (KeyboardResp.keys == str(Correct)) or (KeyboardResp.keys == Correct):\u000a                        KeyboardResp.corr = 1\u000a                    else:\u000a                        KeyboardResp.corr = 0\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(1)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if KeyboardResp.keys in ['', [], None]:  # No response was made\u000a           KeyboardResp.keys=None\u000a           # was no response the correct answer?!\u000a           if str(Correct).lower() == 'none': KeyboardResp.corr = 1  # correct non-response\u000a           else: KeyboardResp.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('KeyboardResp.keys',KeyboardResp.keys)\u000a        trials.addData('KeyboardResp.corr', KeyboardResp.corr)\u000a        if KeyboardResp.keys != None:  # we had a response\u000a            trials.addData('KeyboardResp.rt', KeyboardResp.rt)\u000a        thisExp.nextEntry()\u000a        \u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    EndTimeClock = core.Clock()\u000a    EndTimeClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(End)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    EndTimeComponents = []\u000a    EndTimeComponents.append(RestCrossHair)\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = EndTimeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        if RestCrossHair.status == STARTED and t >= (0.0 + (End-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in EndTimeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            #win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # ########################################################\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()    \u000a    # completed 1 repeats of 'trials'\u000a    # the Routine "trial" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    win.close()\u000a    #sys.exit()\u000a    return filename\u000a\u000adef PartialTrialFeedback(INPUTFILE,filename,subid=9999,visitid=9999):\u000a    # filename is for the output file where the data gets written to\u000a    expInfo = {u'Visit ID': u'001', u'Participant ID': u''}\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a        if dlg.OK == False: win.close()  # user pressed cancel\u000a    else:\u000a        print "Subid entered is: %s"%(subid)\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid\u000a        \u000a    # Store info about the experiment session\u000a\u000a    \u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    \u000a    # The following line is commented out because now the output file is given as an input. \u000a    # This allows better control over what it is called.\u000a    #filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=True,\u000a        dataFileName=filename)\u000a    #save a log file for detail verbose info\u000a    logFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=u'testMonitor', color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'use preferences')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial"\u000a    trialClock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=1.7,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.25, wrapWidth=1.7,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.25, wrapWidth=1.5,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    WaitForScanner = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Waiting for Scanner\u005cn Or press r to advance',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    ThankYou = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'Merci\u005cnThank you',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    # Initialize components for Routine "Feedback"\u000a    FeedbackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    FeedbackMsg = visual.TextStim(win=win, ori=0, name='FeedbackMsg',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=1, method=u'sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=data.importConditions(INPUTFILE),#TrialListShort1#TrialList5Loads6Repeats\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a\u000a\u000a    # PRESENT THE SCREEN TO WAIT FOR THE MRI TRIGGER\u000a    #vol = launchScan(win, MR_settings,  mode='Scan')\u000a\u000a    # ########################################################\u000a    # There should be WAITING FOR SCANNER trial here\u000a    # The test2 routine has these parts in it\u000a    #------Prepare to start Routine "ScanWait"-------\u000a    t = 0\u000a    ScanWaitClock = core.Clock()\u000a    ScanWaitClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    ScannerTrigger = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    ScannerTrigger.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    ScanWaitComponents = []\u000a    ScanWaitComponents.append(WaitForScanner)\u000a    ScanWaitComponents.append(ScannerTrigger)\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "ScanWait"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = ScanWaitClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_4* updates\u000a        if t >= 0.0 and WaitForScanner.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            WaitForScanner.tStart = t  # underestimates by a little under one frame\u000a            WaitForScanner.frameNStart = frameN  # exact frame index\u000a            WaitForScanner.setAutoDraw(True)\u000a        \u000a        # *key_resp_3* updates\u000a        if t >= 0.0 and ScannerTrigger.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ScannerTrigger.tStart = t  # underestimates by a little under one frame\u000a            ScannerTrigger.frameNStart = frameN  # exact frame index\u000a            ScannerTrigger.status = STARTED\u000a            # keyboard checking is just starting\u000a            ScannerTrigger.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if ScannerTrigger.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['5', 'r'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                ScannerTrigger.keys = theseKeys[-1]  # just the last key pressed\u000a                ScannerTrigger.rt = ScannerTrigger.clock.getTime()\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ScanWaitComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            #core.quit()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a        else:  # this Routine was not non-slip safe so reset non-slip timer\u000a            routineTimer.reset()\u000a\u000a    #-------Ending Routine "ScanWait"-------\u000a    for thisComponent in ScanWaitComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if ScannerTrigger.keys in ['', [], None]:  # No response was made\u000a       ScannerTrigger.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('ScannerTrigger.keys',ScannerTrigger.keys)\u000a    if ScannerTrigger.keys != None:  # we had a response\u000a        thisExp.addData('ScannerTrigger.rt', ScannerTrigger.rt)\u000a    thisExp.nextEntry()\u000a    # ########################################################\u000a\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a    IntroTime = 5\u000a    # Write out when the experiment begins\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    #------Prepare to start Routine "intro"-------\u000a    t = 0\u000a    introClock = core.Clock()\u000a    introClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(IntroTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    introComponents = []\u000a    introComponents.append(RestCrossHair)\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "intro"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = introClock.getTime()\u000a        \u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_3* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (0.0 + (IntroTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in introComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "intro"-------\u000a    for thisComponent in introComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    # ########################################################\u000a\u000a    for thisTrial in trials:\u000a        # Write to the file the time this trial starts\u000a        trials.addData('TrialStartTime',time.time())\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "trial"-------\u000a        t = 0\u000a        trialClock.reset()  # clock \u000a        frameN = -1\u000a        \u000a        # ENCODING SET\u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempStimSet = StimSet\u000a        # Letters for space - letter - space - letter ... - space\u000a        StimSet=' '\u000a        for i in tempStimSet:\u000a            StimSet=StimSet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        UpBrackText = ''\u000a        if UpBrack > 0:\u000a            BracketList = list(str(UpBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,13,1):   ## Changed from 13 when using 7 letters\u000a                UpBrackText = UpBrackText+' '\u000a            s = list(UpBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            UpBrackText = ''.join(s)\u000a        \u000a        # PROBE \u000a        # Add spaces to between the letters of the stimulus set\u000a        # Note use Courier font because it is monspaced\u000a        tempProbeLet = ProbeLet\u000a        print '%s'%(tempProbeLet)\u000a        # Letters for space - letter - space - letter ... - space\u000a        ProbeLet=' '\u000a        for i in tempProbeLet:\u000a            ProbeLet = ProbeLet+i+' '\u000a        # Create the brackets\u000a        # What bracket positions to use?\u000a        # Find the first character of the bracket variable\u000a        BotBrackText = ''\u000a        if BotBrack > 0:\u000a            BracketList = list(str(BotBrack))\u000a            LeftBrackPos = int(BracketList[0])\u000a            RightBrackPos = int(BracketList[-1])\u000a            for i in range(0,13,1):   ## Changed from 13 when using 7 letters\u000a                BotBrackText = BotBrackText+' '\u000a            s = list(BotBrackText)\u000a            s[2*LeftBrackPos-1-1]='{'\u000a            s[2*RightBrackPos-1+1]='}'\u000a            BotBrackText = ''.join(s)\u000a            \u000a        # update component parameters for each repeat\u000a        UpperText.setText(StimSet)\u000a        UpperBrackets.setText(UpBrackText)\u000a        LowerText.setText(ProbeLet)\u000a        LowerBrackets.setText(BotBrackText)\u000a        \u000a        KeyboardResp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        KeyboardResp.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        trialComponents = []\u000a        trialComponents.append(ISI)\u000a        trialComponents.append(TopUpperLine)\u000a        trialComponents.append(UpperText)\u000a        trialComponents.append(UpperBrackets)\u000a        trialComponents.append(BotUpperLine)\u000a        trialComponents.append(TopLowerLine)\u000a        trialComponents.append(LowerText)\u000a        trialComponents.append(LowerBrackets)\u000a        trialComponents.append(BotLowerLine)\u000a        trialComponents.append(TrialCrossHair)\u000a        trialComponents.append(RestCrossHair)\u000a        trialComponents.append(KeyboardResp)\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "trial"-------\u000a        continueRoutine = True\u000a        while continueRoutine:\u000a            # get current time\u000a            t = trialClock.getTime()\u000a            \u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *TopUpperLine* updates\u000a            if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine.frameNStart = frameN  # exact frame index\u000a                TopUpperLine.setAutoDraw(True)\u000a            elif TopUpperLine.status == STARTED and t >= (0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine.setAutoDraw(False)\u000a            \u000a            # *UpperText* updates\u000a            if t >= 0 and UpperText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText.tStart = t  # underestimates by a little under one frame\u000a                UpperText.frameNStart = frameN  # exact frame index\u000a                UpperText.setAutoDraw(True)\u000a            elif UpperText.status == STARTED and t >= (0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets* updates\u000a            if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets.frameNStart = frameN  # exact frame index\u000a                UpperBrackets.setAutoDraw(True)\u000a            elif UpperBrackets.status == STARTED and t >= (0.0 + (StimDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine* updates\u000a            if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine.frameNStart = frameN  # exact frame index\u000a                BotUpperLine.setAutoDraw(True)\u000a            elif BotUpperLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine* updates\u000a            if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine.frameNStart = frameN  # exact frame index\u000a                TopLowerLine.setAutoDraw(True)\u000a            elif TopLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine.setAutoDraw(False)\u000a            \u000a            # *LowerText* updates\u000a            if t >= ProbeStart and LowerText.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText.tStart = t  # underestimates by a little under one frame\u000a                LowerText.frameNStart = frameN  # exact frame index\u000a                LowerText.setAutoDraw(True)\u000a            elif LowerText.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets* updates\u000a            if t >= ProbeStart and LowerBrackets.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets.frameNStart = frameN  # exact frame index\u000a                LowerBrackets.setAutoDraw(True)\u000a            elif LowerBrackets.status == STARTED and t >= (ProbeStart + (ProbeDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine* updates\u000a            if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine.frameNStart = frameN  # exact frame index\u000a                BotLowerLine.setAutoDraw(True)\u000a            elif BotLowerLine.status == STARTED and t >= (0.0 + (TrialITIDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair* updates\u000a            if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair.setAutoDraw(True)\u000a            elif TrialCrossHair.status == STARTED and t >= (0 + (TrialDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= TrialDur and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            elif RestCrossHair.status == STARTED and t >= (TrialDur + (ITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # *KeyboardResp* updates\u000a            if t >= ProbeStart and KeyboardResp.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                KeyboardResp.tStart = t  # underestimates by a little under one frame\u000a                KeyboardResp.frameNStart = frameN  # exact frame index\u000a                KeyboardResp.status = STARTED\u000a                # keyboard checking is just starting\u000a                KeyboardResp.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif KeyboardResp.status == STARTED and t >= (ProbeStart + (ProbeDurITI-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                KeyboardResp.status = STOPPED\u000a            if KeyboardResp.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    #KeyboardResp.keys.extend(theseKeys)  # storing all keys\u000a                    KeyboardResp.keys = theseKeys[-1]  # just the last key pressed\u000a                    #KeyboardResp.rt.append(KeyboardResp.clock.getTime())\u000a                    KeyboardResp.rt = KeyboardResp.clock.getTime()\u000a                    # was this 'correct'?\u000a                    # What if the participant responded whenthey were not supposed to?\u000a                    if str(Correct).lower() == 'none':\u000a                        KeyboardResp.corr = -10 # RESPONSE WHEN NONE WAS EXPECTED\u000a                    else:\u000a                        if (KeyboardResp.keys == str(Correct)) or (KeyboardResp.keys == Correct):\u000a                            KeyboardResp.corr = 1 # CORRECT\u000a                        else:\u000a                            KeyboardResp.corr = 0 # INCORRECT\u000a                    # was this 'correct'?\u000a            # *ISI* period\u000a            if t >= 0.0 and ISI.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI.tStart = t  # underestimates by a little under one frame\u000a                ISI.frameNStart = frameN  # exact frame index\u000a                ISI.start(1)\u000a            elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in trialComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a            else:  # this Routine was not non-slip safe so reset non-slip timer\u000a                routineTimer.reset()\u000a        \u000a        #-------Ending Routine "trial"-------\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if KeyboardResp.keys in ['', [], None]:  # No response was made\u000a           KeyboardResp.keys=None\u000a           # was no response the correct answer?!\u000a           if str(Correct).lower() == 'none': KeyboardResp.corr = 10  # correct non-response\u000a           else: KeyboardResp.corr = -1  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('KeyboardResp.keys',KeyboardResp.keys)\u000a        trials.addData('KeyboardResp.corr', KeyboardResp.corr)\u000a        if KeyboardResp.keys != None:  # we had a response\u000a            trials.addData('KeyboardResp.rt', KeyboardResp.rt)\u000a        thisExp.nextEntry()\u000a        \u000a        \u000a    # ########################################################    \u000a        #------Prepare to start Routine "Feedback"-------\u000a        FeedbackDur = 1.5\u000a        t = 0\u000a        FeedbackClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(FeedbackDur)\u000a        # update component parameters for each repeat\u000a        if KeyboardResp.corr == 1:#stored on last run routine\u000a          msg="Correct! RT=%.3f" %(KeyboardResp.rt)\u000a        elif KeyboardResp.corr == 0:\u000a          msg="Oops! That was wrong"\u000a        elif KeyboardResp.corr == -1:\u000a          msg="No response...miss"\u000a        elif KeyboardResp.corr == 10:\u000a          msg="No response, good!"\u000a        FeedbackMsg.setText(msg)\u000a        # keep track of which components have finished\u000a        FeedbackComponents = []\u000a        FeedbackComponents.append(FeedbackMsg)\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = FeedbackClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *FeedbackMsg* updates\u000a            if t >= 0.0 and FeedbackMsg.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                FeedbackMsg.tStart = t  # underestimates by a little under one frame\u000a                FeedbackMsg.frameNStart = frameN  # exact frame index\u000a                FeedbackMsg.setAutoDraw(True)\u000a            if FeedbackMsg.status == STARTED and t >= (0.0 + (FeedbackDur-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                FeedbackMsg.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in FeedbackComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback"-------\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a\u000a\u000a        #------Prepare to start Routine "REST"-------\u000a        t = 0\u000a        RESTClock = core.Clock()\u000a        RESTClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(1.000000)\u000a        # update component parameters for each repeat\u000a        # keep track of which components have finished\u000a        RESTComponents = []\u000a        RESTComponents.append(RestCrossHair)\u000a        for thisComponent in RESTComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "REST"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = RESTClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *RestCrossHair* updates\u000a            if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair.frameNStart = frameN  # exact frame index\u000a                RestCrossHair.setAutoDraw(True)\u000a            if RestCrossHair.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in RESTComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a\u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "REST"-------\u000a        for thisComponent in RESTComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        thisExp.nextEntry()\u000a\u000a\u000a    win.flip()\u000a    # ########################################################\u000a    # There should be an intro off trial here also\u000a    EndTime = 10\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    EndTimeClock = core.Clock()\u000a    EndTimeClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(EndTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    EndTimeComponents = []\u000a    EndTimeComponents.append(RestCrossHair)\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = EndTimeClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        if RestCrossHair.status == STARTED and t >= (0.0 + (EndTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in EndTimeComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a            \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "EndTime"-------\u000a    for thisComponent in EndTimeComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a            \u000a    # ########################################################        \u000a    # There should be an intro off trial here also\u000a    ThankYouTime = 3\u000a    #------Prepare to start Routine "EndTime"-------\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()\u000a    t = 0\u000a    ThankYouClock = core.Clock()\u000a    ThankYouClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(ThankYouTime)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    ThankYouComponents = []\u000a    ThankYouComponents.append(ThankYou)\u000a    for thisComponent in ThankYouComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "EndTime"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = ThankYouClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *End* updates\u000a        if t >= 0.0 and ThankYou.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ThankYou.tStart = t  # underestimates by a little under one frame\u000a            ThankYou.frameNStart = frameN  # exact frame index\u000a            ThankYou.setAutoDraw(True)\u000a        if ThankYou.status == STARTED and t >= (0.0 + (ThankYouTime-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            ThankYou.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in ThankYouComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "Thank you"-------\u000a    for thisComponent in ThankYouComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)       \u000a    # ########################################################\u000a    thisExp.addData('TrialStartTime', time.time())\u000a    thisExp.nextEntry()    \u000a    # completed 1 repeats of 'trials'\u000a    win.close()\u000a#    win.close()\u000a\u000adef Instructions():\u000a    # Store info about the experiment session\u000a    expName = u'Instructions'  # from the Builder filename that created this script\u000a    expInfo = {u'session': u'001', u'participant': u''}\u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=False,\u000a        dataFileName=filename)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=u'UbuntuMon', color=[-1,-1,-1], colorSpace=u'rgb',\u000a        blendMode=u'add', useFBO=True,\u000a        units=u'norm')\u000a\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "ButtonPractice"\u000a    ButtonPracticeClock = core.Clock()\u000a    text_28 = visual.TextStim(win=win, ori=0, name='text_28',\u000a        text="First ...\u005cnLet's make sure the buttons work.\u005cnPress the RIGHT INDEX Finger button.",    font='Courier',\u000a        pos=[0,0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    ISI_14 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_14')\u000a    TopUpperLine_14 = visual.Line(win=win, name='TopUpperLine_14',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_14 = visual.TextStim(win=win, ori=0, name='UpperText_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    UpperBrackets_14 = visual.TextStim(win=win, ori=0, name='UpperBrackets_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    BotUpperLine_14 = visual.Line(win=win, name='BotUpperLine_14',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_14 = visual.Line(win=win, name='TopLowerLine_14',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_14 = visual.TextStim(win=win, ori=0, name='LowerText_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    LowerBrackets_14 = visual.TextStim(win=win, ori=0, name='LowerBrackets_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    BotLowerLine_14 = visual.Line(win=win, name='BotLowerLine_14',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_14 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_14',\u000a        text='\u005cn',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    RestCrossHair_14 = visual.TextStim(win=win, ori=0, name='RestCrossHair_14',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a\u000a    # Initialize components for Routine "Feedback"\u000a    FeedbackClock = core.Clock()\u000a    msg='?????'\u000a    text_25 = visual.TextStim(win=win, ori=0, name='text_25',\u000a        text='default text',    font='Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Initialize components for Routine "ButtonPractice_MIDDLE"\u000a    ButtonPractice_MIDDLEClock = core.Clock()\u000a    text_29 = visual.TextStim(win=win, ori=0, name='text_29',\u000a        text='Press the RIGHT MIDDLE Finger button.',    font='Courier',\u000a        pos=[0,0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    ISI_15 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_15')\u000a    TopUpperLine_15 = visual.Line(win=win, name='TopUpperLine_15',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_15 = visual.TextStim(win=win, ori=0, name='UpperText_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    UpperBrackets_15 = visual.TextStim(win=win, ori=0, name='UpperBrackets_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    BotUpperLine_15 = visual.Line(win=win, name='BotUpperLine_15',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_15 = visual.Line(win=win, name='TopLowerLine_15',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_15 = visual.TextStim(win=win, ori=0, name='LowerText_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    LowerBrackets_15 = visual.TextStim(win=win, ori=0, name='LowerBrackets_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    BotLowerLine_15 = visual.Line(win=win, name='BotLowerLine_15',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_15 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_15',\u000a        text='\u005cn',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    RestCrossHair_15 = visual.TextStim(win=win, ori=0, name='RestCrossHair_15',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a\u000a    # Initialize components for Routine "Feedback_MIDDLE"\u000a    Feedback_MIDDLEClock = core.Clock()\u000a    msg='?????'\u000a    text_26 = visual.TextStim(win=win, ori=0, name='text_26',\u000a        text='default text',    font=u'Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_2"\u000a    var_6Letters_2Clock = core.Clock()\u000a    text_13 = visual.TextStim(win=win, ori=0, name='text_13',\u000a        text='This is the screen you will see for each trial',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text_16 = visual.TextStim(win=win, ori=0, name='text_16',\u000a        text='With an UPPER Part',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_18 = visual.TextStim(win=win, ori=0, name='text_18',\u000a        text='And a LOWER part',    font='Courier',\u000a        pos=[0,-0.3], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_21 = visual.TextStim(win=win, ori=0, name='text_21',\u000a        text=None,    font='Courier',\u000a        pos=[0, 0], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_13 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_13')\u000a    TopUpperLine_13 = visual.Line(win=win, name='TopUpperLine_13',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_13 = visual.TextStim(win=win, ori=0, name='UpperText_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_13 = visual.TextStim(win=win, ori=0, name='UpperBrackets_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_13 = visual.Line(win=win, name='BotUpperLine_13',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_13 = visual.Line(win=win, name='TopLowerLine_13',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_13 = visual.TextStim(win=win, ori=0, name='LowerText_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_13 = visual.TextStim(win=win, ori=0, name='LowerBrackets_13',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_13 = visual.Line(win=win, name='BotLowerLine_13',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_13 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_13',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_13 = visual.TextStim(win=win, ori=0, name='RestCrossHair_13',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_22 = visual.TextStim(win=win, ori=0, name='text_22',\u000a        text='You will also see a cross hair on the screen',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_23 = visual.TextStim(win=win, ori=0, name='text_23',\u000a        text='Either Green',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_24 = visual.TextStim(win=win, ori=0, name='text_24',\u000a        text='Or RED',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_0"\u000a    var_6Letters_0Clock = core.Clock()\u000a    text_2 = visual.TextStim(win=win, ori=0, name='text_2',\u000a        text='For this experiment you will see letters at the top of the screen.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.1,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text = visual.TextStim(win=win, ori=0, name='text',\u000a        text='Some of the letters will be enclosed by brackets.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_6 = visual.TextStim(win=win, ori=0, name='text_6',\u000a        text=u'These are the letters to remember.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_4 = visual.TextStim(win=win, ori=0, name='text_4',\u000a        text='The letters will be removed, focus on the green cross hair.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_11 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_11')\u000a    TopUpperLine_11 = visual.Line(win=win, name='TopUpperLine_11',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_11 = visual.TextStim(win=win, ori=0, name='UpperText_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_11 = visual.TextStim(win=win, ori=0, name='UpperBrackets_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_11 = visual.Line(win=win, name='BotUpperLine_11',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_11 = visual.Line(win=win, name='TopLowerLine_11',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_11 = visual.TextStim(win=win, ori=0, name='LowerText_11',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_11 = visual.TextStim(win=win, ori=0, name='LowerBrackets_11',\u000a        text='  { }        ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_11 = visual.Line(win=win, name='BotLowerLine_11',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_11 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_11',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_11 = visual.TextStim(win=win, ori=0, name='RestCrossHair_11',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_5 = visual.TextStim(win=win, ori=0, name='text_5',\u000a        text='You will then see letters at the bottom.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.1,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_7 = visual.TextStim(win=win, ori=0, name='text_7',\u000a        text='Only one letter will be in brackets.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a    text_8 = visual.TextStim(win=win, ori=0, name='text_8',\u000a        text='You need to decide whether this letter was one that you had to remember.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-18.0)\u000a    text_9 = visual.TextStim(win=win, ori=0, name='text_9',\u000a        text='YES = INDEX finger button\u005cnNO  = MIDDLE finger button',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-19.0)\u000a    text_10 = visual.TextStim(win=win, ori=0, name='text_10',\u000a        text='The trial is then over and the cross hair turns RED.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-20.0)\u000a\u000a    # Initialize components for Routine "var_6Letters_1"\u000a    var_6Letters_1Clock = core.Clock()\u000a    text_11 = visual.TextStim(win=win, ori=0, name='text_11',\u000a        text=u"Let's Repeat",    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_12 = visual.TextStim(win=win, ori=0, name='text_12',\u000a        text='Remember the letters B and C',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_14 = visual.TextStim(win=win, ori=0, name='text_14',\u000a        text=u'Letters are removed',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    ISI_12 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_12')\u000a    TopUpperLine_12 = visual.Line(win=win, name='TopUpperLine_12',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_12 = visual.TextStim(win=win, ori=0, name='UpperText_12',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-5.0)\u000a    UpperBrackets_12 = visual.TextStim(win=win, ori=0, name='UpperBrackets_12',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    BotUpperLine_12 = visual.Line(win=win, name='BotUpperLine_12',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_12 = visual.Line(win=win, name='TopLowerLine_12',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_12 = visual.TextStim(win=win, ori=0, name='LowerText_12',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    LowerBrackets_12 = visual.TextStim(win=win, ori=0, name='LowerBrackets_12',\u000a        text='  { }        ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    BotLowerLine_12 = visual.Line(win=win, name='BotLowerLine_12',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_12 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_12',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-12.0)\u000a    RestCrossHair_12 = visual.TextStim(win=win, ori=0, name='RestCrossHair_12',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    text_17 = visual.TextStim(win=win, ori=0, name='text_17',\u000a        text=u'Are you trying to remember the letter b?',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_19 = visual.TextStim(win=win, ori=0, name='text_19',\u000a        text=u'Yes you are. You would press the INDEX finger button as quickly as possible.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_20 = visual.TextStim(win=win, ori=0, name='text_20',\u000a        text=u'The trial is over and the cross hair turns RED.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "DemoTrialRealTimes"\u000a    DemoTrialRealTimesClock = core.Clock()\u000a    text_44 = visual.TextStim(win=win, ori=0, name='text_44',\u000a        text=u"Let's repeat at the true pace",    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_45 = visual.TextStim(win=win, ori=0, name='text_45',\u000a        text=u'Remember the letters B and C',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_46 = visual.TextStim(win=win, ori=0, name='text_46',\u000a        text=u'Letters are removed',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    ISI_18 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_18')\u000a    TopUpperLine_18 = visual.Line(win=win, name='TopUpperLine_18',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_18 = visual.TextStim(win=win, ori=0, name='UpperText_18',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-5.0)\u000a    UpperBrackets_18 = visual.TextStim(win=win, ori=0, name='UpperBrackets_18',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    BotUpperLine_18 = visual.Line(win=win, name='BotUpperLine_18',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_18 = visual.Line(win=win, name='TopLowerLine_18',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_17 = visual.TextStim(win=win, ori=0, name='LowerText_17',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-9.0)\u000a    LowerBrackets_17 = visual.TextStim(win=win, ori=0, name='LowerBrackets_17',\u000a        text=u'  { }        ',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a    BotLowerLine_18 = visual.Line(win=win, name='BotLowerLine_18',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_18 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_18',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'green', colorSpace=u'rgb', opacity=1,\u000a        depth=-12.0)\u000a    RestCrossHair_18 = visual.TextStim(win=win, ori=0, name='RestCrossHair_18',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-13.0)\u000a    text_48 = visual.TextStim(win=win, ori=0, name='text_48',\u000a        text=u'Respond as quickly as possible',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_49 = visual.TextStim(win=win, ori=0, name='text_49',\u000a        text=u'The trial is over and the cross hair turns RED.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-16.0)\u000a\u000a    # Initialize components for Routine "NumLettersToRem"\u000a    NumLettersToRemClock = core.Clock()\u000a    text_15 = visual.TextStim(win=win, ori=0, name='text_15',\u000a        text='The number of letters to remember',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=0.0)\u000a    text_33 = visual.TextStim(win=win, ori=0, name='text_33',\u000a        text='Varies between 1 and 6',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_34 = visual.TextStim(win=win, ori=0, name='text_34',\u000a        text='There will always be six letters presented',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_3 = visual.TextStim(win=win, ori=0, name='text_3',\u000a        text='It is the brackets that indicate which letters to remember.',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    text_35 = visual.TextStim(win=win, ori=0, name='text_35',\u000a        text='Here are some examples',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-4.0)\u000a    UpBrack1 = visual.TextStim(win=win, ori=0, name='UpBrack1',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-5.0)\u000a    ISI_17 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_17')\u000a    TopUpperLine_17 = visual.Line(win=win, name='TopUpperLine_17',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_17 = visual.TextStim(win=win, ori=0, name='UpperText_17',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-8.0)\u000a    UpperBrackets_17 = visual.TextStim(win=win, ori=0, name='UpperBrackets_17',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    BotUpperLine_17 = visual.Line(win=win, name='BotUpperLine_17',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_17 = visual.Line(win=win, name='TopLowerLine_17',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    BotLowerLine_17 = visual.Line(win=win, name='BotLowerLine_17',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_17 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_17',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_17 = visual.TextStim(win=win, ori=0, name='RestCrossHair_17',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    UpBrack2 = visual.TextStim(win=win, ori=0, name='UpBrack2',\u000a        text='{   }        ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    UpBrack3 = visual.TextStim(win=win, ori=0, name='UpBrack3',\u000a        text='      {     }',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='Yellow', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    UpBrack4 = visual.TextStim(win=win, ori=0, name='UpBrack4',\u000a        text='  {       }  ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-17.0)\u000a    UpBrack5 = visual.TextStim(win=win, ori=0, name='UpBrack5',\u000a        text='{         }  ',    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-18.0)\u000a    UpBrack6 = visual.TextStim(win=win, ori=0, name='UpBrack6',\u000a        text=u'{           }',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-19.0)\u000a    text_38 = visual.TextStim(win=win, ori=0, name='text_38',\u000a        text=u'One letter',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-20.0)\u000a    text_39 = visual.TextStim(win=win, ori=0, name='text_39',\u000a        text=u'Two letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-21.0)\u000a    text_40 = visual.TextStim(win=win, ori=0, name='text_40',\u000a        text=u'Three letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-22.0)\u000a    text_41 = visual.TextStim(win=win, ori=0, name='text_41',\u000a        text=u'Four letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-23.0)\u000a    text_42 = visual.TextStim(win=win, ori=0, name='text_42',\u000a        text=u'Five letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-24.0)\u000a    text_43 = visual.TextStim(win=win, ori=0, name='text_43',\u000a        text=u'Six letters',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-25.0)\u000a\u000a    # Initialize components for Routine "TrialParts_1"\u000a    TrialParts_1Clock = core.Clock()\u000a    text_27 = visual.TextStim(win=win, ori=0, name='text_27',\u000a        text=u'To help with the analysis of the brain data.\u005cnSome trials are PARTIAL.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=0.0)\u000a    text_30 = visual.TextStim(win=win, ori=0, name='text_30',\u000a        text='All trials will have a set of letters to study.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.25,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a    text_31 = visual.TextStim(win=win, ori=0, name='text_31',\u000a        text='Some will not require a response',    font='Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    text_32 = visual.TextStim(win=win, ori=0, name='text_32',\u000a        text='Some will have no delay between the letters to study and the response.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    ISI_16 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_16')\u000a    TopUpperLine_16 = visual.Line(win=win, name='TopUpperLine_16',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText_16 = visual.TextStim(win=win, ori=0, name='UpperText_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    UpperBrackets_16 = visual.TextStim(win=win, ori=0, name='UpperBrackets_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotUpperLine_16 = visual.Line(win=win, name='BotUpperLine_16',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine_16 = visual.Line(win=win, name='TopLowerLine_16',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText_16 = visual.TextStim(win=win, ori=0, name='LowerText_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a    LowerBrackets_16 = visual.TextStim(win=win, ori=0, name='LowerBrackets_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-11.0)\u000a    BotLowerLine_16 = visual.Line(win=win, name='BotLowerLine_16',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair_16 = visual.TextStim(win=win, ori=0, name='TrialCrossHair_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-13.0)\u000a    RestCrossHair_16 = visual.TextStim(win=win, ori=0, name='RestCrossHair_16',\u000a        text=None,    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-14.0)\u000a    text_36 = visual.TextStim(win=win, ori=0, name='text_36',\u000a        text='What is important is that when the crosshair turns RED. The trial is over.',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-15.0)\u000a    text_37 = visual.TextStim(win=win, ori=0, name='text_37',\u000a        text='Try to forget any of the studied letters and wait for the next trial',    font='Courier',\u000a        units='norm', pos=[0, 0.8], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-16.0)\u000a    text_50 = visual.TextStim(win=win, ori=0, name='text_50',\u000a        text=u'Here is an example trial with feedback.\u005cnRemember respond as quickly as possible.',    font=u'Courier',\u000a        pos=[0, 0.8], height=0.1, wrapWidth=None,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-17.0)\u000a\u000a    # Initialize components for Routine "trial5_2"\u000a    trial5_2Clock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0,0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'[1,1,-1]', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,0.3], height=0.2, wrapWidth=1.5,\u000a        color=u'yellow', colorSpace=u'rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units=u'norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace=u'rgb',\u000a        fillColor=u'yellow', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace=u'rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text=u'      { }    ',    font=u'Courier',\u000a        units=u'norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color=u'cyan', colorSpace=u'rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units=u'norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor=u'cyan', lineColorSpace=u'rgb',\u000a        fillColor=u'cyan', fillColorSpace=u'rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text=u'+',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color=u'red', colorSpace=u'rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Initialize components for Routine "TrialFeedBack"\u000a    TrialFeedBackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    text_47 = visual.TextStim(win=win, ori=0, name='text_47',\u000a        text='default text',    font=u'Courier',\u000a        units=u'norm', pos=[0, 0], height=0.1, wrapWidth=1.5,\u000a        color=u'white', colorSpace=u'rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials = data.TrialHandler(nReps=10, method='sequential', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='trials')\u000a    thisExp.addLoop(trials)  # add the loop to the experiment\u000a    thisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a\u000a    for thisTrial in trials:\u000a        currentLoop = trials\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a        if thisTrial != None:\u000a            for paramName in thisTrial.keys():\u000a                exec(paramName + '= thisTrial.' + paramName)\u000a        \u000a        #------Prepare to start Routine "ButtonPractice"-------\u000a        t = 0\u000a        ButtonPracticeClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(120.000000)\u000a        # update component parameters for each repeat\u000a        UpperText_14.setText('')\u000a        UpperBrackets_14.setText('')\u000a        LowerText_14.setText('')\u000a        key_resp_2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_2.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        ButtonPracticeComponents = []\u000a        ButtonPracticeComponents.append(text_28)\u000a        ButtonPracticeComponents.append(ISI_14)\u000a        ButtonPracticeComponents.append(TopUpperLine_14)\u000a        ButtonPracticeComponents.append(UpperText_14)\u000a        ButtonPracticeComponents.append(UpperBrackets_14)\u000a        ButtonPracticeComponents.append(BotUpperLine_14)\u000a        ButtonPracticeComponents.append(TopLowerLine_14)\u000a        ButtonPracticeComponents.append(LowerText_14)\u000a        ButtonPracticeComponents.append(LowerBrackets_14)\u000a        ButtonPracticeComponents.append(BotLowerLine_14)\u000a        ButtonPracticeComponents.append(TrialCrossHair_14)\u000a        ButtonPracticeComponents.append(RestCrossHair_14)\u000a        ButtonPracticeComponents.append(key_resp_2)\u000a        for thisComponent in ButtonPracticeComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "ButtonPractice"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = ButtonPracticeClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_28* updates\u000a            if t >= 0 and text_28.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_28.tStart = t  # underestimates by a little under one frame\u000a                text_28.frameNStart = frameN  # exact frame index\u000a                text_28.setAutoDraw(True)\u000a            elif text_28.status == STARTED and t >= (0 + (60-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_28.setAutoDraw(False)\u000a            \u000a            # *TopUpperLine_14* updates\u000a            if t >= 0 and TopUpperLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine_14.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine_14.frameNStart = frameN  # exact frame index\u000a                TopUpperLine_14.setAutoDraw(True)\u000a            elif TopUpperLine_14.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine_14.setAutoDraw(False)\u000a            \u000a            # *UpperText_14* updates\u000a            if t >= 0 and UpperText_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText_14.tStart = t  # underestimates by a little under one frame\u000a                UpperText_14.frameNStart = frameN  # exact frame index\u000a                UpperText_14.setAutoDraw(True)\u000a            elif UpperText_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText_14.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets_14* updates\u000a            if t >= 0 and UpperBrackets_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets_14.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets_14.frameNStart = frameN  # exact frame index\u000a                UpperBrackets_14.setAutoDraw(True)\u000a            elif UpperBrackets_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets_14.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine_14* updates\u000a            if t >= 0.0 and BotUpperLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine_14.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine_14.frameNStart = frameN  # exact frame index\u000a                BotUpperLine_14.setAutoDraw(True)\u000a            elif BotUpperLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine_14.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine_14* updates\u000a            if t >= 0.0 and TopLowerLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine_14.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine_14.frameNStart = frameN  # exact frame index\u000a                TopLowerLine_14.setAutoDraw(True)\u000a            elif TopLowerLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine_14.setAutoDraw(False)\u000a            \u000a            # *LowerText_14* updates\u000a            if t >= 0 and LowerText_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText_14.tStart = t  # underestimates by a little under one frame\u000a                LowerText_14.frameNStart = frameN  # exact frame index\u000a                LowerText_14.setAutoDraw(True)\u000a            elif LowerText_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText_14.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets_14* updates\u000a            if t >= 0 and LowerBrackets_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets_14.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets_14.frameNStart = frameN  # exact frame index\u000a                LowerBrackets_14.setAutoDraw(True)\u000a            elif LowerBrackets_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets_14.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine_14* updates\u000a            if t >= 0.0 and BotLowerLine_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine_14.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine_14.frameNStart = frameN  # exact frame index\u000a                BotLowerLine_14.setAutoDraw(True)\u000a            elif BotLowerLine_14.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine_14.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair_14* updates\u000a            if t >= 0 and TrialCrossHair_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair_14.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair_14.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair_14.setAutoDraw(True)\u000a            elif TrialCrossHair_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair_14.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair_14* updates\u000a            if t >= 0 and RestCrossHair_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair_14.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair_14.frameNStart = frameN  # exact frame index\u000a                RestCrossHair_14.setAutoDraw(True)\u000a            elif RestCrossHair_14.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair_14.setAutoDraw(False)\u000a            \u000a            # *key_resp_2* updates\u000a            if t >= 0.0 and key_resp_2.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_2.tStart = t  # underestimates by a little under one frame\u000a                key_resp_2.frameNStart = frameN  # exact frame index\u000a                key_resp_2.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_2.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif key_resp_2.status == STARTED and t >= (0.0 + (60-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_2.status = STOPPED\u000a            if key_resp_2.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8', '9','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_2.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_2.rt = key_resp_2.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_2.keys == str('6')) or (key_resp_2.keys == 'down'):\u000a                        key_resp_2.corr = 1\u000a                    else:\u000a                        key_resp_2.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            # *ISI_14* period\u000a            if t >= 0.0 and ISI_14.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI_14.tStart = t  # underestimates by a little under one frame\u000a                ISI_14.frameNStart = frameN  # exact frame index\u000a                ISI_14.start(1)\u000a            elif ISI_14.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI_14.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in ButtonPracticeComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                #win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "ButtonPractice"-------\u000a        for thisComponent in ButtonPracticeComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_2.keys in ['', [], None]:  # No response was made\u000a           key_resp_2.keys=None\u000a           # was no response the correct answer?!\u000a           if str('6').lower() == 'none': key_resp_2.corr = 1  # correct non-response\u000a           else: key_resp_2.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials (TrialHandler)\u000a        trials.addData('key_resp_2.keys',key_resp_2.keys)\u000a        trials.addData('key_resp_2.corr', key_resp_2.corr)\u000a        if key_resp_2.keys != None:  # we had a response\u000a            trials.addData('key_resp_2.rt', key_resp_2.rt)\u000a        \u000a        #------Prepare to start Routine "Feedback"-------\u000a        t = 0\u000a        FeedbackClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        if len(key_resp_2.keys)<1:\u000a            msg="Please press the RIGHT INDEX Finger button"\u000a            trials.finished = Falses\u000a        elif key_resp_2.corr:#stored on last run routine\u000a            msg="Correct! That button indicates a YES response." \u000a            trials.finished = True\u000a        else:\u000a            msg="Oops! Wrong button, please try again."\u000a            trials.finished = False\u000a        text_25.setText(msg)\u000a        # keep track of which components have finished\u000a        FeedbackComponents = []\u000a        FeedbackComponents.append(text_25)\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = FeedbackClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_25* updates\u000a            if t >= 0.0 and text_25.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_25.tStart = t  # underestimates by a little under one frame\u000a                text_25.frameNStart = frameN  # exact frame index\u000a                text_25.setAutoDraw(True)\u000a            elif text_25.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_25.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in FeedbackComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a                sys.exit()\u000a                \u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback"-------\u000a        for thisComponent in FeedbackComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 10 repeats of 'trials'\u000a\u000a\u000a    # set up handler to look after randomisation of conditions etc\u000a    trials_2 = data.TrialHandler(nReps=10, method='random', \u000a        extraInfo=expInfo, originPath=None,\u000a        trialList=[None],\u000a        seed=None, name='trials_2')\u000a    thisExp.addLoop(trials_2)  # add the loop to the experiment\u000a    thisTrial_2 = trials_2.trialList[0]  # so we can initialise stimuli with some values\u000a    # abbreviate parameter names if possible (e.g. rgb=thisTrial_2.rgb)\u000a    if thisTrial_2 != None:\u000a        for paramName in thisTrial_2.keys():\u000a            exec(paramName + '= thisTrial_2.' + paramName)\u000a\u000a    for thisTrial_2 in trials_2:\u000a        currentLoop = trials_2\u000a        # abbreviate parameter names if possible (e.g. rgb = thisTrial_2.rgb)\u000a        if thisTrial_2 != None:\u000a            for paramName in thisTrial_2.keys():\u000a                exec(paramName + '= thisTrial_2.' + paramName)\u000a        \u000a        #------Prepare to start Routine "ButtonPractice_MIDDLE"-------\u000a        t = 0\u000a        ButtonPractice_MIDDLEClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(20.000000)\u000a        # update component parameters for each repeat\u000a        UpperText_15.setText('')\u000a        UpperBrackets_15.setText('')\u000a        LowerText_15.setText('')\u000a        key_resp_3 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a        key_resp_3.status = NOT_STARTED\u000a        # keep track of which components have finished\u000a        ButtonPractice_MIDDLEComponents = []\u000a        ButtonPractice_MIDDLEComponents.append(text_29)\u000a        ButtonPractice_MIDDLEComponents.append(ISI_15)\u000a        ButtonPractice_MIDDLEComponents.append(TopUpperLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(UpperText_15)\u000a        ButtonPractice_MIDDLEComponents.append(UpperBrackets_15)\u000a        ButtonPractice_MIDDLEComponents.append(BotUpperLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(TopLowerLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(LowerText_15)\u000a        ButtonPractice_MIDDLEComponents.append(LowerBrackets_15)\u000a        ButtonPractice_MIDDLEComponents.append(BotLowerLine_15)\u000a        ButtonPractice_MIDDLEComponents.append(TrialCrossHair_15)\u000a        ButtonPractice_MIDDLEComponents.append(RestCrossHair_15)\u000a        ButtonPractice_MIDDLEComponents.append(key_resp_3)\u000a        for thisComponent in ButtonPractice_MIDDLEComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "ButtonPractice_MIDDLE"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = ButtonPractice_MIDDLEClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            # *text_29* updates\u000a            if t >= 0 and text_29.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_29.tStart = t  # underestimates by a little under one frame\u000a                text_29.frameNStart = frameN  # exact frame index\u000a                text_29.setAutoDraw(True)\u000a            elif text_29.status == STARTED and t >= (0 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_29.setAutoDraw(False)\u000a            \u000a            # *TopUpperLine_15* updates\u000a            if t >= 0 and TopUpperLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopUpperLine_15.tStart = t  # underestimates by a little under one frame\u000a                TopUpperLine_15.frameNStart = frameN  # exact frame index\u000a                TopUpperLine_15.setAutoDraw(True)\u000a            elif TopUpperLine_15.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopUpperLine_15.setAutoDraw(False)\u000a            \u000a            # *UpperText_15* updates\u000a            if t >= 0 and UpperText_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperText_15.tStart = t  # underestimates by a little under one frame\u000a                UpperText_15.frameNStart = frameN  # exact frame index\u000a                UpperText_15.setAutoDraw(True)\u000a            elif UpperText_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperText_15.setAutoDraw(False)\u000a            \u000a            # *UpperBrackets_15* updates\u000a            if t >= 0 and UpperBrackets_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                UpperBrackets_15.tStart = t  # underestimates by a little under one frame\u000a                UpperBrackets_15.frameNStart = frameN  # exact frame index\u000a                UpperBrackets_15.setAutoDraw(True)\u000a            elif UpperBrackets_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                UpperBrackets_15.setAutoDraw(False)\u000a            \u000a            # *BotUpperLine_15* updates\u000a            if t >= 0.0 and BotUpperLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotUpperLine_15.tStart = t  # underestimates by a little under one frame\u000a                BotUpperLine_15.frameNStart = frameN  # exact frame index\u000a                BotUpperLine_15.setAutoDraw(True)\u000a            elif BotUpperLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotUpperLine_15.setAutoDraw(False)\u000a            \u000a            # *TopLowerLine_15* updates\u000a            if t >= 0.0 and TopLowerLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TopLowerLine_15.tStart = t  # underestimates by a little under one frame\u000a                TopLowerLine_15.frameNStart = frameN  # exact frame index\u000a                TopLowerLine_15.setAutoDraw(True)\u000a            elif TopLowerLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TopLowerLine_15.setAutoDraw(False)\u000a            \u000a            # *LowerText_15* updates\u000a            if t >= 0 and LowerText_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerText_15.tStart = t  # underestimates by a little under one frame\u000a                LowerText_15.frameNStart = frameN  # exact frame index\u000a                LowerText_15.setAutoDraw(True)\u000a            elif LowerText_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerText_15.setAutoDraw(False)\u000a            \u000a            # *LowerBrackets_15* updates\u000a            if t >= 0 and LowerBrackets_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                LowerBrackets_15.tStart = t  # underestimates by a little under one frame\u000a                LowerBrackets_15.frameNStart = frameN  # exact frame index\u000a                LowerBrackets_15.setAutoDraw(True)\u000a            elif LowerBrackets_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                LowerBrackets_15.setAutoDraw(False)\u000a            \u000a            # *BotLowerLine_15* updates\u000a            if t >= 0.0 and BotLowerLine_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                BotLowerLine_15.tStart = t  # underestimates by a little under one frame\u000a                BotLowerLine_15.frameNStart = frameN  # exact frame index\u000a                BotLowerLine_15.setAutoDraw(True)\u000a            elif BotLowerLine_15.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                BotLowerLine_15.setAutoDraw(False)\u000a            \u000a            # *TrialCrossHair_15* updates\u000a            if t >= 0 and TrialCrossHair_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                TrialCrossHair_15.tStart = t  # underestimates by a little under one frame\u000a                TrialCrossHair_15.frameNStart = frameN  # exact frame index\u000a                TrialCrossHair_15.setAutoDraw(True)\u000a            elif TrialCrossHair_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                TrialCrossHair_15.setAutoDraw(False)\u000a            \u000a            # *RestCrossHair_15* updates\u000a            if t >= 0 and RestCrossHair_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                RestCrossHair_15.tStart = t  # underestimates by a little under one frame\u000a                RestCrossHair_15.frameNStart = frameN  # exact frame index\u000a                RestCrossHair_15.setAutoDraw(True)\u000a            elif RestCrossHair_15.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                RestCrossHair_15.setAutoDraw(False)\u000a            \u000a            # *key_resp_3* updates\u000a            if t >= 0.0 and key_resp_3.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                key_resp_3.tStart = t  # underestimates by a little under one frame\u000a                key_resp_3.frameNStart = frameN  # exact frame index\u000a                key_resp_3.status = STARTED\u000a                # keyboard checking is just starting\u000a                key_resp_3.clock.reset()  # now t=0\u000a                event.clearEvents(eventType='keyboard')\u000a            elif key_resp_3.status == STARTED and t >= (0.0 + (10-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                key_resp_3.status = STOPPED\u000a            if key_resp_3.status == STARTED:\u000a                theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8', '9','down','right'])\u000a                \u000a                # check for quit:\u000a                if "escape" in theseKeys:\u000a                    endExpNow = True\u000a                if len(theseKeys) > 0:  # at least one key was pressed\u000a                    key_resp_3.keys = theseKeys[-1]  # just the last key pressed\u000a                    key_resp_3.rt = key_resp_3.clock.getTime()\u000a                    # was this 'correct'?\u000a                    if (key_resp_3.keys == str('7')) or (key_resp_3.keys == 'right'):\u000a                        key_resp_3.corr = 1\u000a                    else:\u000a                        key_resp_3.corr = 0\u000a                    # a response ends the routine\u000a                    continueRoutine = False\u000a            # *ISI_15* period\u000a            if t >= 0.0 and ISI_15.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                ISI_15.tStart = t  # underestimates by a little under one frame\u000a                ISI_15.frameNStart = frameN  # exact frame index\u000a                ISI_15.start(1)\u000a            elif ISI_15.status == STARTED: #one frame should pass before updating params and completing\u000a                ISI_15.complete() #finish the static period\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in ButtonPractice_MIDDLEComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "ButtonPractice_MIDDLE"-------\u000a        for thisComponent in ButtonPractice_MIDDLEComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        # check responses\u000a        if key_resp_3.keys in ['', [], None]:  # No response was made\u000a           key_resp_3.keys=None\u000a           # was no response the correct answer?!\u000a           if str('7').lower() == 'none': key_resp_3.corr = 1  # correct non-response\u000a           else: key_resp_3.corr = 0  # failed to respond (incorrectly)\u000a        # store data for trials_2 (TrialHandler)\u000a        trials_2.addData('key_resp_3.keys',key_resp_3.keys)\u000a        trials_2.addData('key_resp_3.corr', key_resp_3.corr)\u000a        if key_resp_3.keys != None:  # we had a response\u000a            trials_2.addData('key_resp_3.rt', key_resp_3.rt)\u000a        \u000a        #------Prepare to start Routine "Feedback_MIDDLE"-------\u000a        t = 0\u000a        Feedback_MIDDLEClock.reset()  # clock \u000a        frameN = -1\u000a        routineTimer.add(2.000000)\u000a        # update component parameters for each repeat\u000a        if len(key_resp_3.keys)<1:\u000a            msg="Please press the RIGHT MIDDLE Finger button"\u000a            trials_2.finished = Falses\u000a        elif key_resp_3.corr:#stored on last run routine\u000a            msg="Good! That button indicates a NO response." \u000a            trials_2.finished = True\u000a        else:\u000a            msg="Oops! Wrong button, please try again."\u000a            trials_2.finished = False\u000a        text_26.setText(msg)\u000a        # keep track of which components have finished\u000a        Feedback_MIDDLEComponents = []\u000a        Feedback_MIDDLEComponents.append(text_26)\u000a        for thisComponent in Feedback_MIDDLEComponents:\u000a            if hasattr(thisComponent, 'status'):\u000a                thisComponent.status = NOT_STARTED\u000a        \u000a        #-------Start Routine "Feedback_MIDDLE"-------\u000a        continueRoutine = True\u000a        while continueRoutine and routineTimer.getTime() > 0:\u000a            # get current time\u000a            t = Feedback_MIDDLEClock.getTime()\u000a            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a            # update/draw components on each frame\u000a            \u000a            \u000a            # *text_26* updates\u000a            if t >= 0.0 and text_26.status == NOT_STARTED:\u000a                # keep track of start time/frame for later\u000a                text_26.tStart = t  # underestimates by a little under one frame\u000a                text_26.frameNStart = frameN  # exact frame index\u000a                text_26.setAutoDraw(True)\u000a            elif text_26.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a                text_26.setAutoDraw(False)\u000a            \u000a            # check if all components have finished\u000a            if not continueRoutine:  # a component has requested a forced-end of Routine\u000a                routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a                break\u000a            continueRoutine = False  # will revert to True if at least one component still running\u000a            for thisComponent in Feedback_MIDDLEComponents:\u000a                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                    continueRoutine = True\u000a                    break  # at least one component has not yet finished\u000a            \u000a            # check for quit (the Esc key)\u000a            if endExpNow or event.getKeys(keyList=["escape"]):\u000a                win.close()\u000a            \u000a            # refresh the screen\u000a            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a                win.flip()\u000a        \u000a        #-------Ending Routine "Feedback_MIDDLE"-------\u000a        for thisComponent in Feedback_MIDDLEComponents:\u000a            if hasattr(thisComponent, "setAutoDraw"):\u000a                thisComponent.setAutoDraw(False)\u000a        \u000a        thisExp.nextEntry()\u000a        \u000a    # completed 10 repeats of 'trials_2'\u000a\u000a\u000a    #------Prepare to start Routine "var_6Letters_2"-------\u000a    t = 0\u000a    var_6Letters_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(20.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_13.setText('')\u000a    UpperBrackets_13.setText('')\u000a    LowerText_13.setText('')\u000a    # keep track of which components have finished\u000a    var_6Letters_2Components = []\u000a    var_6Letters_2Components.append(text_13)\u000a    var_6Letters_2Components.append(text_16)\u000a    var_6Letters_2Components.append(text_18)\u000a    var_6Letters_2Components.append(text_21)\u000a    var_6Letters_2Components.append(ISI_13)\u000a    var_6Letters_2Components.append(TopUpperLine_13)\u000a    var_6Letters_2Components.append(UpperText_13)\u000a    var_6Letters_2Components.append(UpperBrackets_13)\u000a    var_6Letters_2Components.append(BotUpperLine_13)\u000a    var_6Letters_2Components.append(TopLowerLine_13)\u000a    var_6Letters_2Components.append(LowerText_13)\u000a    var_6Letters_2Components.append(LowerBrackets_13)\u000a    var_6Letters_2Components.append(BotLowerLine_13)\u000a    var_6Letters_2Components.append(TrialCrossHair_13)\u000a    var_6Letters_2Components.append(RestCrossHair_13)\u000a    var_6Letters_2Components.append(text_22)\u000a    var_6Letters_2Components.append(text_23)\u000a    var_6Letters_2Components.append(text_24)\u000a    for thisComponent in var_6Letters_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_13* updates\u000a        if t >= 0.0 and text_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_13.tStart = t  # underestimates by a little under one frame\u000a            text_13.frameNStart = frameN  # exact frame index\u000a            text_13.setAutoDraw(True)\u000a        elif text_13.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_13.setAutoDraw(False)\u000a        \u000a        # *text_16* updates\u000a        if t >= 3 and text_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_16.tStart = t  # underestimates by a little under one frame\u000a            text_16.frameNStart = frameN  # exact frame index\u000a            text_16.setAutoDraw(True)\u000a        elif text_16.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_16.setAutoDraw(False)\u000a        \u000a        # *text_18* updates\u000a        if t >= 6 and text_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_18.tStart = t  # underestimates by a little under one frame\u000a            text_18.frameNStart = frameN  # exact frame index\u000a            text_18.setAutoDraw(True)\u000a        elif text_18.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_18.setAutoDraw(False)\u000a        \u000a        # *text_21* updates\u000a        if t >= 0 and text_21.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_21.tStart = t  # underestimates by a little under one frame\u000a            text_21.frameNStart = frameN  # exact frame index\u000a            text_21.setAutoDraw(True)\u000a        elif text_21.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_21.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_13* updates\u000a        if t >= 0 and TopUpperLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_13.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_13.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_13.setAutoDraw(True)\u000a        elif TopUpperLine_13.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_13.setAutoDraw(False)\u000a        \u000a        # *UpperText_13* updates\u000a        if t >= 0 and UpperText_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_13.tStart = t  # underestimates by a little under one frame\u000a            UpperText_13.frameNStart = frameN  # exact frame index\u000a            UpperText_13.setAutoDraw(True)\u000a        elif UpperText_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_13.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_13* updates\u000a        if t >= 0 and UpperBrackets_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_13.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_13.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_13.setAutoDraw(True)\u000a        elif UpperBrackets_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_13.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_13* updates\u000a        if t >= 0.0 and BotUpperLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_13.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_13.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_13.setAutoDraw(True)\u000a        elif BotUpperLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_13.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_13* updates\u000a        if t >= 0.0 and TopLowerLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_13.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_13.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_13.setAutoDraw(True)\u000a        elif TopLowerLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_13.setAutoDraw(False)\u000a        \u000a        # *LowerText_13* updates\u000a        if t >= 0 and LowerText_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_13.tStart = t  # underestimates by a little under one frame\u000a            LowerText_13.frameNStart = frameN  # exact frame index\u000a            LowerText_13.setAutoDraw(True)\u000a        elif LowerText_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_13.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_13* updates\u000a        if t >= 0 and LowerBrackets_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_13.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_13.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_13.setAutoDraw(True)\u000a        elif LowerBrackets_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_13.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_13* updates\u000a        if t >= 0.0 and BotLowerLine_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_13.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_13.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_13.setAutoDraw(True)\u000a        elif BotLowerLine_13.status == STARTED and t >= (0.0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_13.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_13* updates\u000a        if t >= 12 and TrialCrossHair_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_13.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_13.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_13.setAutoDraw(True)\u000a        elif TrialCrossHair_13.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_13.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_13* updates\u000a        if t >= 15 and RestCrossHair_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_13.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_13.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_13.setAutoDraw(True)\u000a        elif RestCrossHair_13.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_13.setAutoDraw(False)\u000a        \u000a        # *text_22* updates\u000a        if t >= 9 and text_22.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_22.tStart = t  # underestimates by a little under one frame\u000a            text_22.frameNStart = frameN  # exact frame index\u000a            text_22.setAutoDraw(True)\u000a        elif text_22.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_22.setAutoDraw(False)\u000a        \u000a        # *text_23* updates\u000a        if t >= 12 and text_23.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_23.tStart = t  # underestimates by a little under one frame\u000a            text_23.frameNStart = frameN  # exact frame index\u000a            text_23.setAutoDraw(True)\u000a        elif text_23.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_23.setAutoDraw(False)\u000a        \u000a        # *text_24* updates\u000a        if t >= 15 and text_24.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_24.tStart = t  # underestimates by a little under one frame\u000a            text_24.frameNStart = frameN  # exact frame index\u000a            text_24.setAutoDraw(True)\u000a        elif text_24.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_24.setAutoDraw(False)\u000a        # *ISI_13* period\u000a        if t >= 0.0 and ISI_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_13.tStart = t  # underestimates by a little under one frame\u000a            ISI_13.frameNStart = frameN  # exact frame index\u000a            ISI_13.start(1)\u000a        elif ISI_13.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_13.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_2"-------\u000a    for thisComponent in var_6Letters_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "var_6Letters_0"-------\u000a    t = 0\u000a    var_6Letters_0Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(30.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_11.setText(' A B C D E F ')\u000a    UpperBrackets_11.setText('  {   }      ')\u000a    LowerText_11.setText(' a b c d e f ')\u000a    KeyboardResp_11 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_11.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    var_6Letters_0Components = []\u000a    var_6Letters_0Components.append(text_2)\u000a    var_6Letters_0Components.append(text)\u000a    var_6Letters_0Components.append(text_6)\u000a    var_6Letters_0Components.append(text_4)\u000a    var_6Letters_0Components.append(ISI_11)\u000a    var_6Letters_0Components.append(TopUpperLine_11)\u000a    var_6Letters_0Components.append(UpperText_11)\u000a    var_6Letters_0Components.append(UpperBrackets_11)\u000a    var_6Letters_0Components.append(BotUpperLine_11)\u000a    var_6Letters_0Components.append(TopLowerLine_11)\u000a    var_6Letters_0Components.append(LowerText_11)\u000a    var_6Letters_0Components.append(LowerBrackets_11)\u000a    var_6Letters_0Components.append(BotLowerLine_11)\u000a    var_6Letters_0Components.append(TrialCrossHair_11)\u000a    var_6Letters_0Components.append(RestCrossHair_11)\u000a    var_6Letters_0Components.append(KeyboardResp_11)\u000a    var_6Letters_0Components.append(text_5)\u000a    var_6Letters_0Components.append(text_7)\u000a    var_6Letters_0Components.append(text_8)\u000a    var_6Letters_0Components.append(text_9)\u000a    var_6Letters_0Components.append(text_10)\u000a    for thisComponent in var_6Letters_0Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_0"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_0Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_2* updates\u000a        if t >= 0.0 and text_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_2.tStart = t  # underestimates by a little under one frame\u000a            text_2.frameNStart = frameN  # exact frame index\u000a            text_2.setAutoDraw(True)\u000a        elif text_2.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_2.setAutoDraw(False)\u000a        \u000a        # *text* updates\u000a        if t >= 3 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        elif text.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # *text_6* updates\u000a        if t >= 6 and text_6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_6.tStart = t  # underestimates by a little under one frame\u000a            text_6.frameNStart = frameN  # exact frame index\u000a            text_6.setAutoDraw(True)\u000a        elif text_6.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_6.setAutoDraw(False)\u000a        \u000a        # *text_4* updates\u000a        if t >= 9 and text_4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_4.tStart = t  # underestimates by a little under one frame\u000a            text_4.frameNStart = frameN  # exact frame index\u000a            text_4.setAutoDraw(True)\u000a        elif text_4.status == STARTED and t >= (9 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_4.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_11* updates\u000a        if t >= 0 and TopUpperLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_11.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_11.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_11.setAutoDraw(True)\u000a        elif TopUpperLine_11.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_11.setAutoDraw(False)\u000a        \u000a        # *UpperText_11* updates\u000a        if t >= 0 and UpperText_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_11.tStart = t  # underestimates by a little under one frame\u000a            UpperText_11.frameNStart = frameN  # exact frame index\u000a            UpperText_11.setAutoDraw(True)\u000a        elif UpperText_11.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_11.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_11* updates\u000a        if t >= 3 and UpperBrackets_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_11.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_11.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_11.setAutoDraw(True)\u000a        elif UpperBrackets_11.status == STARTED and t >= (3 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_11.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_11* updates\u000a        if t >= 0.0 and BotUpperLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_11.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_11.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_11.setAutoDraw(True)\u000a        elif BotUpperLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_11.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_11* updates\u000a        if t >= 0.0 and TopLowerLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_11.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_11.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_11.setAutoDraw(True)\u000a        elif TopLowerLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_11.setAutoDraw(False)\u000a        \u000a        # *LowerText_11* updates\u000a        if t >= 14 and LowerText_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_11.tStart = t  # underestimates by a little under one frame\u000a            LowerText_11.frameNStart = frameN  # exact frame index\u000a            LowerText_11.setAutoDraw(True)\u000a        elif LowerText_11.status == STARTED and t >= (14 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_11.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_11* updates\u000a        if t >= 17 and LowerBrackets_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_11.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_11.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_11.setAutoDraw(True)\u000a        elif LowerBrackets_11.status == STARTED and t >= (17 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_11.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_11* updates\u000a        if t >= 0.0 and BotLowerLine_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_11.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_11.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_11.setAutoDraw(True)\u000a        elif BotLowerLine_11.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_11.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_11* updates\u000a        if t >= 0 and TrialCrossHair_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_11.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_11.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_11.setAutoDraw(True)\u000a        elif TrialCrossHair_11.status == STARTED and t >= (0 + (26-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_11.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_11* updates\u000a        if t >= 26 and RestCrossHair_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_11.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_11.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_11.setAutoDraw(True)\u000a        elif RestCrossHair_11.status == STARTED and t >= (26 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_11.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_11* updates\u000a        if t >= 0 and KeyboardResp_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_11.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_11.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_11.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_11.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_11.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_11.status = STOPPED\u000a        if KeyboardResp_11.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_11.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_11.rt.append(KeyboardResp_11.clock.getTime())\u000a        \u000a        # *text_5* updates\u000a        if t >= 14 and text_5.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_5.tStart = t  # underestimates by a little under one frame\u000a            text_5.frameNStart = frameN  # exact frame index\u000a            text_5.setAutoDraw(True)\u000a        elif text_5.status == STARTED and t >= (14 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_5.setAutoDraw(False)\u000a        \u000a        # *text_7* updates\u000a        if t >= 17 and text_7.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_7.tStart = t  # underestimates by a little under one frame\u000a            text_7.frameNStart = frameN  # exact frame index\u000a            text_7.setAutoDraw(True)\u000a        elif text_7.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_7.setAutoDraw(False)\u000a        \u000a        # *text_8* updates\u000a        if t >= 20 and text_8.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_8.tStart = t  # underestimates by a little under one frame\u000a            text_8.frameNStart = frameN  # exact frame index\u000a            text_8.setAutoDraw(True)\u000a        elif text_8.status == STARTED and t >= (20 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_8.setAutoDraw(False)\u000a        \u000a        # *text_9* updates\u000a        if t >= 23 and text_9.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_9.tStart = t  # underestimates by a little under one frame\u000a            text_9.frameNStart = frameN  # exact frame index\u000a            text_9.setAutoDraw(True)\u000a        elif text_9.status == STARTED and t >= (23 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_9.setAutoDraw(False)\u000a        \u000a        # *text_10* updates\u000a        if t >= 26 and text_10.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_10.tStart = t  # underestimates by a little under one frame\u000a            text_10.frameNStart = frameN  # exact frame index\u000a            text_10.setAutoDraw(True)\u000a        elif text_10.status == STARTED and t >= (26 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_10.setAutoDraw(False)\u000a        # *ISI_11* period\u000a        if t >= 0.0 and ISI_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_11.tStart = t  # underestimates by a little under one frame\u000a            ISI_11.frameNStart = frameN  # exact frame index\u000a            ISI_11.start(1)\u000a        elif ISI_11.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_11.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_0Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_0"-------\u000a    for thisComponent in var_6Letters_0Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_11.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_11.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_11.keys',KeyboardResp_11.keys)\u000a    if KeyboardResp_11.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_11.rt', KeyboardResp_11.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "var_6Letters_1"-------\u000a    t = 0\u000a    var_6Letters_1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(22.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_12.setText(' A B C D E F ')\u000a    UpperBrackets_12.setText('  {   }      ')\u000a    LowerText_12.setText(u' a b c d e f ')\u000a    KeyboardResp_12 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_12.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    var_6Letters_1Components = []\u000a    var_6Letters_1Components.append(text_11)\u000a    var_6Letters_1Components.append(text_12)\u000a    var_6Letters_1Components.append(text_14)\u000a    var_6Letters_1Components.append(ISI_12)\u000a    var_6Letters_1Components.append(TopUpperLine_12)\u000a    var_6Letters_1Components.append(UpperText_12)\u000a    var_6Letters_1Components.append(UpperBrackets_12)\u000a    var_6Letters_1Components.append(BotUpperLine_12)\u000a    var_6Letters_1Components.append(TopLowerLine_12)\u000a    var_6Letters_1Components.append(LowerText_12)\u000a    var_6Letters_1Components.append(LowerBrackets_12)\u000a    var_6Letters_1Components.append(BotLowerLine_12)\u000a    var_6Letters_1Components.append(TrialCrossHair_12)\u000a    var_6Letters_1Components.append(RestCrossHair_12)\u000a    var_6Letters_1Components.append(KeyboardResp_12)\u000a    var_6Letters_1Components.append(text_17)\u000a    var_6Letters_1Components.append(text_19)\u000a    var_6Letters_1Components.append(text_20)\u000a    for thisComponent in var_6Letters_1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "var_6Letters_1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = var_6Letters_1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_11* updates\u000a        if t >= 0.0 and text_11.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_11.tStart = t  # underestimates by a little under one frame\u000a            text_11.frameNStart = frameN  # exact frame index\u000a            text_11.setAutoDraw(True)\u000a        elif text_11.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_11.setAutoDraw(False)\u000a        \u000a        # *text_12* updates\u000a        if t >= 3 and text_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_12.tStart = t  # underestimates by a little under one frame\u000a            text_12.frameNStart = frameN  # exact frame index\u000a            text_12.setAutoDraw(True)\u000a        elif text_12.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_12.setAutoDraw(False)\u000a        \u000a        # *text_14* updates\u000a        if t >= 6 and text_14.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_14.tStart = t  # underestimates by a little under one frame\u000a            text_14.frameNStart = frameN  # exact frame index\u000a            text_14.setAutoDraw(True)\u000a        elif text_14.status == STARTED and t >= (6 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_14.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_12* updates\u000a        if t >= 0 and TopUpperLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_12.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_12.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_12.setAutoDraw(True)\u000a        elif TopUpperLine_12.status == STARTED and t >= (0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_12.setAutoDraw(False)\u000a        \u000a        # *UpperText_12* updates\u000a        if t >= 0 and UpperText_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_12.tStart = t  # underestimates by a little under one frame\u000a            UpperText_12.frameNStart = frameN  # exact frame index\u000a            UpperText_12.setAutoDraw(True)\u000a        elif UpperText_12.status == STARTED and t >= (0 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_12.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_12* updates\u000a        if t >= 3 and UpperBrackets_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_12.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_12.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_12.setAutoDraw(True)\u000a        elif UpperBrackets_12.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_12.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_12* updates\u000a        if t >= 0.0 and BotUpperLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_12.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_12.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_12.setAutoDraw(True)\u000a        elif BotUpperLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_12.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_12* updates\u000a        if t >= 0.0 and TopLowerLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_12.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_12.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_12.setAutoDraw(True)\u000a        elif TopLowerLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_12.setAutoDraw(False)\u000a        \u000a        # *LowerText_12* updates\u000a        if t >= 11 and LowerText_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_12.tStart = t  # underestimates by a little under one frame\u000a            LowerText_12.frameNStart = frameN  # exact frame index\u000a            LowerText_12.setAutoDraw(True)\u000a        elif LowerText_12.status == STARTED and t >= (11 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_12.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_12* updates\u000a        if t >= 11 and LowerBrackets_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_12.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_12.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_12.setAutoDraw(True)\u000a        elif LowerBrackets_12.status == STARTED and t >= (11 + (6-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_12.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_12* updates\u000a        if t >= 0.0 and BotLowerLine_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_12.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_12.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_12.setAutoDraw(True)\u000a        elif BotLowerLine_12.status == STARTED and t >= (0.0 + (22-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_12.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_12* updates\u000a        if t >= 0 and TrialCrossHair_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_12.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_12.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_12.setAutoDraw(True)\u000a        elif TrialCrossHair_12.status == STARTED and t >= (0 + (20-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_12.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_12* updates\u000a        if t >= 17 and RestCrossHair_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_12.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_12.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_12.setAutoDraw(True)\u000a        elif RestCrossHair_12.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_12.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_12* updates\u000a        if t >= 0 and KeyboardResp_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_12.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_12.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_12.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_12.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_12.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_12.status = STOPPED\u000a        if KeyboardResp_12.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8','down','right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_12.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_12.rt.append(KeyboardResp_12.clock.getTime())\u000a        \u000a        # *text_17* updates\u000a        if t >= 11 and text_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_17.tStart = t  # underestimates by a little under one frame\u000a            text_17.frameNStart = frameN  # exact frame index\u000a            text_17.setAutoDraw(True)\u000a        elif text_17.status == STARTED and t >= (11 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_17.setAutoDraw(False)\u000a        \u000a        # *text_19* updates\u000a        if t >= 14 and text_19.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_19.tStart = t  # underestimates by a little under one frame\u000a            text_19.frameNStart = frameN  # exact frame index\u000a            text_19.setAutoDraw(True)\u000a        elif text_19.status == STARTED and t >= (14 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_19.setAutoDraw(False)\u000a        \u000a        # *text_20* updates\u000a        if t >= 17 and text_20.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_20.tStart = t  # underestimates by a little under one frame\u000a            text_20.frameNStart = frameN  # exact frame index\u000a            text_20.setAutoDraw(True)\u000a        elif text_20.status == STARTED and t >= (17 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_20.setAutoDraw(False)\u000a        # *ISI_12* period\u000a        if t >= 0.0 and ISI_12.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_12.tStart = t  # underestimates by a little under one frame\u000a            ISI_12.frameNStart = frameN  # exact frame index\u000a            ISI_12.start(1)\u000a        elif ISI_12.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_12.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in var_6Letters_1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "var_6Letters_1"-------\u000a    for thisComponent in var_6Letters_1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_12.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_12.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_12.keys',KeyboardResp_12.keys)\u000a    if KeyboardResp_12.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_12.rt', KeyboardResp_12.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "DemoTrialRealTimes"-------\u000a    t = 0\u000a    DemoTrialRealTimesClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(17.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_18.setText(u' A B C D E F ')\u000a    UpperBrackets_18.setText(u'  {   }      ')\u000a    LowerText_17.setText(u' a b c d e f ')\u000a    KeyboardResp_13 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    KeyboardResp_13.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    DemoTrialRealTimesComponents = []\u000a    DemoTrialRealTimesComponents.append(text_44)\u000a    DemoTrialRealTimesComponents.append(text_45)\u000a    DemoTrialRealTimesComponents.append(text_46)\u000a    DemoTrialRealTimesComponents.append(ISI_18)\u000a    DemoTrialRealTimesComponents.append(TopUpperLine_18)\u000a    DemoTrialRealTimesComponents.append(UpperText_18)\u000a    DemoTrialRealTimesComponents.append(UpperBrackets_18)\u000a    DemoTrialRealTimesComponents.append(BotUpperLine_18)\u000a    DemoTrialRealTimesComponents.append(TopLowerLine_18)\u000a    DemoTrialRealTimesComponents.append(LowerText_17)\u000a    DemoTrialRealTimesComponents.append(LowerBrackets_17)\u000a    DemoTrialRealTimesComponents.append(BotLowerLine_18)\u000a    DemoTrialRealTimesComponents.append(TrialCrossHair_18)\u000a    DemoTrialRealTimesComponents.append(RestCrossHair_18)\u000a    DemoTrialRealTimesComponents.append(KeyboardResp_13)\u000a    DemoTrialRealTimesComponents.append(text_48)\u000a    DemoTrialRealTimesComponents.append(text_49)\u000a    for thisComponent in DemoTrialRealTimesComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "DemoTrialRealTimes"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = DemoTrialRealTimesClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_44* updates\u000a        if t >= 0.0 and text_44.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_44.tStart = t  # underestimates by a little under one frame\u000a            text_44.frameNStart = frameN  # exact frame index\u000a            text_44.setAutoDraw(True)\u000a        elif text_44.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_44.setAutoDraw(False)\u000a        \u000a        # *text_45* updates\u000a        if t >= 3 and text_45.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_45.tStart = t  # underestimates by a little under one frame\u000a            text_45.frameNStart = frameN  # exact frame index\u000a            text_45.setAutoDraw(True)\u000a        elif text_45.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_45.setAutoDraw(False)\u000a        \u000a        # *text_46* updates\u000a        if t >= 5 and text_46.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_46.tStart = t  # underestimates by a little under one frame\u000a            text_46.frameNStart = frameN  # exact frame index\u000a            text_46.setAutoDraw(True)\u000a        elif text_46.status == STARTED and t >= (5 + (5-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_46.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_18* updates\u000a        if t >= 0 and TopUpperLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_18.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_18.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_18.setAutoDraw(True)\u000a        elif TopUpperLine_18.status == STARTED and t >= (0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_18.setAutoDraw(False)\u000a        \u000a        # *UpperText_18* updates\u000a        if t >= 3 and UpperText_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_18.tStart = t  # underestimates by a little under one frame\u000a            UpperText_18.frameNStart = frameN  # exact frame index\u000a            UpperText_18.setAutoDraw(True)\u000a        elif UpperText_18.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_18.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_18* updates\u000a        if t >= 3 and UpperBrackets_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_18.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_18.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_18.setAutoDraw(True)\u000a        elif UpperBrackets_18.status == STARTED and t >= (3 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_18.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_18* updates\u000a        if t >= 0.0 and BotUpperLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_18.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_18.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_18.setAutoDraw(True)\u000a        elif BotUpperLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_18.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_18* updates\u000a        if t >= 0.0 and TopLowerLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_18.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_18.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_18.setAutoDraw(True)\u000a        elif TopLowerLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_18.setAutoDraw(False)\u000a        \u000a        # *LowerText_17* updates\u000a        if t >= 10 and LowerText_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_17.tStart = t  # underestimates by a little under one frame\u000a            LowerText_17.frameNStart = frameN  # exact frame index\u000a            LowerText_17.setAutoDraw(True)\u000a        elif LowerText_17.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_17.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_17* updates\u000a        if t >= 10 and LowerBrackets_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_17.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_17.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_17.setAutoDraw(True)\u000a        elif LowerBrackets_17.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_17.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_18* updates\u000a        if t >= 0.0 and BotLowerLine_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_18.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_18.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_18.setAutoDraw(True)\u000a        elif BotLowerLine_18.status == STARTED and t >= (0.0 + (17-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_18.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_18* updates\u000a        if t >= 0 and TrialCrossHair_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_18.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_18.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_18.setAutoDraw(True)\u000a        elif TrialCrossHair_18.status == STARTED and t >= (0 + (12-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_18.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_18* updates\u000a        if t >= 12 and RestCrossHair_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_18.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_18.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_18.setAutoDraw(True)\u000a        elif RestCrossHair_18.status == STARTED and t >= (12 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_18.setAutoDraw(False)\u000a        \u000a        # *KeyboardResp_13* updates\u000a        if t >= 0 and KeyboardResp_13.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            KeyboardResp_13.tStart = t  # underestimates by a little under one frame\u000a            KeyboardResp_13.frameNStart = frameN  # exact frame index\u000a            KeyboardResp_13.status = STARTED\u000a            # keyboard checking is just starting\u000a            KeyboardResp_13.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif KeyboardResp_13.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            KeyboardResp_13.status = STOPPED\u000a        if KeyboardResp_13.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                KeyboardResp_13.keys.extend(theseKeys)  # storing all keys\u000a                KeyboardResp_13.rt.append(KeyboardResp_13.clock.getTime())\u000a        \u000a        # *text_48* updates\u000a        if t >= 10 and text_48.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_48.tStart = t  # underestimates by a little under one frame\u000a            text_48.frameNStart = frameN  # exact frame index\u000a            text_48.setAutoDraw(True)\u000a        elif text_48.status == STARTED and t >= (10 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_48.setAutoDraw(False)\u000a        \u000a        # *text_49* updates\u000a        if t >= 12 and text_49.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_49.tStart = t  # underestimates by a little under one frame\u000a            text_49.frameNStart = frameN  # exact frame index\u000a            text_49.setAutoDraw(True)\u000a        elif text_49.status == STARTED and t >= (12 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_49.setAutoDraw(False)\u000a        # *ISI_18* period\u000a        if t >= 0.0 and ISI_18.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_18.tStart = t  # underestimates by a little under one frame\u000a            ISI_18.frameNStart = frameN  # exact frame index\u000a            ISI_18.start(1)\u000a        elif ISI_18.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_18.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in DemoTrialRealTimesComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "DemoTrialRealTimes"-------\u000a    for thisComponent in DemoTrialRealTimesComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if KeyboardResp_13.keys in ['', [], None]:  # No response was made\u000a       KeyboardResp_13.keys=None\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('KeyboardResp_13.keys',KeyboardResp_13.keys)\u000a    if KeyboardResp_13.keys != None:  # we had a response\u000a        thisExp.addData('KeyboardResp_13.rt', KeyboardResp_13.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "NumLettersToRem"-------\u000a    t = 0\u000a    NumLettersToRemClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(30.000000)\u000a    # update component parameters for each repeat\u000a    UpBrack1.setText('        { }  ')\u000a    UpperText_17.setText(' A B C D E F ')\u000a    UpperBrackets_17.setText('')\u000a    # keep track of which components have finished\u000a    NumLettersToRemComponents = []\u000a    NumLettersToRemComponents.append(text_15)\u000a    NumLettersToRemComponents.append(text_33)\u000a    NumLettersToRemComponents.append(text_34)\u000a    NumLettersToRemComponents.append(text_3)\u000a    NumLettersToRemComponents.append(text_35)\u000a    NumLettersToRemComponents.append(UpBrack1)\u000a    NumLettersToRemComponents.append(ISI_17)\u000a    NumLettersToRemComponents.append(TopUpperLine_17)\u000a    NumLettersToRemComponents.append(UpperText_17)\u000a    NumLettersToRemComponents.append(UpperBrackets_17)\u000a    NumLettersToRemComponents.append(BotUpperLine_17)\u000a    NumLettersToRemComponents.append(TopLowerLine_17)\u000a    NumLettersToRemComponents.append(BotLowerLine_17)\u000a    NumLettersToRemComponents.append(TrialCrossHair_17)\u000a    NumLettersToRemComponents.append(RestCrossHair_17)\u000a    NumLettersToRemComponents.append(UpBrack2)\u000a    NumLettersToRemComponents.append(UpBrack3)\u000a    NumLettersToRemComponents.append(UpBrack4)\u000a    NumLettersToRemComponents.append(UpBrack5)\u000a    NumLettersToRemComponents.append(UpBrack6)\u000a    NumLettersToRemComponents.append(text_38)\u000a    NumLettersToRemComponents.append(text_39)\u000a    NumLettersToRemComponents.append(text_40)\u000a    NumLettersToRemComponents.append(text_41)\u000a    NumLettersToRemComponents.append(text_42)\u000a    NumLettersToRemComponents.append(text_43)\u000a    for thisComponent in NumLettersToRemComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "NumLettersToRem"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = NumLettersToRemClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_15* updates\u000a        if t >= 0.0 and text_15.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_15.tStart = t  # underestimates by a little under one frame\u000a            text_15.frameNStart = frameN  # exact frame index\u000a            text_15.setAutoDraw(True)\u000a        elif text_15.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_15.setAutoDraw(False)\u000a        \u000a        # *text_33* updates\u000a        if t >= 3 and text_33.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_33.tStart = t  # underestimates by a little under one frame\u000a            text_33.frameNStart = frameN  # exact frame index\u000a            text_33.setAutoDraw(True)\u000a        elif text_33.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_33.setAutoDraw(False)\u000a        \u000a        # *text_34* updates\u000a        if t >= 6 and text_34.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_34.tStart = t  # underestimates by a little under one frame\u000a            text_34.frameNStart = frameN  # exact frame index\u000a            text_34.setAutoDraw(True)\u000a        elif text_34.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_34.setAutoDraw(False)\u000a        \u000a        # *text_3* updates\u000a        if t >= 9 and text_3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_3.tStart = t  # underestimates by a little under one frame\u000a            text_3.frameNStart = frameN  # exact frame index\u000a            text_3.setAutoDraw(True)\u000a        elif text_3.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_3.setAutoDraw(False)\u000a        \u000a        # *text_35* updates\u000a        if t >= 12 and text_35.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_35.tStart = t  # underestimates by a little under one frame\u000a            text_35.frameNStart = frameN  # exact frame index\u000a            text_35.setAutoDraw(True)\u000a        elif text_35.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_35.setAutoDraw(False)\u000a        \u000a        # *UpBrack1* updates\u000a        if t >= 15 and UpBrack1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack1.tStart = t  # underestimates by a little under one frame\u000a            UpBrack1.frameNStart = frameN  # exact frame index\u000a            UpBrack1.setAutoDraw(True)\u000a        elif UpBrack1.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack1.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_17* updates\u000a        if t >= 0 and TopUpperLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_17.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_17.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_17.setAutoDraw(True)\u000a        elif TopUpperLine_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_17.setAutoDraw(False)\u000a        \u000a        # *UpperText_17* updates\u000a        if t >= 0 and UpperText_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_17.tStart = t  # underestimates by a little under one frame\u000a            UpperText_17.frameNStart = frameN  # exact frame index\u000a            UpperText_17.setAutoDraw(True)\u000a        elif UpperText_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_17.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_17* updates\u000a        if t >= 0.0 and UpperBrackets_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_17.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_17.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_17.setAutoDraw(True)\u000a        elif UpperBrackets_17.status == STARTED and t >= (0.0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_17.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_17* updates\u000a        if t >= 0.0 and BotUpperLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_17.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_17.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_17.setAutoDraw(True)\u000a        elif BotUpperLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_17.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_17* updates\u000a        if t >= 0.0 and TopLowerLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_17.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_17.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_17.setAutoDraw(True)\u000a        elif TopLowerLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_17.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_17* updates\u000a        if t >= 0.0 and BotLowerLine_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_17.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_17.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_17.setAutoDraw(True)\u000a        elif BotLowerLine_17.status == STARTED and t >= (0.0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_17.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_17* updates\u000a        if t >= 0 and TrialCrossHair_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_17.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_17.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_17.setAutoDraw(True)\u000a        elif TrialCrossHair_17.status == STARTED and t >= (0 + (30-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_17.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_17* updates\u000a        if t >= 0.0 and RestCrossHair_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_17.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_17.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_17.setAutoDraw(True)\u000a        elif RestCrossHair_17.status == STARTED and t >= (0.0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_17.setAutoDraw(False)\u000a        \u000a        # *UpBrack2* updates\u000a        if t >= 18 and UpBrack2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack2.tStart = t  # underestimates by a little under one frame\u000a            UpBrack2.frameNStart = frameN  # exact frame index\u000a            UpBrack2.setAutoDraw(True)\u000a        elif UpBrack2.status == STARTED and t >= (18 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack2.setAutoDraw(False)\u000a        \u000a        # *UpBrack3* updates\u000a        if t >= 20 and UpBrack3.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack3.tStart = t  # underestimates by a little under one frame\u000a            UpBrack3.frameNStart = frameN  # exact frame index\u000a            UpBrack3.setAutoDraw(True)\u000a        elif UpBrack3.status == STARTED and t >= (20 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack3.setAutoDraw(False)\u000a        \u000a        # *UpBrack4* updates\u000a        if t >= 22 and UpBrack4.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack4.tStart = t  # underestimates by a little under one frame\u000a            UpBrack4.frameNStart = frameN  # exact frame index\u000a            UpBrack4.setAutoDraw(True)\u000a        elif UpBrack4.status == STARTED and t >= (22 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack4.setAutoDraw(False)\u000a        \u000a        # *UpBrack5* updates\u000a        if t >= 24 and UpBrack5.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack5.tStart = t  # underestimates by a little under one frame\u000a            UpBrack5.frameNStart = frameN  # exact frame index\u000a            UpBrack5.setAutoDraw(True)\u000a        elif UpBrack5.status == STARTED and t >= (24 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack5.setAutoDraw(False)\u000a        \u000a        # *UpBrack6* updates\u000a        if t >= 26 and UpBrack6.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpBrack6.tStart = t  # underestimates by a little under one frame\u000a            UpBrack6.frameNStart = frameN  # exact frame index\u000a            UpBrack6.setAutoDraw(True)\u000a        elif UpBrack6.status == STARTED and t >= (26 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpBrack6.setAutoDraw(False)\u000a        \u000a        # *text_38* updates\u000a        if t >= 15 and text_38.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_38.tStart = t  # underestimates by a little under one frame\u000a            text_38.frameNStart = frameN  # exact frame index\u000a            text_38.setAutoDraw(True)\u000a        elif text_38.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_38.setAutoDraw(False)\u000a        \u000a        # *text_39* updates\u000a        if t >= 18 and text_39.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_39.tStart = t  # underestimates by a little under one frame\u000a            text_39.frameNStart = frameN  # exact frame index\u000a            text_39.setAutoDraw(True)\u000a        elif text_39.status == STARTED and t >= (18 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_39.setAutoDraw(False)\u000a        \u000a        # *text_40* updates\u000a        if t >= 20 and text_40.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_40.tStart = t  # underestimates by a little under one frame\u000a            text_40.frameNStart = frameN  # exact frame index\u000a            text_40.setAutoDraw(True)\u000a        elif text_40.status == STARTED and t >= (20 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_40.setAutoDraw(False)\u000a        \u000a        # *text_41* updates\u000a        if t >= 22 and text_41.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_41.tStart = t  # underestimates by a little under one frame\u000a            text_41.frameNStart = frameN  # exact frame index\u000a            text_41.setAutoDraw(True)\u000a        elif text_41.status == STARTED and t >= (22 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_41.setAutoDraw(False)\u000a        \u000a        # *text_42* updates\u000a        if t >= 24 and text_42.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_42.tStart = t  # underestimates by a little under one frame\u000a            text_42.frameNStart = frameN  # exact frame index\u000a            text_42.setAutoDraw(True)\u000a        elif text_42.status == STARTED and t >= (24 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_42.setAutoDraw(False)\u000a        \u000a        # *text_43* updates\u000a        if t >= 26 and text_43.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_43.tStart = t  # underestimates by a little under one frame\u000a            text_43.frameNStart = frameN  # exact frame index\u000a            text_43.setAutoDraw(True)\u000a        elif text_43.status == STARTED and t >= (26 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_43.setAutoDraw(False)\u000a        # *ISI_17* period\u000a        if t >= 0.0 and ISI_17.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_17.tStart = t  # underestimates by a little under one frame\u000a            ISI_17.frameNStart = frameN  # exact frame index\u000a            ISI_17.start(1)\u000a        elif ISI_17.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_17.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in NumLettersToRemComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "NumLettersToRem"-------\u000a    for thisComponent in NumLettersToRemComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "TrialParts_1"-------\u000a    t = 0\u000a    TrialParts_1Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(25.000000)\u000a    # update component parameters for each repeat\u000a    UpperText_16.setText('')\u000a    UpperBrackets_16.setText('')\u000a    LowerText_16.setText('')\u000a    # keep track of which components have finished\u000a    TrialParts_1Components = []\u000a    TrialParts_1Components.append(text_27)\u000a    TrialParts_1Components.append(text_30)\u000a    TrialParts_1Components.append(text_31)\u000a    TrialParts_1Components.append(text_32)\u000a    TrialParts_1Components.append(ISI_16)\u000a    TrialParts_1Components.append(TopUpperLine_16)\u000a    TrialParts_1Components.append(UpperText_16)\u000a    TrialParts_1Components.append(UpperBrackets_16)\u000a    TrialParts_1Components.append(BotUpperLine_16)\u000a    TrialParts_1Components.append(TopLowerLine_16)\u000a    TrialParts_1Components.append(LowerText_16)\u000a    TrialParts_1Components.append(LowerBrackets_16)\u000a    TrialParts_1Components.append(BotLowerLine_16)\u000a    TrialParts_1Components.append(TrialCrossHair_16)\u000a    TrialParts_1Components.append(RestCrossHair_16)\u000a    TrialParts_1Components.append(text_36)\u000a    TrialParts_1Components.append(text_37)\u000a    TrialParts_1Components.append(text_50)\u000a    for thisComponent in TrialParts_1Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialParts_1"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialParts_1Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *text_27* updates\u000a        if t >= 0.0 and text_27.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_27.tStart = t  # underestimates by a little under one frame\u000a            text_27.frameNStart = frameN  # exact frame index\u000a            text_27.setAutoDraw(True)\u000a        elif text_27.status == STARTED and t >= (0.0 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_27.setAutoDraw(False)\u000a        \u000a        # *text_30* updates\u000a        if t >= 3 and text_30.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_30.tStart = t  # underestimates by a little under one frame\u000a            text_30.frameNStart = frameN  # exact frame index\u000a            text_30.setAutoDraw(True)\u000a        elif text_30.status == STARTED and t >= (3 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_30.setAutoDraw(False)\u000a        \u000a        # *text_31* updates\u000a        if t >= 6 and text_31.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_31.tStart = t  # underestimates by a little under one frame\u000a            text_31.frameNStart = frameN  # exact frame index\u000a            text_31.setAutoDraw(True)\u000a        elif text_31.status == STARTED and t >= (6 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_31.setAutoDraw(False)\u000a        \u000a        # *text_32* updates\u000a        if t >= 9 and text_32.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_32.tStart = t  # underestimates by a little under one frame\u000a            text_32.frameNStart = frameN  # exact frame index\u000a            text_32.setAutoDraw(True)\u000a        elif text_32.status == STARTED and t >= (9 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_32.setAutoDraw(False)\u000a        \u000a        # *TopUpperLine_16* updates\u000a        if t >= 0 and TopUpperLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine_16.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine_16.frameNStart = frameN  # exact frame index\u000a            TopUpperLine_16.setAutoDraw(True)\u000a        elif TopUpperLine_16.status == STARTED and t >= (0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine_16.setAutoDraw(False)\u000a        \u000a        # *UpperText_16* updates\u000a        if t >= 0 and UpperText_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText_16.tStart = t  # underestimates by a little under one frame\u000a            UpperText_16.frameNStart = frameN  # exact frame index\u000a            UpperText_16.setAutoDraw(True)\u000a        elif UpperText_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText_16.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets_16* updates\u000a        if t >= 0 and UpperBrackets_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets_16.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets_16.frameNStart = frameN  # exact frame index\u000a            UpperBrackets_16.setAutoDraw(True)\u000a        elif UpperBrackets_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets_16.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine_16* updates\u000a        if t >= 0.0 and BotUpperLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine_16.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine_16.frameNStart = frameN  # exact frame index\u000a            BotUpperLine_16.setAutoDraw(True)\u000a        elif BotUpperLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine_16.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine_16* updates\u000a        if t >= 0.0 and TopLowerLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine_16.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine_16.frameNStart = frameN  # exact frame index\u000a            TopLowerLine_16.setAutoDraw(True)\u000a        elif TopLowerLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine_16.setAutoDraw(False)\u000a        \u000a        # *LowerText_16* updates\u000a        if t >= 0 and LowerText_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText_16.tStart = t  # underestimates by a little under one frame\u000a            LowerText_16.frameNStart = frameN  # exact frame index\u000a            LowerText_16.setAutoDraw(True)\u000a        elif LowerText_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText_16.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets_16* updates\u000a        if t >= 0 and LowerBrackets_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets_16.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets_16.frameNStart = frameN  # exact frame index\u000a            LowerBrackets_16.setAutoDraw(True)\u000a        elif LowerBrackets_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets_16.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine_16* updates\u000a        if t >= 0.0 and BotLowerLine_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine_16.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine_16.frameNStart = frameN  # exact frame index\u000a            BotLowerLine_16.setAutoDraw(True)\u000a        elif BotLowerLine_16.status == STARTED and t >= (0.0 + (25-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine_16.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair_16* updates\u000a        if t >= 0 and TrialCrossHair_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair_16.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair_16.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair_16.setAutoDraw(True)\u000a        elif TrialCrossHair_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair_16.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair_16* updates\u000a        if t >= 0 and RestCrossHair_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair_16.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair_16.frameNStart = frameN  # exact frame index\u000a            RestCrossHair_16.setAutoDraw(True)\u000a        elif RestCrossHair_16.status == STARTED and t >= (0 + (0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair_16.setAutoDraw(False)\u000a        \u000a        # *text_36* updates\u000a        if t >= 12 and text_36.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_36.tStart = t  # underestimates by a little under one frame\u000a            text_36.frameNStart = frameN  # exact frame index\u000a            text_36.setAutoDraw(True)\u000a        elif text_36.status == STARTED and t >= (12 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_36.setAutoDraw(False)\u000a        \u000a        # *text_37* updates\u000a        if t >= 15 and text_37.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_37.tStart = t  # underestimates by a little under one frame\u000a            text_37.frameNStart = frameN  # exact frame index\u000a            text_37.setAutoDraw(True)\u000a        elif text_37.status == STARTED and t >= (15 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_37.setAutoDraw(False)\u000a        \u000a        # *text_50* updates\u000a        if t >= 20 and text_50.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_50.tStart = t  # underestimates by a little under one frame\u000a            text_50.frameNStart = frameN  # exact frame index\u000a            text_50.setAutoDraw(True)\u000a        elif text_50.status == STARTED and t >= (20 + (3-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_50.setAutoDraw(False)\u000a        # *ISI_16* period\u000a        if t >= 0.0 and ISI_16.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_16.tStart = t  # underestimates by a little under one frame\u000a            ISI_16.frameNStart = frameN  # exact frame index\u000a            ISI_16.start(1)\u000a        elif ISI_16.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_16.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialParts_1Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialParts_1"-------\u000a    for thisComponent in TrialParts_1Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a\u000a    #------Prepare to start Routine "trial5_2"-------\u000a    t = 0\u000a    trial5_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    UpperText.setText(u' L K R G M X ')\u000a    UpperBrackets.setText(u'  {         }')\u000a    LowerText.setText(u' b t y g q j ')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trial5_2Components = []\u000a    trial5_2Components.append(ISI)\u000a    trial5_2Components.append(TopUpperLine)\u000a    trial5_2Components.append(UpperText)\u000a    trial5_2Components.append(UpperBrackets)\u000a    trial5_2Components.append(BotUpperLine)\u000a    trial5_2Components.append(TopLowerLine)\u000a    trial5_2Components.append(LowerText)\u000a    trial5_2Components.append(LowerBrackets)\u000a    trial5_2Components.append(BotLowerLine)\u000a    trial5_2Components.append(TrialCrossHair)\u000a    trial5_2Components.append(RestCrossHair)\u000a    trial5_2Components.append(resp)\u000a    for thisComponent in trial5_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "trial5_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial5_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *TopUpperLine* updates\u000a        if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine.frameNStart = frameN  # exact frame index\u000a            TopUpperLine.setAutoDraw(True)\u000a        elif TopUpperLine.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine.setAutoDraw(False)\u000a        \u000a        # *UpperText* updates\u000a        if t >= 0 and UpperText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText.tStart = t  # underestimates by a little under one frame\u000a            UpperText.frameNStart = frameN  # exact frame index\u000a            UpperText.setAutoDraw(True)\u000a        elif UpperText.status == STARTED and t >= (0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets* updates\u000a        if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets.frameNStart = frameN  # exact frame index\u000a            UpperBrackets.setAutoDraw(True)\u000a        elif UpperBrackets.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine* updates\u000a        if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine.frameNStart = frameN  # exact frame index\u000a            BotUpperLine.setAutoDraw(True)\u000a        elif BotUpperLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine* updates\u000a        if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine.frameNStart = frameN  # exact frame index\u000a            TopLowerLine.setAutoDraw(True)\u000a        elif TopLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine.setAutoDraw(False)\u000a        \u000a        # *LowerText* updates\u000a        if t >= 7 and LowerText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText.tStart = t  # underestimates by a little under one frame\u000a            LowerText.frameNStart = frameN  # exact frame index\u000a            LowerText.setAutoDraw(True)\u000a        elif LowerText.status == STARTED and t >= (7 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets* updates\u000a        if t >= 7 and LowerBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets.frameNStart = frameN  # exact frame index\u000a            LowerBrackets.setAutoDraw(True)\u000a        elif LowerBrackets.status == STARTED and t >= (7 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine* updates\u000a        if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine.frameNStart = frameN  # exact frame index\u000a            BotLowerLine.setAutoDraw(True)\u000a        elif BotLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair* updates\u000a        if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair.setAutoDraw(True)\u000a        elif TrialCrossHair.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair* updates\u000a        if t >= 9 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (9 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # *resp* updates\u000a        if t >= 7 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif resp.status == STARTED and t >= (7 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(u'6')) or (resp.keys == u'6'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(1)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial5_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "trial5_2"-------\u000a    for thisComponent in trial5_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(u'6').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('resp.keys',resp.keys)\u000a    thisExp.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        thisExp.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "TrialFeedBack"-------\u000a    t = 0\u000a    TrialFeedBackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.000000)\u000a    # update component parameters for each repeat\u000a    if ((resp.corr) & (resp.rt < 2.0)):#stored on last run routine\u000a      msg="Correct and on time! RT=%.3f" %(resp.rt)\u000a    elif ((resp.corr) & (resp.rt > 2.0)):#stored on last run routine\u000a      msg="Correct, but too slow!\u005cn RT=%.3f\u005cnResponse time should be less than two seconds." %(resp.rt)\u000a    else:\u000a      if resp.rt < 2.0:\u000a        msg="Oops! That was incorrect, but on time!"\u000a      else: \u000a        msg="Oops! That was incorrect and too slow!"\u000a    text_47.setText(msg)\u000a    # keep track of which components have finished\u000a    TrialFeedBackComponents = []\u000a    TrialFeedBackComponents.append(text_47)\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialFeedBack"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialFeedBackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text_47* updates\u000a        if t >= 0.0 and text_47.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text_47.tStart = t  # underestimates by a little under one frame\u000a            text_47.frameNStart = frameN  # exact frame index\u000a            text_47.setAutoDraw(True)\u000a        elif text_47.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text_47.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialFeedBackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a            sys.exit()\u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialFeedBack"-------\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    msg='Ended'\u000a    win.close()\u000a#    win.close()\u000a\u000adef Test(subid,visitid):\u000a    expInfo = {u'Visit ID': u'9999', u'Participant ID': u'1'}\u000a    print 'subid is %s'%(subid)\u000a    if subid == '9999':\u000a        dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a    else:\u000a        expInfo['Participant ID']=subid\u000a        expInfo['Visit ID']=visitid    \u000a    # Store info about the experiment session\u000a\u000a    expInfo['date'] = data.getDateStr()  # add a simple timestamp\u000a    expInfo['expName'] = expName\u000a\u000a    # Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000a    filename = _thisDir + os.sep + 'data/%s_%s_%s_%s' %(expInfo['Participant ID'], expInfo['Visit ID'],expName, expInfo['date'])\u000a\u000a    # An ExperimentHandler isn't essential but helps with data saving\u000a    thisExp = data.ExperimentHandler(name=expName, version='',\u000a        extraInfo=expInfo, runtimeInfo=None,\u000a        originPath=None,\u000a        savePickle=True, saveWideText=False,\u000a        dataFileName=filename)\u000a    logging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000a    endExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a    # Start Code - component code to be run before the window creation\u000a\u000a    # Setup the Window\u000a    win = visual.Window(size=[800, 600], fullscr=FullScreenFlag, screen=0, allowGUI=True, allowStencil=False,\u000a        monitor=ScreenToUse, color=[-1,-1,-1], colorSpace='rgb',\u000a        blendMode='average', useFBO=True,\u000a        units='cm')\u000a    # store frame rate of monitor if we can measure it successfully\u000a    expInfo['frameRate']=win.getActualFrameRate()\u000a    if expInfo['frameRate']!=None:\u000a        frameDur = 1.0/round(expInfo['frameRate'])\u000a    else:\u000a        frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a    # Initialize components for Routine "trial_2"\u000a    trial_2Clock = core.Clock()\u000a    ISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a    TopUpperLine = visual.Line(win=win, name='TopUpperLine',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.45],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='[1,1,-1]', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    UpperText = visual.TextStim(win=win, ori=0, name='UpperText',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0.3], height=0.2, wrapWidth=1.5,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-2.0)\u000a    UpperBrackets = visual.TextStim(win=win, ori=0, name='UpperBrackets',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0.3], height=0.2, wrapWidth=1.5,\u000a        color='yellow', colorSpace='rgb', opacity=1,\u000a        depth=-3.0)\u000a    BotUpperLine = visual.Line(win=win, name='BotUpperLine',units='norm', \u000a        start=(-[2, 0.95][0]/2.0, 0), end=(+[2, 0.95][0]/2.0, 0),\u000a        ori=0, pos=[0, 0.15],\u000a        lineWidth=2, lineColor=[1,1,-1], lineColorSpace='rgb',\u000a        fillColor='yellow', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TopLowerLine = visual.Line(win=win, name='TopLowerLine',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0, -0.15],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    LowerText = visual.TextStim(win=win, ori=0, name='LowerText',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=2,\u000a        color=[0,0,0], colorSpace='rgb', opacity=1,\u000a        depth=-6.0)\u000a    LowerBrackets = visual.TextStim(win=win, ori=0, name='LowerBrackets',\u000a        text='      { }    ',    font='Courier',\u000a        units='norm', pos=[0,-0.3], height=0.2, wrapWidth=None,\u000a        color='cyan', colorSpace='rgb', opacity=1,\u000a        depth=-7.0)\u000a    BotLowerLine = visual.Line(win=win, name='BotLowerLine',units='norm', \u000a        start=(-[2, 0.5][0]/2.0, 0), end=(+[2, 0.5][0]/2.0, 0),\u000a        ori=0, pos=[0,-0.45],\u000a        lineWidth=2, lineColor='cyan', lineColorSpace='rgb',\u000a        fillColor='cyan', fillColorSpace='rgb',\u000a        opacity=1,interpolate=True)\u000a    TrialCrossHair = visual.TextStim(win=win, ori=0, name='TrialCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='green', colorSpace='rgb', opacity=1,\u000a        depth=-9.0)\u000a    RestCrossHair = visual.TextStim(win=win, ori=0, name='RestCrossHair',\u000a        text='+',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.2, wrapWidth=None,\u000a        color='red', colorSpace='rgb', opacity=1,\u000a        depth=-10.0)\u000a\u000a    # Initialize components for Routine "TrialFeedBack"\u000a    TrialFeedBackClock = core.Clock()\u000a    #msg variable just needs some value at start\u000a    msg=''\u000a    text = visual.TextStim(win=win, ori=0, name='text',\u000a        text='default text',    font='Courier',\u000a        units='norm', pos=[0, 0], height=0.1, wrapWidth=1.5,\u000a        color='white', colorSpace='rgb', opacity=1,\u000a        depth=-1.0)\u000a\u000a    # Create some handy timers\u000a    globalClock = core.Clock()  # to track the time since experiment started\u000a    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a    #------Prepare to start Routine "trial_2"-------\u000a    t = 0\u000a    trial_2Clock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(11.000000)\u000a    # update component parameters for each repeat\u000a    UpperText.setText(' A B C D E F ')\u000a    UpperBrackets.setText('  {         }')\u000a    LowerText.setText(' a b c d e f ')\u000a    resp = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    resp.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    trial_2Components = []\u000a    trial_2Components.append(ISI)\u000a    trial_2Components.append(TopUpperLine)\u000a    trial_2Components.append(UpperText)\u000a    trial_2Components.append(UpperBrackets)\u000a    trial_2Components.append(BotUpperLine)\u000a    trial_2Components.append(TopLowerLine)\u000a    trial_2Components.append(LowerText)\u000a    trial_2Components.append(LowerBrackets)\u000a    trial_2Components.append(BotLowerLine)\u000a    trial_2Components.append(TrialCrossHair)\u000a    trial_2Components.append(RestCrossHair)\u000a    trial_2Components.append(resp)\u000a    for thisComponent in trial_2Components:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "trial_2"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = trial_2Clock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *TopUpperLine* updates\u000a        if t >= 0 and TopUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopUpperLine.tStart = t  # underestimates by a little under one frame\u000a            TopUpperLine.frameNStart = frameN  # exact frame index\u000a            TopUpperLine.setAutoDraw(True)\u000a        elif TopUpperLine.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopUpperLine.setAutoDraw(False)\u000a        \u000a        # *UpperText* updates\u000a        if t >= 0 and UpperText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperText.tStart = t  # underestimates by a little under one frame\u000a            UpperText.frameNStart = frameN  # exact frame index\u000a            UpperText.setAutoDraw(True)\u000a        elif UpperText.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperText.setAutoDraw(False)\u000a        \u000a        # *UpperBrackets* updates\u000a        if t >= 0.0 and UpperBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            UpperBrackets.tStart = t  # underestimates by a little under one frame\u000a            UpperBrackets.frameNStart = frameN  # exact frame index\u000a            UpperBrackets.setAutoDraw(True)\u000a        elif UpperBrackets.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            UpperBrackets.setAutoDraw(False)\u000a        \u000a        # *BotUpperLine* updates\u000a        if t >= 0.0 and BotUpperLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotUpperLine.tStart = t  # underestimates by a little under one frame\u000a            BotUpperLine.frameNStart = frameN  # exact frame index\u000a            BotUpperLine.setAutoDraw(True)\u000a        elif BotUpperLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotUpperLine.setAutoDraw(False)\u000a        \u000a        # *TopLowerLine* updates\u000a        if t >= 0.0 and TopLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TopLowerLine.tStart = t  # underestimates by a little under one frame\u000a            TopLowerLine.frameNStart = frameN  # exact frame index\u000a            TopLowerLine.setAutoDraw(True)\u000a        elif TopLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TopLowerLine.setAutoDraw(False)\u000a        \u000a        # *LowerText* updates\u000a        if t >= 7 and LowerText.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerText.tStart = t  # underestimates by a little under one frame\u000a            LowerText.frameNStart = frameN  # exact frame index\u000a            LowerText.setAutoDraw(True)\u000a        elif LowerText.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerText.setAutoDraw(False)\u000a        \u000a        # *LowerBrackets* updates\u000a        if t >= 7 and LowerBrackets.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            LowerBrackets.tStart = t  # underestimates by a little under one frame\u000a            LowerBrackets.frameNStart = frameN  # exact frame index\u000a            LowerBrackets.setAutoDraw(True)\u000a        elif LowerBrackets.status == STARTED and t >= (0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            LowerBrackets.setAutoDraw(False)\u000a        \u000a        # *BotLowerLine* updates\u000a        if t >= 0.0 and BotLowerLine.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            BotLowerLine.tStart = t  # underestimates by a little under one frame\u000a            BotLowerLine.frameNStart = frameN  # exact frame index\u000a            BotLowerLine.setAutoDraw(True)\u000a        elif BotLowerLine.status == STARTED and t >= (0.0 + (11-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            BotLowerLine.setAutoDraw(False)\u000a        \u000a        # *TrialCrossHair* updates\u000a        if t >= 0 and TrialCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            TrialCrossHair.tStart = t  # underestimates by a little under one frame\u000a            TrialCrossHair.frameNStart = frameN  # exact frame index\u000a            TrialCrossHair.setAutoDraw(True)\u000a        elif TrialCrossHair.status == STARTED and t >= (0 + (9-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            TrialCrossHair.setAutoDraw(False)\u000a        \u000a        # *RestCrossHair* updates\u000a        if t >= 9 and RestCrossHair.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            RestCrossHair.tStart = t  # underestimates by a little under one frame\u000a            RestCrossHair.frameNStart = frameN  # exact frame index\u000a            RestCrossHair.setAutoDraw(True)\u000a        elif RestCrossHair.status == STARTED and t >= (9 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            RestCrossHair.setAutoDraw(False)\u000a        \u000a        # *resp* updates\u000a        if t >= 7 and resp.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            resp.tStart = t  # underestimates by a little under one frame\u000a            resp.frameNStart = frameN  # exact frame index\u000a            resp.status = STARTED\u000a            # keyboard checking is just starting\u000a            resp.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        elif resp.status == STARTED and t >= (7 + (4-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            resp.status = STOPPED\u000a        if resp.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=AllowedInputKeys)#['1', '2', '3', '4', '5', '6', '7', '8'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                resp.keys = theseKeys[-1]  # just the last key pressed\u000a                resp.rt = resp.clock.getTime()\u000a                # was this 'correct'?\u000a                if (resp.keys == str(u'6')) or (resp.keys == u'6'):\u000a                    resp.corr = 1\u000a                else:\u000a                    resp.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 0.0 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(1)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trial_2Components:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "trial_2"-------\u000a    for thisComponent in trial_2Components:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if resp.keys in ['', [], None]:  # No response was made\u000a       resp.keys=None\u000a       # was no response the correct answer?!\u000a       if str(u'6').lower() == 'none': resp.corr = 1  # correct non-response\u000a       else: resp.corr = 0  # failed to respond (incorrectly)\u000a    # store data for thisExp (ExperimentHandler)\u000a    thisExp.addData('resp.keys',resp.keys)\u000a    thisExp.addData('resp.corr', resp.corr)\u000a    if resp.keys != None:  # we had a response\u000a        thisExp.addData('resp.rt', resp.rt)\u000a    thisExp.nextEntry()\u000a\u000a    #------Prepare to start Routine "TrialFeedBack"-------\u000a    t = 0\u000a    TrialFeedBackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(2.000000)\u000a    # update component parameters for each repeat\u000a    if ((resp.corr) & (resp.rt < 2.0)):#stored on last run routine\u000a      msg="Correct and on time! RT=%.3f" %(resp.rt)\u000a    elif ((resp.corr) & (resp.rt > 2.0)):#stored on last run routine\u000a      msg="Correct, but too slow!\u005cn RT=%.3f\u005cnResponse time should be less than two seconds." %(resp.rt)\u000a    else:\u000a      if resp.rt < 2.0:\u000a        msg="Oops! That was incorrect, but on time!"\u000a      else: \u000a        msg="Oops! That was incorrect and too slow!"\u000a    text.setText(msg)\u000a    # keep track of which components have finished\u000a    TrialFeedBackComponents = []\u000a    TrialFeedBackComponents.append(text)\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "TrialFeedBack"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = TrialFeedBackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        \u000a        # *text* updates\u000a        if t >= 0.0 and text.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            text.tStart = t  # underestimates by a little under one frame\u000a            text.frameNStart = frameN  # exact frame index\u000a            text.setAutoDraw(True)\u000a        elif text.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            text.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            routineTimer.reset()  # if we abort early the non-slip timer needs reset\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in TrialFeedBackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            win.close()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "TrialFeedBack"-------\u000a    for thisComponent in TrialFeedBackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    msg='Ended'\u000a\u000a    win.close()\u000a\u000a
p1588
sS'thisTrial'
p1589
(lp1590
sS'_exp'
p1591
I157922320
sg10
S'trials'
p1592
sg6
S'PartialTrialFunction.py'
p1593
sS'thisRepN'
p1594
I1
sg20
I01
sg21
g22
sS'data'
p1595
g1
(cpsychopy.data
DataHandler
p1596
c__builtin__
dict
p1597
(dp1598
g18
cnumpy.ma.core
_mareconstruct
p1599
(cnumpy.ma.core
MaskedArray
p1600
cnumpy
ndarray
p1601
(I0
tp1602
S'b'
tRp1603
(I1
(I72
I1
tg30
(S'f4'
I0
I1
tRp1604
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
cnumpy.core.multiarray
_reconstruct
p1605
(g1601
(I0
tS'b'
tRp1606
(I1
(I72
I1
tg30
(S'O4'
I0
I1
tRp1607
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp1608
S'--'
p1609
aS'--'
p1610
ag110
ag132
ag154
ag176
ag198
ag220
ag242
aS'--'
p1611
aS'--'
p1612
ag303
aS'--'
p1613
ag344
aS'--'
p1614
ag385
ag407
ag429
ag451
ag473
ag495
ag517
ag539
ag561
aS'--'
p1615
aS'--'
p1616
ag621
aS'--'
p1617
aS'--'
p1618
ag681
ag703
aS'--'
p1619
ag744
aS'--'
p1620
ag785
ag807
ag829
aS'--'
p1621
ag870
ag892
ag914
ag936
aS'--'
p1622
ag977
ag998
ag1020
ag1042
ag1064
aS'--'
p1623
aS'--'
p1624
ag1124
ag1146
aS'--'
p1625
aS'--'
p1626
aS'--'
p1627
ag1225
ag1247
ag1269
aS'--'
p1628
aS'--'
p1629
ag1329
ag1351
ag1373
aS'--'
p1630
ag1414
ag1436
aS'--'
p1631
ag1477
aS'--'
p1632
aS'--'
p1633
ag1537
ag1559
atbsS'ran'
p1634
g1599
(g1600
g1601
g1602
S'b'
tRp1635
(I1
(I72
I1
tg1604
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
g1605
(g1601
(I0
tS'b'
tRp1636
(I1
(I72
I1
tg1607
I00
(lp1637
NaNag129
ag151
ag173
ag195
ag217
ag239
ag261
aNaNag322
aNag363
aNag404
ag426
ag448
ag470
ag492
ag514
ag536
ag558
ag580
aNaNag640
aNaNag700
ag722
aNag763
aNag804
ag826
ag848
aNag889
ag911
ag933
ag955
aNag995
ag1017
ag1039
ag1061
ag1083
aNaNag1143
ag1165
aNaNaNag1244
ag1266
ag1288
aNaNag1348
ag1370
ag1392
aNag1433
ag1455
aNag1496
aNaNag1556
ag1578
atbsg16
g1599
(g1600
g1601
g1602
S'b'
tRp1638
(I1
(I72
I1
tg1604
I00
S'\xd7i\xadN\xd7i\xadN\xd7i\xadN\xd7i\xadN\xd7i\xadN\xd7i\xadN\xd8i\xadN\xd8i\xadN\xd8i\xadN\xd8i\xadN\xd8i\xadN\xd8i\xadN\xd8i\xadN\xd8i\xadN\xd8i\xadN\xd8i\xadN\xd8i\xadN\xd8i\xadN\xd9i\xadN\xd9i\xadN\xd9i\xadN\xd9i\xadN\xd9i\xadN\xd9i\xadN\xd9i\xadN\xd9i\xadN\xd9i\xadN\xd9i\xadN\xd9i\xadN\xd9i\xadN\xdai\xadN\xdai\xadN\xdai\xadN\xdai\xadN\xdai\xadN\xdai\xadN\xdai\xadN\xdai\xadN\xdai\xadN\xdai\xadN\xdai\xadN\xdbi\xadN\xdbi\xadN\xdbi\xadN\xdbi\xadN\xdbi\xadN\xdbi\xadN\xdbi\xadN\xdbi\xadN\xdbi\xadN\xdbi\xadN\xdbi\xadN\xdbi\xadN\xdbi\xadN\xdci\xadN\xdci\xadN\xdci\xadN\xdci\xadN\xdci\xadN\xdci\xadN\xdci\xadN\xdci\xadN\xdci\xadN\xdci\xadN\xdci\xadN\xdci\xadN\xddi\xadN\xddi\xadN\xddi\xadN\xddi\xadN\xddi\xadN\xddi\xadN'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p1639
g1599
(g1600
g1601
g1602
S'b'
tRp1640
(I1
(I72
I1
tg1604
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00@\x00\x00@@\x00\x00\x80@\x00\x00\xa0@\x00\x00\xc0@\x00\x00\xe0@\x00\x00\x00A\x00\x00\x10A\x00\x00 A\x00\x000A\x00\x00@A\x00\x00PA\x00\x00`A\x00\x00pA\x00\x00\x80A\x00\x00\x88A\x00\x00\x90A\x00\x00\x98A\x00\x00\xa0A\x00\x00\xa8A\x00\x00\xb0A\x00\x00\xb8A\x00\x00\xc0A\x00\x00\xc8A\x00\x00\xd0A\x00\x00\xd8A\x00\x00\xe0A\x00\x00\xe8A\x00\x00\xf0A\x00\x00\xf8A\x00\x00\x00B\x00\x00\x04B\x00\x00\x08B\x00\x00\x0cB\x00\x00\x10B\x00\x00\x14B\x00\x00\x18B\x00\x00\x1cB\x00\x00 B\x00\x00$B\x00\x00(B\x00\x00,B\x00\x000B\x00\x004B\x00\x008B\x00\x00<B\x00\x00@B\x00\x00DB\x00\x00HB\x00\x00LB\x00\x00PB\x00\x00TB\x00\x00XB\x00\x00\\B\x00\x00`B\x00\x00dB\x00\x00hB\x00\x00lB\x00\x00pB\x00\x00tB\x00\x00xB\x00\x00|B\x00\x00\x80B\x00\x00\x82B\x00\x00\x84B\x00\x00\x86B\x00\x00\x88B\x00\x00\x8aB\x00\x00\x8cB\x00\x00\x8eB'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp1641
(dp1642
S'isNumeric'
p1643
(dp1644
g18
I01
sg1634
I01
sg16
I01
sg19
I00
sg17
I00
sg1639
I01
ssg1592
g1585
sS'dataTypes'
p1645
(lp1646
g1634
ag1639
ag16
ag17
ag18
ag19
asS'dataShape'
p1647
(lp1648
I72
aI1
asbsS'method'
p1649
Vsequential
p1650
sS'sequenceIndices'
p1651
g1605
(g1601
(I0
tS'b'
tRp1652
(I1
(I72
I1
tg80
I00
S'\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t\x00\x00\x00\n\x00\x00\x00\x0b\x00\x00\x00\x0c\x00\x00\x00\r\x00\x00\x00\x0e\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\x11\x00\x00\x00\x12\x00\x00\x00\x13\x00\x00\x00\x14\x00\x00\x00\x15\x00\x00\x00\x16\x00\x00\x00\x17\x00\x00\x00\x18\x00\x00\x00\x19\x00\x00\x00\x1a\x00\x00\x00\x1b\x00\x00\x00\x1c\x00\x00\x00\x1d\x00\x00\x00\x1e\x00\x00\x00\x1f\x00\x00\x00 \x00\x00\x00!\x00\x00\x00"\x00\x00\x00#\x00\x00\x00$\x00\x00\x00%\x00\x00\x00&\x00\x00\x00\'\x00\x00\x00(\x00\x00\x00)\x00\x00\x00*\x00\x00\x00+\x00\x00\x00,\x00\x00\x00-\x00\x00\x00.\x00\x00\x00/\x00\x00\x000\x00\x00\x001\x00\x00\x002\x00\x00\x003\x00\x00\x004\x00\x00\x005\x00\x00\x006\x00\x00\x007\x00\x00\x008\x00\x00\x009\x00\x00\x00:\x00\x00\x00;\x00\x00\x00<\x00\x00\x00=\x00\x00\x00>\x00\x00\x00?\x00\x00\x00@\x00\x00\x00A\x00\x00\x00B\x00\x00\x00C\x00\x00\x00D\x00\x00\x00E\x00\x00\x00F\x00\x00\x00G\x00\x00\x00'
tbsS'finished'
p1653
I01
sS'nReps'
p1654
I1
sS'nRemaining'
p1655
I-1
sS'trialList'
p1656
(lp1657
g1
(cpsychopy.data
TrialType
p1658
g1597
(dp1659
g41
g78
sg42
g70
sg43
g82
sg44
g71
sg45
g72
sg46
g84
sg47
g73
sg48
g74
sg49
g86
sg50
g75
sg51
g76
sg52
V 
sg53
g88
sg54
g77
stRp1660
ag1
(g1658
g1597
(dp1661
g41
g98
sg42
g90
sg43
g101
sg44
g91
sg45
g92
sg46
g103
sg47
g93
sg48
g94
sg49
g105
sg50
g95
sg51
g96
sg52
V 
sg53
g107
sg54
g97
stRp1662
ag1
(g1658
g1597
(dp1663
g41
g121
sg42
g115
sg43
g124
sg44
g116
sg45
g117
sg46
g113
sg47
g118
sg48
g109
sg49
g126
sg50
g119
sg51
g111
sg52
g120
sg53
g128
sg54
g112
stRp1664
ag1
(g1658
g1597
(dp1665
g41
g143
sg42
g137
sg43
g146
sg44
g138
sg45
g139
sg46
g135
sg47
g140
sg48
g131
sg49
g148
sg50
g141
sg51
g133
sg52
g142
sg53
g150
sg54
g134
stRp1666
ag1
(g1658
g1597
(dp1667
g41
g165
sg42
g159
sg43
g168
sg44
g160
sg45
g161
sg46
g157
sg47
g162
sg48
g153
sg49
g170
sg50
g163
sg51
g155
sg52
g164
sg53
g172
sg54
g156
stRp1668
ag1
(g1658
g1597
(dp1669
g41
g187
sg42
g181
sg43
g190
sg44
g182
sg45
g183
sg46
g179
sg47
g184
sg48
g175
sg49
g192
sg50
g185
sg51
g177
sg52
g186
sg53
g194
sg54
g178
stRp1670
ag1
(g1658
g1597
(dp1671
g41
g209
sg42
g203
sg43
g212
sg44
g204
sg45
g205
sg46
g201
sg47
g206
sg48
g197
sg49
g214
sg50
g207
sg51
g199
sg52
g208
sg53
g216
sg54
g200
stRp1672
ag1
(g1658
g1597
(dp1673
g41
g231
sg42
g225
sg43
g234
sg44
g226
sg45
g227
sg46
g223
sg47
g228
sg48
g219
sg49
g236
sg50
g229
sg51
g221
sg52
g230
sg53
g238
sg54
g222
stRp1674
ag1
(g1658
g1597
(dp1675
g41
g253
sg42
g247
sg43
g256
sg44
g248
sg45
g249
sg46
g245
sg47
g250
sg48
g241
sg49
g258
sg50
g251
sg51
g243
sg52
g252
sg53
g260
sg54
g244
stRp1676
ag1
(g1658
g1597
(dp1677
g41
g271
sg42
g263
sg43
g274
sg44
g264
sg45
g265
sg46
g276
sg47
g266
sg48
g267
sg49
g278
sg50
g268
sg51
g269
sg52
V 
sg53
g280
sg54
g270
stRp1678
ag1
(g1658
g1597
(dp1679
g41
g291
sg42
g282
sg43
g294
sg44
g283
sg45
g284
sg46
g296
sg47
g285
sg48
g286
sg49
g298
sg50
g287
sg51
g288
sg52
g289
sg53
g300
sg54
g290
stRp1680
ag1
(g1658
g1597
(dp1681
g41
g314
sg42
g308
sg43
g317
sg44
g309
sg45
g310
sg46
g306
sg47
g311
sg48
g302
sg49
g319
sg50
g312
sg51
g304
sg52
g313
sg53
g321
sg54
g305
stRp1682
ag1
(g1658
g1597
(dp1683
g41
g332
sg42
g324
sg43
g335
sg44
g325
sg45
g326
sg46
g337
sg47
g327
sg48
g328
sg49
g339
sg50
g329
sg51
g330
sg52
V 
sg53
g341
sg54
g331
stRp1684
ag1
(g1658
g1597
(dp1685
g41
g355
sg42
g349
sg43
g358
sg44
g350
sg45
g351
sg46
g347
sg47
g352
sg48
g343
sg49
g360
sg50
g353
sg51
g345
sg52
g354
sg53
g362
sg54
g346
stRp1686
ag1
(g1658
g1597
(dp1687
g41
g373
sg42
g365
sg43
g376
sg44
g366
sg45
g367
sg46
g378
sg47
g368
sg48
g369
sg49
g380
sg50
g370
sg51
g371
sg52
V 
sg53
g382
sg54
g372
stRp1688
ag1
(g1658
g1597
(dp1689
g41
g396
sg42
g390
sg43
g399
sg44
g391
sg45
g392
sg46
g388
sg47
g393
sg48
g384
sg49
g401
sg50
g394
sg51
g386
sg52
g395
sg53
g403
sg54
g387
stRp1690
ag1
(g1658
g1597
(dp1691
g41
g418
sg42
g412
sg43
g421
sg44
g413
sg45
g414
sg46
g410
sg47
g415
sg48
g406
sg49
g423
sg50
g416
sg51
g408
sg52
g417
sg53
g425
sg54
g409
stRp1692
ag1
(g1658
g1597
(dp1693
g41
g440
sg42
g434
sg43
g443
sg44
g435
sg45
g436
sg46
g432
sg47
g437
sg48
g428
sg49
g445
sg50
g438
sg51
g430
sg52
g439
sg53
g447
sg54
g431
stRp1694
ag1
(g1658
g1597
(dp1695
g41
g462
sg42
g456
sg43
g465
sg44
g457
sg45
g458
sg46
g454
sg47
g459
sg48
g450
sg49
g467
sg50
g460
sg51
g452
sg52
g461
sg53
g469
sg54
g453
stRp1696
ag1
(g1658
g1597
(dp1697
g41
g484
sg42
g478
sg43
g487
sg44
g479
sg45
g480
sg46
g476
sg47
g481
sg48
g472
sg49
g489
sg50
g482
sg51
g474
sg52
g483
sg53
g491
sg54
g475
stRp1698
ag1
(g1658
g1597
(dp1699
g41
g506
sg42
g500
sg43
g509
sg44
g501
sg45
g502
sg46
g498
sg47
g503
sg48
g494
sg49
g511
sg50
g504
sg51
g496
sg52
g505
sg53
g513
sg54
g497
stRp1700
ag1
(g1658
g1597
(dp1701
g41
g528
sg42
g522
sg43
g531
sg44
g523
sg45
g524
sg46
g520
sg47
g525
sg48
g516
sg49
g533
sg50
g526
sg51
g518
sg52
g527
sg53
g535
sg54
g519
stRp1702
ag1
(g1658
g1597
(dp1703
g41
g550
sg42
g544
sg43
g553
sg44
g545
sg45
g546
sg46
g542
sg47
g547
sg48
g538
sg49
g555
sg50
g548
sg51
g540
sg52
g549
sg53
g557
sg54
g541
stRp1704
ag1
(g1658
g1597
(dp1705
g41
g572
sg42
g566
sg43
g575
sg44
g567
sg45
g568
sg46
g564
sg47
g569
sg48
g560
sg49
g577
sg50
g570
sg51
g562
sg52
g571
sg53
g579
sg54
g563
stRp1706
ag1
(g1658
g1597
(dp1707
g41
g590
sg42
g582
sg43
g593
sg44
g583
sg45
g584
sg46
g595
sg47
g585
sg48
g586
sg49
g597
sg50
g587
sg51
g588
sg52
V 
sg53
g599
sg54
g589
stRp1708
ag1
(g1658
g1597
(dp1709
g41
g609
sg42
g601
sg43
g612
sg44
g602
sg45
g603
sg46
g614
sg47
g604
sg48
g605
sg49
g616
sg50
g606
sg51
g607
sg52
V 
sg53
g618
sg54
g608
stRp1710
ag1
(g1658
g1597
(dp1711
g41
g632
sg42
g626
sg43
g635
sg44
g627
sg45
g628
sg46
g624
sg47
g629
sg48
g620
sg49
g637
sg50
g630
sg51
g622
sg52
g631
sg53
g639
sg54
g623
stRp1712
ag1
(g1658
g1597
(dp1713
g41
g650
sg42
g642
sg43
g653
sg44
g643
sg45
g644
sg46
g655
sg47
g645
sg48
g646
sg49
g657
sg50
g647
sg51
g648
sg52
V 
sg53
g659
sg54
g649
stRp1714
ag1
(g1658
g1597
(dp1715
g41
g669
sg42
g661
sg43
g672
sg44
g662
sg45
g663
sg46
g674
sg47
g664
sg48
g665
sg49
g676
sg50
g666
sg51
g667
sg52
V 
sg53
g678
sg54
g668
stRp1716
ag1
(g1658
g1597
(dp1717
g41
g692
sg42
g686
sg43
g695
sg44
g687
sg45
g688
sg46
g684
sg47
g689
sg48
g680
sg49
g697
sg50
g690
sg51
g682
sg52
g691
sg53
g699
sg54
g683
stRp1718
ag1
(g1658
g1597
(dp1719
g41
g714
sg42
g708
sg43
g717
sg44
g709
sg45
g710
sg46
g706
sg47
g711
sg48
g702
sg49
g719
sg50
g712
sg51
g704
sg52
g713
sg53
g721
sg54
g705
stRp1720
ag1
(g1658
g1597
(dp1721
g41
g732
sg42
g724
sg43
g735
sg44
g725
sg45
g726
sg46
g737
sg47
g727
sg48
g728
sg49
g739
sg50
g729
sg51
g730
sg52
V 
sg53
g741
sg54
g731
stRp1722
ag1
(g1658
g1597
(dp1723
g41
g755
sg42
g749
sg43
g758
sg44
g750
sg45
g751
sg46
g747
sg47
g752
sg48
g743
sg49
g760
sg50
g753
sg51
g745
sg52
g754
sg53
g762
sg54
g746
stRp1724
ag1
(g1658
g1597
(dp1725
g41
g773
sg42
g765
sg43
g776
sg44
g766
sg45
g767
sg46
g778
sg47
g768
sg48
g769
sg49
g780
sg50
g770
sg51
g771
sg52
V 
sg53
g782
sg54
g772
stRp1726
ag1
(g1658
g1597
(dp1727
g41
g796
sg42
g790
sg43
g799
sg44
g791
sg45
g792
sg46
g788
sg47
g793
sg48
g784
sg49
g801
sg50
g794
sg51
g786
sg52
g795
sg53
g803
sg54
g787
stRp1728
ag1
(g1658
g1597
(dp1729
g41
g818
sg42
g812
sg43
g821
sg44
g813
sg45
g814
sg46
g810
sg47
g815
sg48
g806
sg49
g823
sg50
g816
sg51
g808
sg52
g817
sg53
g825
sg54
g809
stRp1730
ag1
(g1658
g1597
(dp1731
g41
g840
sg42
g834
sg43
g843
sg44
g835
sg45
g836
sg46
g832
sg47
g837
sg48
g828
sg49
g845
sg50
g838
sg51
g830
sg52
g839
sg53
g847
sg54
g831
stRp1732
ag1
(g1658
g1597
(dp1733
g41
g858
sg42
g850
sg43
g861
sg44
g851
sg45
g852
sg46
g863
sg47
g853
sg48
g854
sg49
g865
sg50
g855
sg51
g856
sg52
V 
sg53
g867
sg54
g857
stRp1734
ag1
(g1658
g1597
(dp1735
g41
g881
sg42
g875
sg43
g884
sg44
g876
sg45
g877
sg46
g873
sg47
g878
sg48
g869
sg49
g886
sg50
g879
sg51
g871
sg52
g880
sg53
g888
sg54
g872
stRp1736
ag1
(g1658
g1597
(dp1737
g41
g903
sg42
g897
sg43
g906
sg44
g898
sg45
g899
sg46
g895
sg47
g900
sg48
g891
sg49
g908
sg50
g901
sg51
g893
sg52
g902
sg53
g910
sg54
g894
stRp1738
ag1
(g1658
g1597
(dp1739
g41
g925
sg42
g919
sg43
g928
sg44
g920
sg45
g921
sg46
g917
sg47
g922
sg48
g913
sg49
g930
sg50
g923
sg51
g915
sg52
g924
sg53
g932
sg54
g916
stRp1740
ag1
(g1658
g1597
(dp1741
g41
g947
sg42
g941
sg43
g950
sg44
g942
sg45
g943
sg46
g939
sg47
g944
sg48
g935
sg49
g952
sg50
g945
sg51
g937
sg52
g946
sg53
g954
sg54
g938
stRp1742
ag1
(g1658
g1597
(dp1743
g41
g965
sg42
g957
sg43
g968
sg44
g958
sg45
g959
sg46
g970
sg47
g960
sg48
g961
sg49
g972
sg50
g962
sg51
g963
sg52
V 
sg53
g974
sg54
g964
stRp1744
ag1
(g1658
g1597
(dp1745
g41
g987
sg42
g982
sg43
g990
sg44
g983
sg45
g984
sg46
g980
sg47
g985
sg48
g976
sg49
g992
sg50
g416
sg51
g978
sg52
g986
sg53
g994
sg54
g979
stRp1746
ag1
(g1658
g1597
(dp1747
g41
g1009
sg42
g1003
sg43
g1012
sg44
g1004
sg45
g1005
sg46
g1001
sg47
g1006
sg48
g997
sg49
g1014
sg50
g1007
sg51
g999
sg52
g1008
sg53
g1016
sg54
g1000
stRp1748
ag1
(g1658
g1597
(dp1749
g41
g1031
sg42
g1025
sg43
g1034
sg44
g1026
sg45
g1027
sg46
g1023
sg47
g1028
sg48
g1019
sg49
g1036
sg50
g1029
sg51
g1021
sg52
g1030
sg53
g1038
sg54
g1022
stRp1750
ag1
(g1658
g1597
(dp1751
g41
g1053
sg42
g1047
sg43
g1056
sg44
g1048
sg45
g1049
sg46
g1045
sg47
g1050
sg48
g1041
sg49
g1058
sg50
g1051
sg51
g1043
sg52
g1052
sg53
g1060
sg54
g1044
stRp1752
ag1
(g1658
g1597
(dp1753
g41
g1075
sg42
g1069
sg43
g1078
sg44
g1070
sg45
g1071
sg46
g1067
sg47
g1072
sg48
g1063
sg49
g1080
sg50
g1073
sg51
g1065
sg52
g1074
sg53
g1082
sg54
g1066
stRp1754
ag1
(g1658
g1597
(dp1755
g41
g1093
sg42
g1085
sg43
g1096
sg44
g1086
sg45
g1087
sg46
g1098
sg47
g1088
sg48
g1089
sg49
g1100
sg50
g1090
sg51
g1091
sg52
V 
sg53
g1102
sg54
g1092
stRp1756
ag1
(g1658
g1597
(dp1757
g41
g1112
sg42
g1104
sg43
g1115
sg44
g1105
sg45
g1106
sg46
g1117
sg47
g1107
sg48
g1108
sg49
g1119
sg50
g1109
sg51
g1110
sg52
V 
sg53
g1121
sg54
g1111
stRp1758
ag1
(g1658
g1597
(dp1759
g41
g1135
sg42
g1129
sg43
g1138
sg44
g1130
sg45
g1131
sg46
g1127
sg47
g1132
sg48
g1123
sg49
g1140
sg50
g1133
sg51
g1125
sg52
g1134
sg53
g1142
sg54
g1126
stRp1760
ag1
(g1658
g1597
(dp1761
g41
g1157
sg42
g1151
sg43
g1160
sg44
g1152
sg45
g1153
sg46
g1149
sg47
g1154
sg48
g1145
sg49
g1162
sg50
g1155
sg51
g1147
sg52
g1156
sg53
g1164
sg54
g1148
stRp1762
ag1
(g1658
g1597
(dp1763
g41
g1175
sg42
g1167
sg43
g1178
sg44
g1168
sg45
g1169
sg46
g1180
sg47
g1170
sg48
g1171
sg49
g1182
sg50
g1172
sg51
g1173
sg52
V 
sg53
g1184
sg54
g1174
stRp1764
ag1
(g1658
g1597
(dp1765
g41
g1194
sg42
g1186
sg43
g1197
sg44
g1187
sg45
g1188
sg46
g1199
sg47
g1189
sg48
g1190
sg49
g1201
sg50
g1191
sg51
g1192
sg52
V 
sg53
g1203
sg54
g1193
stRp1766
ag1
(g1658
g1597
(dp1767
g41
g1213
sg42
g1205
sg43
g1216
sg44
g1206
sg45
g1207
sg46
g1218
sg47
g1208
sg48
g1209
sg49
g1220
sg50
g1210
sg51
g1211
sg52
V 
sg53
g1222
sg54
g1212
stRp1768
ag1
(g1658
g1597
(dp1769
g41
g1236
sg42
g1230
sg43
g1239
sg44
g1231
sg45
g1232
sg46
g1228
sg47
g1233
sg48
g1224
sg49
g1241
sg50
g1234
sg51
g1226
sg52
g1235
sg53
g1243
sg54
g1227
stRp1770
ag1
(g1658
g1597
(dp1771
g41
g1258
sg42
g1252
sg43
g1261
sg44
g1253
sg45
g1254
sg46
g1250
sg47
g1255
sg48
g1246
sg49
g1263
sg50
g1256
sg51
g1248
sg52
g1257
sg53
g1265
sg54
g1249
stRp1772
ag1
(g1658
g1597
(dp1773
g41
g1280
sg42
g1274
sg43
g1283
sg44
g1275
sg45
g1276
sg46
g1272
sg47
g1277
sg48
g1268
sg49
g1285
sg50
g1278
sg51
g1270
sg52
g1279
sg53
g1287
sg54
g1271
stRp1774
ag1
(g1658
g1597
(dp1775
g41
g1298
sg42
g1290
sg43
g1301
sg44
g1291
sg45
g1292
sg46
g1303
sg47
g1293
sg48
g1294
sg49
g1305
sg50
g1295
sg51
g1296
sg52
V 
sg53
g1307
sg54
g1297
stRp1776
ag1
(g1658
g1597
(dp1777
g41
g1317
sg42
g1309
sg43
g1320
sg44
g1310
sg45
g1311
sg46
g1322
sg47
g1312
sg48
g1313
sg49
g1324
sg50
g1314
sg51
g1315
sg52
V 
sg53
g1326
sg54
g1316
stRp1778
ag1
(g1658
g1597
(dp1779
g41
g1340
sg42
g1334
sg43
g1343
sg44
g1335
sg45
g1336
sg46
g1332
sg47
g1337
sg48
g1328
sg49
g1345
sg50
g1338
sg51
g1330
sg52
g1339
sg53
g1347
sg54
g1331
stRp1780
ag1
(g1658
g1597
(dp1781
g41
g1362
sg42
g1356
sg43
g1365
sg44
g1357
sg45
g1358
sg46
g1354
sg47
g1359
sg48
g1350
sg49
g1367
sg50
g1360
sg51
g1352
sg52
g1361
sg53
g1369
sg54
g1353
stRp1782
ag1
(g1658
g1597
(dp1783
g41
g1384
sg42
g1378
sg43
g1387
sg44
g1379
sg45
g1380
sg46
g1376
sg47
g1381
sg48
g1372
sg49
g1389
sg50
g1382
sg51
g1374
sg52
g1383
sg53
g1391
sg54
g1375
stRp1784
ag1
(g1658
g1597
(dp1785
g41
g1402
sg42
g1394
sg43
g1405
sg44
g1395
sg45
g1396
sg46
g1407
sg47
g1397
sg48
g1398
sg49
g1409
sg50
g1399
sg51
g1400
sg52
V 
sg53
g1411
sg54
g1401
stRp1786
ag1
(g1658
g1597
(dp1787
g41
g1425
sg42
g1419
sg43
g1428
sg44
g1420
sg45
g1421
sg46
g1417
sg47
g1422
sg48
g1413
sg49
g1430
sg50
g1423
sg51
g1415
sg52
g1424
sg53
g1432
sg54
g1416
stRp1788
ag1
(g1658
g1597
(dp1789
g41
g1447
sg42
g1441
sg43
g1450
sg44
g1442
sg45
g1443
sg46
g1439
sg47
g1444
sg48
g1435
sg49
g1452
sg50
g1445
sg51
g1437
sg52
g1446
sg53
g1454
sg54
g1438
stRp1790
ag1
(g1658
g1597
(dp1791
g41
g1465
sg42
g1457
sg43
g1468
sg44
g1458
sg45
g1459
sg46
g1470
sg47
g1460
sg48
g1461
sg49
g1472
sg50
g1462
sg51
g1463
sg52
V 
sg53
g1474
sg54
g1464
stRp1792
ag1
(g1658
g1597
(dp1793
g41
g1488
sg42
g1482
sg43
g1491
sg44
g1483
sg45
g1484
sg46
g1480
sg47
g1485
sg48
g1476
sg49
g1493
sg50
g1486
sg51
g1478
sg52
g1487
sg53
g1495
sg54
g1479
stRp1794
ag1
(g1658
g1597
(dp1795
g41
g1506
sg42
g1498
sg43
g1509
sg44
g1499
sg45
g1500
sg46
g1511
sg47
g1501
sg48
g1502
sg49
g1513
sg50
g1503
sg51
g1504
sg52
V 
sg53
g1515
sg54
g1505
stRp1796
ag1
(g1658
g1597
(dp1797
g41
g1525
sg42
g1517
sg43
g1528
sg44
g1518
sg45
g1519
sg46
g1530
sg47
g1520
sg48
g1521
sg49
g1532
sg50
g1522
sg51
g1523
sg52
V 
sg53
g1534
sg54
g1524
stRp1798
ag1
(g1658
g1597
(dp1799
g41
g1548
sg42
g1542
sg43
g1551
sg44
g1543
sg45
g1544
sg46
g1540
sg47
g1545
sg48
g1536
sg49
g1553
sg50
g1546
sg51
g1538
sg52
g1547
sg53
g1555
sg54
g1539
stRp1800
ag1
(g1658
g1597
(dp1801
g41
g1570
sg42
g1564
sg43
g1573
sg44
g1565
sg45
g1566
sg46
g1562
sg47
g1567
sg48
g1558
sg49
g1575
sg50
g1568
sg51
g1560
sg52
g1569
sg53
g1577
sg54
g1561
stRp1802
asS'seed'
p1803
NsS'thisIndex'
p1804
g1572
sS'thisN'
p1805
I72
sS'thisTrialN'
p1806
I0
sS'nTotal'
p1807
I72
sS'_warnUseOfNext'
p1808
I01
sbasS'savePickle'
p1809
I00
sb.